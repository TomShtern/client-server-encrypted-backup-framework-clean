"""
Dashboard View - Advanced dashboard with real server integration and performance optimization.

Organization:
    - Section 1: Data Fetching (async wrappers with run_in_executor)
    - Section 2: Business Logic (pure functions for metric calculations)
    - Section 3: UI Components (Flet control builders)
    - Section 4: Event Handlers (user interaction handlers)
    - Section 5: Main View (view composition and setup)
"""

import asyncio
import contextlib
import logging
import os
import sys
import time
from datetime import datetime
from typing import Any, Callable, Optional

# Path setup
_views_dir = os.path.dirname(os.path.abspath(__file__))
_flet_v2_root = os.path.dirname(_views_dir)
_repo_root = os.path.dirname(_flet_v2_root)
for _path in (_flet_v2_root, _repo_root):
    if _path not in sys.path:
        sys.path.insert(0, _path)

import flet as ft
import Shared.utils.utf8_solution as _  # noqa: F401

# Import new utilities
from utils.async_helpers_exp import run_sync_in_executor, fetch_with_loading, debounce
from utils.loading_states import create_loading_indicator, create_error_display, show_success_snackbar, show_error_snackbar
from utils.data_export import export_to_json, generate_export_filename
from utils.ui_builders import create_action_button
from theme import (
    # Pre-computed neumorphic shadows (40-45% intensity)
    PRONOUNCED_NEUMORPHIC_SHADOWS,
    MODERATE_NEUMORPHIC_SHADOWS,
    SUBTLE_NEUMORPHIC_SHADOWS,
    # Glassmorphic configuration constants (20-30% intensity)
    GLASS_STRONG,
    GLASS_MODERATE,
    GLASS_SUBTLE,
    # Helper functions
    get_neumorphic_shadows,
    create_glassmorphic_container,
    create_glassmorphic_overlay,
    create_hover_animation
)

# Setup logging
logger = logging.getLogger(__name__)

# ------------------------------------------------------------------------------------
# SECTION 1: DATA FETCHING (Async wrappers for ServerBridge calls with proper run_in_executor)
# ------------------------------------------------------------------------------------

async def fetch_dashboard_summary_async(bridge):
    """Fetch dashboard summary data."""
    if not bridge:
        return {'success': False, 'data': {}, 'error': 'No server bridge available'}
    
    try:
        result = await run_sync_in_executor(bridge.get_dashboard_summary)
        return result
    except Exception as e:
        return {'success': False, 'data': {}, 'error': str(e)}

async def fetch_system_status_async(bridge):
    """Fetch system status information."""
    if not bridge:
        return {'success': False, 'data': {}, 'error': 'No server bridge available'}
    
    try:
        result = await run_sync_in_executor(bridge.get_system_status)
        return result
    except Exception as e:
        return {'success': False, 'data': {}, 'error': str(e)}

async def fetch_performance_metrics_async(bridge):
    """Fetch performance metrics."""
    if not bridge:
        return {'success': False, 'data': {}, 'error': 'No server bridge available'}
    
    try:
        result = await run_sync_in_executor(bridge.get_performance_metrics)
        return result
    except Exception as e:
        return {'success': False, 'data': {}, 'error': str(e)}

async def fetch_server_statistics_async(bridge):
    """Fetch server statistics."""
    if not bridge:
        return {'success': False, 'data': {}, 'error': 'No server bridge available'}
    
    try:
        result = await run_sync_in_executor(bridge.get_server_statistics)
        return result
    except Exception as e:
        return {'success': False, 'data': {}, 'error': str(e)}

async def fetch_recent_activity_async(bridge, limit=10):
    """Fetch recent system activity."""
    if not bridge:
        return {'success': False, 'data': [], 'error': 'No server bridge available'}
    
    try:
        result = await run_sync_in_executor(bridge.get_recent_activity, limit)
        return result
    except Exception as e:
        return {'success': False, 'data': [], 'error': str(e)}

# ------------------------------------------------------------------------------------
# SECTION 2: BUSINESS LOGIC (Pure functions for metric calculations and data processing)
# ------------------------------------------------------------------------------------

def calculate_metrics_summary(dashboard_data, system_data, performance_data, stats_data):
    """Calculate and combine all dashboard metrics."""
    # Extract data from each source
    dashboard_metrics = dashboard_data.get('data', {})
    system_metrics = system_data.get('data', {})
    performance_metrics = performance_data.get('data', {})
    stats_metrics = stats_data.get('data', {})
    
    # Combine all metrics into a single summary
    summary = {
        'clients_count': dashboard_metrics.get('clients_count', 0),
        'files_count': dashboard_metrics.get('files_count', 0),
        'total_storage': dashboard_metrics.get('total_storage', 0),
        'uptime': system_metrics.get('uptime', 'Unknown'),
        'server_status': system_metrics.get('server_status', 'Unknown'),
        'cpu_usage': performance_metrics.get('cpu_usage', 0),
        'memory_usage': performance_metrics.get('memory_usage', 0),
        'network_usage': performance_metrics.get('network_usage', 0),
        'backup_success_rate': stats_metrics.get('backup_success_rate', 0),
        'active_sessions': stats_metrics.get('active_sessions', 0),
        'pending_operations': stats_metrics.get('pending_operations', 0),
    }
    
    return summary

def format_storage_value(bytes_value):
    """Format storage value in human-readable format."""
    if bytes_value is None:
        return "0 B"
    
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_value < 1024.0:
            return f"{bytes_value:.2f} {unit}"
        bytes_value /= 1024.0
    return f"{bytes_value:.2f} PB"

def format_duration(seconds):
    """Format duration in seconds to human-readable format."""
    if seconds is None:
        return "Unknown"
    
    days = int(seconds // 86400)
    seconds = seconds % 86400
    hours = int(seconds // 3600)
    seconds = seconds % 3600
    minutes = int(seconds // 60)
    seconds = int(seconds % 60)
    
    if days > 0:
        return f"{days}d {hours}h {minutes}m"
    elif hours > 0:
        return f"{hours}h {minutes}m {seconds}s"
    elif minutes > 0:
        return f"{minutes}m {seconds}s"
    else:
        return f"{seconds}s"

def get_status_color(status):
    """Get color based on status."""
    status_colors = {
        'Connected': ft.colors.GREEN,
        'Disconnected': ft.colors.RED,
        'Offline': ft.colors.RED,
        'Online': ft.colors.GREEN,
        'Active': ft.colors.GREEN,
        'Inactive': ft.colors.AMBER,
        'Unknown': ft.colors.GREY
    }
    return status_colors.get(status, ft.colors.GREY)

def process_activity_logs(activity_data):
    """Process and format activity logs for display."""
    if not activity_data or not activity_data.get('success'):
        return []
    
    logs = activity_data.get('data', [])
    processed_logs = []
    
    for log in logs:
        processed_log = {
            'timestamp': log.get('timestamp', ''),
            'type': log.get('type', 'Info'),
            'message': log.get('message', ''),
            'source': log.get('source', 'System')
        }
        processed_logs.append(processed_log)
    
    return processed_logs

# ------------------------------------------------------------------------------------
# SECTION 3: UI COMPONENTS (Flet control builders - pure UI, no business logic)
# ------------------------------------------------------------------------------------

def create_metric_card(title, value, subtitle=None, icon=None, color=ft.colors.PRIMARY):
    """Create a standardized metric card."""
    card_content = [
        ft.Row([
            ft.Icon(icon, color=color, size=30) if icon else ft.Container(width=30),
            ft.Text(title, size=14, color=ft.colors.ON_SURFACE_VARIANT)
        ], alignment=ft.MainAxisAlignment.START),
        ft.Text(str(value), size=24, weight=ft.FontWeight.BOLD, color=ft.colors.ON_SURFACE),
    ]
    
    if subtitle:
        card_content.append(ft.Text(subtitle, size=12, color=ft.colors.ON_SURFACE_VARIANT))
    
    return ft.Container(
        content=ft.Column(card_content, spacing=5),
        padding=20,
        border_radius=12,
        bgcolor=ft.colors.SURFACE_VARIANT,
        shadow=ft.BoxShadow(
            spread_radius=0,
            blur_radius=8,
            color=ft.colors.BLACK.with_opacity(0.1),
            offset=ft.Offset(0, 2)
        )
    )

def create_gauge_card(title, value, max_value, icon=None, color=ft.colors.PRIMARY):
    """Create a gauge card for visualizing metrics."""
    percentage = min(100, max(0, (value / max_value) * 100)) if max_value > 0 else 0
    
    return ft.Container(
        content=ft.Column([
            ft.Row([
                ft.Icon(icon, color=color, size=24) if icon else ft.Container(width=24),
                ft.Text(title, size=14, color=ft.colors.ON_SURFACE_VARIANT)
            ], alignment=ft.MainAxisAlignment.CENTER),
            ft.Container(
                content=ft.Stack([
                    ft.Icon(ft.icons.CIRCLE, size=80, color=ft.colors.OUTLINE_VARIANT),
                    ft.Icon(
                        ft.icons.CIRCLE, 
                        size=80, 
                        color=color,
                        rotate=ft.Rotate((percentage / 100) * 3.14159 * 2)
                    ),
                    ft.Column([
                        ft.Text(f"{int(percentage)}%", size=16, weight=ft.FontWeight.BOLD),
                        ft.Text(title, size=10)
                    ], horizontal_alignment=ft.CrossAxisAlignment.CENTER, alignment=ft.MainAxisAlignment.CENTER)
                ])
            ),
            ft.Text(f"{value}/{max_value}", size=12, text_align=ft.TextAlign.CENTER)
        ], horizontal_alignment=ft.CrossAxisAlignment.CENTER, spacing=10),
        padding=20,
        border_radius=12,
        bgcolor=ft.colors.SURFACE_VARIANT,
        shadow=ft.BoxShadow(
            spread_radius=0,
            blur_radius=8,
            color=ft.colors.BLACK.with_opacity(0.1),
            offset=ft.Offset(0, 2)
        )
    )

def create_status_indicator(status_text, status_color):
    """Create a status indicator with colored dot and text."""
    return ft.Row([
        ft.Container(
            width=12,
            height=12,
            border_radius=6,
            bgcolor=status_color
        ),
        ft.Text(status_text, size=14)
    ], spacing=8)

def create_activity_log_item(activity):
    """Create a single activity log item."""
    return ft.ListTile(
        leading=ft.Icon(ft.icons.NOTIFICATION_NONE, color=ft.colors.BLUE),
        title=ft.Text(activity.get('message', 'No message'), size=14),
        subtitle=ft.Text(f"{activity.get('timestamp', 'Unknown')} - {activity.get('source', 'System')}", size=12),
        dense=True
    )

def create_refresh_button(on_refresh_callback):
    """Create a standardized refresh button."""
    return ft.IconButton(
        icon=ft.icons.REFRESH,
        tooltip="Refresh dashboard",
        on_click=on_refresh_callback
    )

def create_export_button(on_export_callback):
    """Create a standardized export button."""
    return ft.IconButton(
        icon=ft.icons.DOWNLOAD,
        tooltip="Export dashboard data",
        on_click=on_export_callback
    )

# ------------------------------------------------------------------------------------
# SECTION 4: EVENT HANDLERS (User interaction handlers - coordinate between UI and business logic)
# ------------------------------------------------------------------------------------

async def handle_refresh_clicked(e, state, page_refs, page):
    """Handle refresh button click to update all dashboard data."""
    # Show loading indicator
    if page_refs['loading_indicator']:
        page_refs['loading_indicator'].visible = True
        page_refs['loading_indicator'].update()
    
    # Update last refresh time
    if page_refs['last_update']:
        page_refs['last_update'].value = f"Last updated: {datetime.now().strftime('%H:%M:%S')}"
        page_refs['last_update'].update()
    
    try:
        # Fetch all data concurrently
        dashboard_task = fetch_dashboard_summary_async(state['bridge'])
        system_task = fetch_system_status_async(state['bridge'])
        performance_task = fetch_performance_metrics_async(state['bridge'])
        stats_task = fetch_server_statistics_async(state['bridge'])
        activity_task = fetch_recent_activity_async(state['bridge'])
        
        dashboard_data, system_data, performance_data, stats_data, activity_data = await asyncio.gather(
            dashboard_task, system_task, performance_task, stats_task, activity_task
        )
        
        # Calculate metrics
        metrics = calculate_metrics_summary(dashboard_data, system_data, performance_data, stats_data)
        activity_logs = process_activity_logs(activity_data)
        
        # Update state
        state['metrics'] = metrics
        state['activity_logs'] = activity_logs
        
        # Update UI components using refs
        if page_refs['clients_count_ref']:
            page_refs['clients_count_ref'].value = str(metrics.get('clients_count', 0))
            page_refs['clients_count_ref'].update()
        
        if page_refs['files_count_ref']:
            page_refs['files_count_ref'].value = str(metrics.get('files_count', 0))
            page_refs['files_count_ref'].update()
        
        if page_refs['storage_value_ref']:
            storage_formatted = format_storage_value(metrics.get('total_storage', 0))
            page_refs['storage_value_ref'].value = storage_formatted
            page_refs['storage_value_ref'].update()
        
        if page_refs['uptime_value_ref']:
            uptime_formatted = format_duration(metrics.get('uptime', 0))
            page_refs['uptime_value_ref'].value = uptime_formatted
            page_refs['uptime_value_ref'].update()
        
        # Update activity list if available
        if page_refs['activity_list_ref'] and activity_logs:
            page_refs['activity_list_ref'].controls = [
                create_activity_log_item(log) for log in activity_logs
            ]
            page_refs['activity_list_ref'].update()
        
        # Update status indicators
        if page_refs['server_status_ref']:
            server_status = metrics.get('server_status', 'Unknown')
            status_color = get_status_color(server_status)
            page_refs['server_status_ref'].content = create_status_indicator(server_status, status_color)
            page_refs['server_status_ref'].update()
        
        # Hide loading indicator
        if page_refs['loading_indicator']:
            page_refs['loading_indicator'].visible = False
            page_refs['loading_indicator'].update()
            
    except Exception as ex:
        logger.error(f"Error refreshing dashboard: {ex}")
        if page_refs['loading_indicator']:
            page_refs['loading_indicator'].visible = False
            page_refs['loading_indicator'].update()

async def handle_export_clicked(e, state, page):
    """Handle export button click."""
    # Prepare data for export
    export_data = {
        'timestamp': datetime.now().isoformat(),
        'metrics': state.get('metrics', {}),
        'activity_logs': state.get('activity_logs', [])
    }
    
    # Generate filename
    filename = generate_export_filename("dashboard", "json")
    
    try:
        export_to_json([export_data], filename)
        show_success_snackbar(page, f"Dashboard exported to {filename}")
    except Exception as ex:
        show_error_snackbar(page, f"Export failed: {str(ex)}")

# ------------------------------------------------------------------------------------
# SECTION 5: MAIN VIEW (View composition and setup - orchestrates everything)
# ------------------------------------------------------------------------------------

def create_dashboard_view(page, bridge):
    """Create the advanced dashboard view with all functionality."""
    
    # State management
    state = {
        'bridge': bridge,
        'metrics': {},
        'activity_logs': [],
        'refresh_interval': 30,  # seconds
    }
    
    # UI container
    main_container = ft.Container(expand=True, padding=20)
    
    # Create refs for targeted updates
    refs = {
        'clients_count_ref': ft.Ref[ft.Text](),
        'files_count_ref': ft.Ref[ft.Text](),
        'storage_value_ref': ft.Ref[ft.Text](),
        'uptime_value_ref': ft.Ref[ft.Text](),
        'last_update': ft.Ref[ft.Text](),
        'loading_indicator': ft.Ref[ft.ProgressRing](),
        'server_status_ref': ft.Ref[ft.Container](),
        'activity_list_ref': ft.Ref[ft.ListView](),
    }
    
    # Create UI components
    header_row = ft.Row([
        ft.Text("Dashboard", size=30, weight=ft.FontWeight.BOLD),
        ft.Row([
            create_refresh_button(lambda e: handle_refresh_clicked(e, state, refs, page)),
            create_export_button(lambda e: handle_export_clicked(e, state, page))
        ], spacing=5)
    ], alignment=ft.MainAxisAlignment.SPACE_BETWEEN)
    
    # Metric cards
    metric_cards_row = ft.Row([
        create_metric_card("Clients", "0", "Connected", ft.icons.PERSON, ft.colors.BLUE),
        create_metric_card("Files", "0", "Backed up", ft.icons.FILE_PRESENT, ft.colors.GREEN),
        create_metric_card("Storage", "0 GB", "Used", ft.icons.STORAGE, ft.colors.PURPLE),
        create_metric_card("Uptime", "0d 0h 0m", "Running", ft.icons.ACCESS_TIME, ft.colors.ORANGE)
    ], alignment=ft.MainAxisAlignment.CENTER, spacing=20)
    
    # Gauge cards
    gauge_cards_row = ft.Row([
        create_gauge_card("CPU Usage", 0, 100, ft.icons.DEVICES, ft.colors.RED),
        create_gauge_card("Memory", 0, 100, ft.icons.MEMORY, ft.colors.AMBER),
        create_gauge_card("Network", 0, 100, ft.icons.SIGNAL_CELLULAR_ALT, ft.colors.TEAL)
    ], alignment=ft.MainAxisAlignment.CENTER, spacing=20)
    
    # Status and activity section
    status_section = ft.Column([
        ft.Text("System Status", size=20, weight=ft.FontWeight.BOLD),
        ft.Divider(),
        ft.Row([
            ft.Column([
                ft.Text("Server Status", weight=ft.FontWeight.BOLD),
                ft.Container(
                    content=create_status_indicator("Unknown", ft.colors.GREY),
                    ref=refs['server_status_ref']
                )
            ]),
            ft.Column([
                ft.Text("Last Update", weight=ft.FontWeight.BOLD),
                ft.Text("Never", ref=refs['last_update'])
            ])
        ], spacing=20),
        ft.Divider(),
        ft.Text("Recent Activity", size=20, weight=ft.FontWeight.BOLD),
        ft.ListView(
            controls=[],
            height=300,
            spacing=5,
            ref=refs['activity_list_ref']
        )
    ])
    
    # Loading indicator
    loading_indicator = ft.ProgressRing(visible=False, ref=refs['loading_indicator'])
    
    # Main layout
    main_layout = ft.Column([
        header_row,
        loading_indicator,
        metric_cards_row,
        gauge_cards_row,
        status_section
    ], spacing=20, expand=True)
    
    main_container.content = main_layout
    
    # Setup function
    async def setup():
        """Setup the dashboard with initial data."""
        try:
            # Show loading state
            main_container.content = ft.Column([
                ft.Text("Loading Dashboard...", size=24, text_align=ft.TextAlign.CENTER),
                ft.ProgressRing()
            ], alignment=ft.MainAxisAlignment.CENTER, horizontal_alignment=ft.CrossAxisAlignment.CENTER, expand=True)
            page.update()
            
            # Fetch initial data
            dashboard_task = fetch_dashboard_summary_async(bridge)
            system_task = fetch_system_status_async(bridge)
            performance_task = fetch_performance_metrics_async(bridge)
            stats_task = fetch_server_statistics_async(bridge)
            activity_task = fetch_recent_activity_async(bridge)
            
            dashboard_data, system_data, performance_data, stats_data, activity_data = await asyncio.gather(
                dashboard_task, system_task, performance_task, stats_task, activity_task
            )
            
            # Calculate metrics
            metrics = calculate_metrics_summary(dashboard_data, system_data, performance_data, stats_data)
            activity_logs = process_activity_logs(activity_data)
            
            # Update state
            state['metrics'] = metrics
            state['activity_logs'] = activity_logs
            
            # Update UI with initial data
            if refs['clients_count_ref'].current:
                refs['clients_count_ref'].current.value = str(metrics.get('clients_count', 0))
                
            if refs['files_count_ref'].current:
                refs['files_count_ref'].current.value = str(metrics.get('files_count', 0))
                
            if refs['storage_value_ref'].current:
                storage_formatted = format_storage_value(metrics.get('total_storage', 0))
                refs['storage_value_ref'].current.value = storage_formatted
                
            if refs['uptime_value_ref'].current:
                uptime_formatted = format_duration(metrics.get('uptime', 0))
                refs['uptime_value_ref'].current.value = uptime_formatted
                
            if refs['last_update'].current:
                refs['last_update'].current.value = f"Last updated: {datetime.now().strftime('%H:%M:%S')}"
                
            if refs['server_status_ref'].current:
                server_status = metrics.get('server_status', 'Unknown')
                status_color = get_status_color(server_status)
                refs['server_status_ref'].current.content = create_status_indicator(server_status, status_color)
                
            if refs['activity_list_ref'].current and activity_logs:
                refs['activity_list_ref'].current.controls = [
                    create_activity_log_item(log) for log in activity_logs
                ]
            
            # Update main container with the proper layout
            main_container.content = main_layout
            page.update()
            
            # Update individual components that have values
            if refs['clients_count_ref'].current:
                refs['clients_count_ref'].current.update()
            if refs['files_count_ref'].current:
                refs['files_count_ref'].current.update()
            if refs['storage_value_ref'].current:
                refs['storage_value_ref'].current.update()
            if refs['uptime_value_ref'].current:
                refs['uptime_value_ref'].current.update()
            if refs['last_update'].current:
                refs['last_update'].current.update()
            if refs['server_status_ref'].current:
                refs['server_status_ref'].current.update()
            if refs['activity_list_ref'].current:
                refs['activity_list_ref'].current.update()
                
        except Exception as e:
            logger.error(f"Error in dashboard setup: {e}")
            main_container.content = create_error_display(f"Dashboard setup failed: {str(e)}")
            page.update()
    
    # Dispose function
    def dispose():
        """Dispose of resources."""
        # Stop any background tasks if they exist
        pass
    
    # Return the dashboard view components
    return main_container, dispose, setup