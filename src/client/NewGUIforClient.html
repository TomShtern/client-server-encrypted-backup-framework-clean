<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberBackup Pro - v3.0 (API Driven)</title>
    <style>
        /* CRITICAL FIX: Move @import to top */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono:wght@400&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Enhanced Cyberpunk Color Palette */
            --neon-pink: #FF00FF;
            --neon-blue: #00FFFF;
            --neon-purple: #8A2BE2;
            --neon-green: #00FF00;
            --neon-yellow: #FFFF00;
            --neon-orange: #FF4500;
            --neon-red: #FF0040;
            --electric-blue: #0080FF;
            --cyber-lime: #32CD32;
            --plasma-pink: #FF1493;
            
            /* Glow Effects */
            --glow-blue: 0 0 20px var(--neon-blue), 0 0 40px var(--neon-blue), 0 0 80px var(--neon-blue);
            --glow-green: 0 0 20px var(--neon-green), 0 0 40px var(--neon-green), 0 0 80px var(--neon-green);
            --glow-pink: 0 0 20px var(--neon-pink), 0 0 40px var(--neon-pink), 0 0 80px var(--neon-pink);
            --glow-purple: 0 0 20px var(--neon-purple), 0 0 40px var(--neon-purple), 0 0 80px var(--neon-purple);
            --glow-yellow: 0 0 20px var(--neon-yellow), 0 0 40px var(--neon-yellow), 0 0 80px var(--neon-yellow);
            --glow-orange: 0 0 20px var(--neon-orange), 0 0 40px var(--neon-orange), 0 0 80px var(--neon-orange);
            --glow-red: 0 0 20px var(--neon-red), 0 0 40px var(--neon-red), 0 0 80px var(--neon-red);
            
            --bg-black: #000000;
            --bg-dark: #0A0A0A;
            --bg-medium: #1A1A2E;
            --bg-light: #16213E;
            --bg-card: rgba(26, 26, 46, 0.95);
            --bg-glass: rgba(255, 255, 255, 0.05);
            
            --text-primary: #FFFFFF;
            --text-secondary: #E0E0E0;
            --text-dim: #888888;
            --text-contrast: rgba(0, 0, 0, 0.8);
            
            --success: var(--neon-green);
            --warning: var(--neon-yellow);
            --error: var(--neon-red);
            --info: var(--neon-blue);
            
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-border-active: rgba(0, 255, 255, 0.6);
            
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-fast: all 0.15s ease-out;
            
            /* Improved Spacing System */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            
            /* Enhanced Border Radius System */
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            
            /* Material Design Elevation System */
            --elevation-1: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
            --elevation-2: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
            --elevation-4: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);
            --elevation-8: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
            --elevation-16: 0 19px 38px rgba(0, 0, 0, 0.30), 0 15px 12px rgba(0, 0, 0, 0.22);
            --elevation-24: 0 24px 48px rgba(0, 0, 0, 0.35), 0 20px 15px rgba(0, 0, 0, 0.22);
            
            /* Material Design with Cyberpunk Glow Elevations */
            --md-elevation-1: var(--elevation-1), 0 0 4px rgba(0, 255, 255, 0.1);
            --md-elevation-2: var(--elevation-2), 0 0 8px rgba(0, 255, 255, 0.15);
            --md-elevation-4: var(--elevation-4), 0 0 12px rgba(0, 255, 255, 0.2);
            --md-elevation-8: var(--elevation-8), 0 0 16px rgba(0, 255, 255, 0.25);
            --md-elevation-16: var(--elevation-16), 0 0 20px rgba(0, 255, 255, 0.3);
            --md-elevation-24: var(--elevation-24), 0 0 24px rgba(0, 255, 255, 0.35);
            
            /* Material Design Typography Scale */
            --font-size-h1: 3.5rem;    /* 56px */
            --font-size-h2: 2.125rem;  /* 34px */
            --font-size-h3: 1.5rem;    /* 24px */
            --font-size-h4: 1.25rem;   /* 20px */
            --font-size-h5: 1.125rem;  /* 18px */
            --font-size-h6: 1rem;      /* 16px */
            --font-size-subtitle1: 1rem;
            --font-size-subtitle2: 0.875rem;
            --font-size-body1: 1rem;
            --font-size-body2: 0.875rem;
            --font-size-button: 0.875rem;
            --font-size-caption: 0.75rem;
            --font-size-overline: 0.625rem;
            
            /* Typography Line Heights */
            --line-height-tight: 1.2;
            --line-height-normal: 1.4;
            --line-height-relaxed: 1.6;
            --line-height-loose: 1.8;
            
            /* Typography Font Weights */
            --font-weight-light: 300;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 600;
            --font-weight-bold: 700;
            --font-weight-black: 900;
            
            /* Enhanced Material Design 8px Grid Spacing */
            --space-0: 0;
            --space-1: 0.125rem;   /* 2px */
            --space-2: 0.25rem;    /* 4px */
            --space-3: 0.375rem;   /* 6px */
            --space-4: 0.5rem;     /* 8px */
            --space-5: 0.625rem;   /* 10px */
            --space-6: 0.75rem;    /* 12px */
            --space-8: 1rem;       /* 16px */
            --space-10: 1.25rem;   /* 20px */
            --space-12: 1.5rem;    /* 24px */
            --space-16: 2rem;      /* 32px */
            --space-20: 2.5rem;    /* 40px */
            --space-24: 3rem;      /* 48px */
            --space-32: 4rem;      /* 64px */
            
            /* Material Design Surface Colors with Cyberpunk Twist */
            --surface-00: rgba(26, 26, 46, 0.95);  /* Default surface */
            --surface-01: rgba(26, 26, 46, 0.97);  /* 1dp elevation */
            --surface-02: rgba(30, 30, 50, 0.98);  /* 2dp elevation */
            --surface-04: rgba(34, 34, 54, 0.99);  /* 4dp elevation */
            --surface-06: rgba(38, 38, 58, 1.0);   /* 6dp elevation */
            --surface-08: rgba(42, 42, 62, 1.0);   /* 8dp elevation */
            --surface-12: rgba(46, 46, 66, 1.0);   /* 12dp elevation */
            --surface-16: rgba(50, 50, 70, 1.0);   /* 16dp elevation */
            --surface-24: rgba(54, 54, 74, 1.0);   /* 24dp elevation */
        }

        /* Performance Utility Classes - Replace direct style manipulation */
        .u-hidden { display: none !important; }
        .u-visible { display: block !important; }
        .u-flex { display: flex !important; }
        .u-inline-flex { display: inline-flex !important; }
        
        /* Screen reader only utility */
        .u-sr-only {
            position: absolute !important;
            left: -10000px !important;
            width: 1px !important;
            height: 1px !important;
            overflow: hidden !important;
        }
        
        /* Debug entry color classes */
        .u-text-gray { color: #666 !important; }
        .u-text-light-gray { color: #ccc !important; }

        body {
            font-family: 'Orbitron', 'Share Tech Mono', monospace;
            background: var(--bg-black);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto; /* Ensure proper scrolling */
            position: relative;
            font-size: 1.125rem; /* Increased base font size */
        }

        /* Enhanced Animated Background */
        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(0, 255, 0, 0.1) 0%, transparent 50%),
                linear-gradient(var(--neon-pink) 1px, transparent 1px),
                linear-gradient(90deg, var(--neon-blue) 1px, transparent 1px);
            background-size: 
                100% 100%,
                100% 100%,
                100% 100%,
                100px 100px,
                100px 100px;
            opacity: 0.1;
            will-change: transform;
            animation: cyber-grid-flow 30s linear infinite;
        }

        @keyframes cyber-grid-flow {
            0% { 
                transform: translate3d(0, 0, 0) rotate(0deg);
            }
            100% { 
                transform: translate3d(100px, 100px, 0) rotate(0.5deg);
            }
        }

        /* Enhanced Neon Text Effects */
        .neon-text {
            position: relative;
            color: var(--text-primary);
            text-shadow: var(--glow-blue);
            will-change: opacity;
            animation: neon-flicker 3s ease-in-out infinite alternate;
        }

        .neon-text.pink { 
            color: var(--neon-pink);
            text-shadow: var(--glow-pink);
        }

        .neon-text.green { 
            color: var(--neon-green);
            text-shadow: var(--glow-green);
        }

        .neon-text.purple { 
            color: var(--neon-purple);
            text-shadow: var(--glow-purple);
        }

        @keyframes neon-flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
            }
            20%, 24%, 55% {        
                opacity: 0.4;
            }
        }

        /* Enhanced Accessibility: Better contrast backgrounds */
        .text-with-contrast {
            background: var(--text-contrast);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        /* IMPROVED CONTAINER - Better Spacing and Responsive Grid */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: var(--space-16) var(--space-16) var(--space-24); /* Enhanced spacing with Material Design */
            display: grid;
            grid-template-columns: minmax(300px, 1fr) minmax(400px, 2fr) minmax(350px, 1fr);
            grid-template-rows: auto 1fr auto;
            gap: var(--space-16); /* Material Design grid spacing */
            min-height: 100vh;
            grid-template-areas: 
                "header header header"
                "config main status"
                "debug debug debug";
        }

        /* Enhanced Glass Card with Material Design Elevation and Cyberpunk Aesthetics */
        .glass-card {
            background: var(--surface-02);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border: 2px solid transparent;
            border-radius: 12px; /* Material Design rounded corners */
            padding: var(--space-16);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1); /* Material Design easing */
            background-clip: padding-box;
            /* Material Design elevation 2dp with cyberpunk glow */
            box-shadow: var(--md-elevation-2);
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                var(--neon-pink), var(--neon-blue), var(--neon-purple), 
                var(--neon-green), var(--neon-yellow), var(--neon-pink));
            background-size: 400% 400%;
            border-radius: calc(var(--radius-xl) + 3px);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
            animation: rgb-border-cycle 4s ease-in-out infinite;
        }

        .glass-card:hover::before,
        .glass-card.active::before {
            opacity: 0.7;
        }

        .glass-card:hover {
            transform: translateY(-4px); /* Enhanced Material Design lift */
            background: var(--surface-04);
            /* Material Design elevation 8dp with enhanced cyberpunk glow */
            box-shadow: var(--md-elevation-8);
        }
        
        /* Material Design card variants */
        .glass-card.elevated {
            box-shadow: var(--md-elevation-4);
        }
        
        .glass-card.elevated:hover {
            box-shadow: var(--md-elevation-16);
            transform: translateY(-6px);
        }
        
        .glass-card.outlined {
            border: 1px solid var(--glass-border);
            box-shadow: var(--md-elevation-1);
        }
        
        .glass-card.outlined:hover {
            border-color: var(--neon-blue);
            box-shadow: var(--md-elevation-4);
        }

        @keyframes rgb-border-cycle {
            0%, 100% { transform: translateX(0%); }
            50% { transform: translateX(100%); }
        }

        /* Particle Effect Container */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--neon-blue);
            border-radius: 50%;
            animation: particle-float 3s linear infinite;
        }

        @keyframes particle-float {
            0% {
                transform: translate3d(0, 100vh, 0) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translate3d(0, -10vh, 0) scale(1);
                opacity: 0;
            }
        }

        /* Enhanced Header - Better Layout */
        .header {
            grid-area: header;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xl);
            border-bottom: 3px solid transparent;
            background: linear-gradient(90deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
            position: relative;
            border-image: linear-gradient(90deg, var(--neon-pink), var(--neon-blue), var(--neon-purple)) 1;
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-md);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }

        .logo-icon {
            font-size: 2.5rem;
            animation: logo-pulse 4s ease-in-out infinite;
            color: var(--neon-pink);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .logo-icon:hover {
            transform: scale(1.1);
            filter: drop-shadow(var(--glow-pink));
        }

        .logo-icon:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 4px;
        }

        @keyframes logo-pulse {
            0%, 100% { 
                transform: scale3d(1, 1, 1);
                color: var(--neon-pink);
            }
            25% { 
                transform: scale3d(1.05, 1.05, 1);
                color: var(--neon-blue);
            }
            50% { 
                transform: scale3d(1.1, 1.1, 1);
                color: var(--neon-purple);
            }
            75% { 
                transform: scale3d(1.05, 1.05, 1);
                color: var(--neon-green);
            }
        }

        .logo-text h1 {
            font-size: var(--font-size-h2);
            font-weight: var(--font-weight-black);
            line-height: var(--line-height-tight);
            color: var(--neon-pink);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: var(--space-2);
            position: relative;
        }

        .logo-text .subtitle {
            font-size: 0.875rem;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Share Tech Mono', monospace;
        }

        /* Enhanced Connection Status with Icons */
        .connection-status {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            padding: var(--space-lg) var(--space-xl);
            background: var(--bg-card);
            border-radius: 50px;
            border: 2px solid var(--glass-border);
            transition: var(--transition);
        }

        .connection-status:hover {
            border-color: var(--glass-border-active);
            box-shadow: var(--glow-blue);
        }

        .status-led {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            background: var(--error);
            position: relative;
            animation: pulse-error 2s infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            box-shadow: 
                0 0 10px rgba(255, 0, 64, 0.4),
                0 0 20px rgba(255, 0, 64, 0.2);
        }

        .status-led.connected {
            background: var(--success);
            animation: pulse-success 2s infinite;
            box-shadow: 
                var(--glow-green),
                0 0 15px rgba(0, 255, 0, 0.4);
        }

        .status-led.connecting {
            background: var(--warning);
            animation: pulse-warning 1s infinite;
            box-shadow: 
                0 0 10px rgba(255, 255, 0, 0.4),
                0 0 20px rgba(255, 255, 0, 0.2);
        }

        .status-led.connected::after {
            content: '‚úì';
        }

        .status-led.connecting::after {
            content: '‚ü≥';
            animation: spin 1s linear infinite;
        }

        .status-led:not(.connected):not(.connecting)::after {
            content: '‚úó';
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes pulse-success {
            0%, 100% { 
                transform: scale3d(1, 1, 1);
                opacity: 0.8;
            }
            50% { 
                transform: scale3d(1.05, 1.05, 1);
                opacity: 1;
            }
        }

        @keyframes pulse-error {
            0%, 100% { 
                transform: scale3d(1, 1, 1);
                opacity: 0.8;
            }
            50% { 
                transform: scale3d(1.05, 1.05, 1);
                opacity: 1;
            }
        }

        @keyframes pulse-warning {
            0%, 100% { 
                transform: scale3d(1, 1, 1);
                opacity: 0.8;
            }
            50% { 
                transform: scale3d(1.05, 1.05, 1);
                opacity: 1;
            }
        }

        /* Enhanced Panel Headers */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--glass-border);
        }

        .panel-title {
            font-size: var(--font-size-h4);
            font-weight: var(--font-weight-bold);
            line-height: var(--line-height-normal);
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Configuration Panel Improvements */
        .config-panel {
            grid-area: config;
        }

        .config-section {
            margin-bottom: var(--space-lg);
        }

        .config-label {
            display: block;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .config-value {
            font-size: 1rem;
            color: var(--text-dim);
            margin-top: var(--space-sm);
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            max-width: 100%;
        }

        .config-value.file-info {
            background: var(--bg-black);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--glass-border);
        }

        .file-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .file-details {
            flex: 1;
            min-width: 0; /* Allow text to truncate */
        }

        .file-name {
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .file-size {
            font-size: 0.875rem;
            color: var(--text-dim);
            margin-top: 2px;
        }

        /* Enhanced Input Fields */
        .config-input {
            width: 100%;
            padding: var(--space-md) var(--space-lg);
            background: var(--bg-black);
            border: 2px solid var(--glass-border);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem;
            transition: var(--transition);
            position: relative;
        }

        .config-input:focus {
            outline: none;
            border-color: var(--neon-blue);
            box-shadow: var(--glow-blue);
            background: rgba(0, 255, 255, 0.05);
        }

        .config-input.error {
            border-color: var(--error);
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.3);
            animation: input-shake 0.5s ease-in-out;
        }

        @keyframes input-shake {
            0%, 100% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-5px, 0, 0); }
            75% { transform: translate3d(5px, 0, 0); }
        }

        /* Enhanced File Drop Zone with Better Visual Feedback */
        .file-drop-zone {
            position: relative;
            margin-bottom: var(--space-16);
            border: 2px dashed var(--glass-border);
            border-radius: 12px;
            padding: var(--space-24);
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            cursor: pointer;
            background: var(--surface-01);
            box-shadow: var(--md-elevation-1);
        }

        .file-drop-zone:hover,
        .file-drop-zone.drag-over {
            border-color: var(--neon-blue);
            background: color-mix(in srgb, var(--surface-02) 90%, var(--neon-blue));
            background: rgba(0, 191, 255, 0.2); /* Fallback for older browsers */
            box-shadow: var(--md-elevation-4);
            transform: translateY(-2px);
        }

        .file-drop-zone.drag-over::before {
            content: 'üìÅ Drop file here!';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.25rem;
            color: var(--neon-blue);
            font-weight: bold;
            z-index: 10;
            text-shadow: var(--glow-blue);
            animation: pulse-glow 1s ease-in-out infinite alternate;
        }

        @keyframes pulse-glow {
            0% { opacity: 0.8; transform: translate3d(-50%, -50%, 0) scale3d(1, 1, 1); }
            100% { opacity: 1; transform: translate3d(-50%, -50%, 0) scale3d(1.05, 1.05, 1); }
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-md);
            padding: var(--space-lg);
            background: linear-gradient(45deg, var(--neon-purple), var(--neon-blue));
            border: none;
            border-radius: var(--radius-md);
            color: white;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        .file-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-purple);
            filter: brightness(1.2);
        }

        .file-button:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        /* Main Panel Improvements */
        .main-panel {
            grid-area: main;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .phase-display {
            margin-bottom: var(--space-xl);
            font-size: 1.375rem;
            font-weight: 700;
            text-align: center;
        }

        /* Enhanced Progress Ring with Better Proportions */
        .progress-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin-bottom: var(--space-2xl);
        }

        /* Enhanced Progress Ring with Dynamic Glow */
        .progress-ring {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            filter: drop-shadow(var(--glow-blue));
            transition: filter 0.3s ease;
        }

        .progress-ring.active {
            filter: drop-shadow(0 0 20px var(--neon-blue)) drop-shadow(0 0 40px var(--neon-blue));
        }

        .progress-fill {
            fill: none;
            stroke: url(#progressGradient);
            stroke-width: 20;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .progress-percentage {
            font-size: var(--font-size-h1);
            font-weight: var(--font-weight-black);
            line-height: var(--line-height-tight);
            color: var(--neon-blue);
            margin-bottom: var(--space-4);
            text-shadow: var(--glow-blue);
        }

        .progress-label {
            font-size: 1rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Enhanced Control Panel */
        .control-panel {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-2xl);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Enhanced Cyberpunk Button System with Material Design Principles */
        .cyber-btn {
            padding: var(--space-8) var(--space-16);
            border: 2px solid;
            background: transparent;
            border-radius: 4px; /* Material Design button radius */
            font-size: var(--font-size-button);
            font-weight: var(--font-weight-medium);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0.0, 0.2, 1); /* Material Design fast easing */
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            font-family: 'Orbitron', monospace;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-4);
            min-height: 48px; /* Material Design minimum touch target */
            box-shadow: var(--elevation-2);
        }
        
        /* Material Design Ripple Effect */
        .cyber-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .cyber-btn:active::before {
            width: 300px;
            height: 300px;
        }

        .cyber-btn:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        .cyber-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Material Design Button Variants */
        
        /* Contained Button (Primary) */
        .cyber-btn.primary {
            background: var(--neon-blue);
            border-color: var(--neon-blue);
            color: var(--bg-black);
            box-shadow: var(--md-elevation-2);
        }

        .cyber-btn.primary:hover:not(:disabled) {
            background: rgba(0, 191, 255, 0.85); /* Fallback for older browsers */
            background: color-mix(in srgb, var(--neon-blue) 85%, white);
            box-shadow: var(--md-elevation-4);
            transform: translateY(-1px);
        }
        
        .cyber-btn.primary:active:not(:disabled) {
            box-shadow: var(--md-elevation-8);
            transform: translateY(0);
        }
        
        /* Outlined Button */
        .cyber-btn.outlined {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            background: transparent;
            box-shadow: none;
        }
        
        .cyber-btn.outlined:hover:not(:disabled) {
            background: rgba(0, 255, 255, 0.08);
            box-shadow: var(--md-elevation-1);
        }
        
        /* Text Button */
        .cyber-btn.text {
            border: none;
            color: var(--neon-blue);
            background: transparent;
            box-shadow: none;
            padding: var(--space-6) var(--space-12);
        }
        
        .cyber-btn.text:hover:not(:disabled) {
            background: rgba(0, 255, 255, 0.08);
        }

        .cyber-btn.success {
            background: var(--neon-green);
            border-color: var(--neon-green);
            color: var(--bg-black);
            box-shadow: var(--md-elevation-2);
        }

        .cyber-btn.success:hover:not(:disabled) {
            background: rgba(0, 255, 0, 0.85); /* Fallback for older browsers */
            background: color-mix(in srgb, var(--neon-green) 85%, white);
            box-shadow: var(--md-elevation-4);
            transform: translateY(-1px);
        }
        
        .cyber-btn.success.outlined {
            border-color: var(--neon-green);
            color: var(--neon-green);
            background: transparent;
            box-shadow: none;
        }
        
        .cyber-btn.success.outlined:hover:not(:disabled) {
            background: rgba(0, 255, 0, 0.08);
        }

        .cyber-btn.danger {
            background: var(--error);
            border-color: var(--error);
            color: var(--bg-black);
            box-shadow: var(--md-elevation-2);
        }

        .cyber-btn.danger:hover:not(:disabled) {
            background: rgba(255, 0, 64, 0.85); /* Fallback for older browsers */
            background: color-mix(in srgb, var(--error) 85%, white);
            box-shadow: var(--md-elevation-4);
            transform: translateY(-1px);
        }
        
        .cyber-btn.danger.outlined {
            border-color: var(--error);
            color: var(--error);
            background: transparent;
            box-shadow: none;
        }
        
        .cyber-btn.danger.outlined:hover:not(:disabled) {
            background: rgba(255, 0, 64, 0.08);
        }

        .cyber-btn.secondary {
            background: var(--neon-purple);
            border-color: var(--neon-purple);
            color: var(--bg-black);
            box-shadow: var(--md-elevation-2);
        }

        .cyber-btn.secondary:hover:not(:disabled) {
            background: color-mix(in srgb, var(--neon-purple) 85%, white);
            box-shadow: var(--md-elevation-4);
            transform: translateY(-1px);
        }
        
        .cyber-btn.secondary.outlined {
            border-color: var(--neon-purple);
            color: var(--neon-purple);
            background: transparent;
            box-shadow: none;
        }
        
        .cyber-btn.secondary.outlined:hover:not(:disabled) {
            background: rgba(138, 43, 226, 0.08);
        }

        /* Large Control Buttons */
        .cyber-btn.large {
            padding: var(--space-lg) var(--space-xl);
            font-size: 1rem;
            min-width: 160px;
        }

        .cyber-btn.large:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.02);
        }

        /* Small compact buttons */
        .cyber-btn.small {
            padding: var(--space-sm) var(--space-md);
            font-size: 0.625rem;
            min-width: auto;
        }


        /* Loading Spinner System */
        .cyber-btn.loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
            cursor: not-allowed;
        }

        .cyber-btn.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: cyber-spin 1s linear infinite;
            color: var(--text-primary) !important;
        }

        .cyber-btn.loading.primary::after {
            color: var(--bg-black);
        }

        .cyber-btn.loading.success::after {
            color: var(--bg-black);
        }

        .cyber-btn.loading.danger::after {
            color: var(--bg-black);
        }

        .cyber-btn.loading.secondary::after {
            color: var(--bg-black);
        }

        .cyber-btn.loading.outlined::after,
        .cyber-btn.loading.text::after {
            color: currentColor;
        }

        .cyber-btn.large.loading::after {
            width: 24px;
            height: 24px;
            border-width: 3px;
        }

        .cyber-btn.small.loading::after {
            width: 16px;
            height: 16px;
            border-width: 2px;
        }

        @keyframes cyber-spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Success Animation */
        .cyber-btn.success-flash {
            animation: success-flash 0.6s ease-out;
        }

        @keyframes success-flash {
            0% { background-color: var(--neon-green); transform: scale(1); }
            50% { 
                background-color: rgba(0, 255, 128, 0.7); /* Fallback for older browsers */
                transform: scale(1.05); 
            }
            100% { transform: scale(1); }
        }

        /* Error Animation */
        .cyber-btn.error-shake {
            animation: error-shake 0.5s ease-in-out;
        }

        @keyframes error-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Button State Indicators */
        .cyber-btn.has-status {
            position: relative;
        }

        .cyber-btn.has-status .status-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid var(--bg-card);
            z-index: 1;
        }

        .cyber-btn.has-status .status-indicator.success {
            background: var(--neon-green);
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.6);
        }

        .cyber-btn.has-status .status-indicator.error {
            background: var(--error);
            box-shadow: 0 0 8px rgba(255, 0, 64, 0.6);
        }

        /* Copy Button Styles */
        .copy-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            margin-left: 8px;
            padding: 0;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .copy-btn:hover {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            background: rgba(0, 191, 255, 0.1);
            box-shadow: 0 0 8px rgba(0, 191, 255, 0.3);
        }

        .copy-btn:active {
            transform: scale(0.95);
        }

        .copy-btn.copied {
            border-color: var(--success);
            color: var(--success);
            background: rgba(0, 255, 128, 0.1);
            box-shadow: 0 0 8px rgba(0, 255, 128, 0.3);
        }

        .copy-btn.copied::after {
            content: '‚úì';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 128, 0.1);
            animation: copySuccess 0.3s ease;
        }

        @keyframes copySuccess {
            0% { transform: scale(0) rotate(180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(0deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        /* Copy container for positioning */
        .copy-container {
            display: inline-flex;
            align-items: center;
        }

        /* Enhanced Status Indicators */
        .status-indicator-enhanced {
            display: inline-flex;
            align-items: center;
            gap: var(--space-xs);
            padding: 2px 8px;
            border-radius: var(--radius-full);
            font-size: var(--font-size-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .status-indicator-enhanced::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 3px;
            transition: all 0.3s ease;
        }

        .status-indicator-enhanced.connected {
            background: rgba(0, 255, 128, 0.1);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-indicator-enhanced.connected::before {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .status-indicator-enhanced.disconnected {
            background: rgba(255, 0, 64, 0.1);
            color: var(--error);
            border: 1px solid var(--error);
        }

        .status-indicator-enhanced.disconnected::before {
            background: var(--error);
            box-shadow: 0 0 8px var(--error);
        }

        .status-indicator-enhanced.running {
            background: rgba(0, 191, 255, 0.1);
            color: var(--neon-blue);
            border: 1px solid var(--neon-blue);
            animation: pulseBlue 2s ease-in-out infinite;
        }

        .status-indicator-enhanced.running::before {
            background: var(--neon-blue);
            box-shadow: 0 0 8px var(--neon-blue);
        }

        .status-indicator-enhanced.paused {
            background: rgba(255, 255, 0, 0.1);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .status-indicator-enhanced.paused::before {
            background: var(--warning);
            box-shadow: 0 0 8px var(--warning);
        }

        @keyframes pulseBlue {
            0%, 100% { 
                box-shadow: 0 0 5px rgba(0, 191, 255, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 20px rgba(0, 191, 255, 0.6);
                transform: scale(1.02);
            }
        }

        /* Enhanced Toast Notifications */
        .toast-enhanced {
            position: relative;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-left: 4px solid transparent;
            animation: slideInRight 0.3s ease-out;
        }

        .toast-enhanced.success {
            border-left-color: var(--success);
            background: linear-gradient(135deg, rgba(0, 255, 128, 0.1), rgba(0, 255, 128, 0.05));
        }

        .toast-enhanced.error {
            border-left-color: var(--error);
            background: linear-gradient(135deg, rgba(255, 0, 64, 0.1), rgba(255, 0, 64, 0.05));
        }

        .toast-enhanced.warning {
            border-left-color: var(--warning);
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.1), rgba(255, 255, 0, 0.05));
        }

        .toast-enhanced.info {
            border-left-color: var(--neon-blue);
            background: linear-gradient(135deg, rgba(0, 191, 255, 0.1), rgba(0, 191, 255, 0.05));
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Animation Polish */
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        .slide-up {
            animation: slideUp 0.4s ease-out;
        }

        .bounce-in {
            animation: bounceIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                transform: translateY(20px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Hover animations for interactive elements */
        .cyber-btn, .copy-btn, .config-input {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .cyber-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 191, 255, 0.3);
        }

        .config-input:focus {
            transform: translateY(-1px);
            box-shadow: 0 0 0 3px rgba(0, 191, 255, 0.2);
        }

        /* Color Scheme Refinements */
        :root {
            /* Enhanced color palette */
            --neon-orange: #ff8c00;
            --neon-pink: #ff69b4;
            --neon-cyan: #00ffff;
            --neon-lime: #32ff32;
            
            /* Improved semantic colors */
            --success-dark: #00cc66;
            --warning-dark: #ff9900;
            --error-dark: #cc0033;
            --info-dark: #0099cc;
            
            /* Better contrast ratios */
            --text-high-contrast: #ffffff;
            --text-medium-contrast: #e0e0e0;
            --text-low-contrast: #a0a0a0;
        }

        /* Accessibility Improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus indicators */
        *:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        .cyber-btn:focus,
        .config-input:focus,
        .copy-btn:focus {
            outline: 3px solid var(--neon-blue);
            outline-offset: 1px;
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --text-primary: var(--text-high-contrast);
                --text-secondary: var(--text-medium-contrast);
                --border: #ffffff;
                --glass-border: #ffffff;
            }
            
            .cyber-btn {
                border-width: 2px;
            }
        }

        /* CSS classes for removed inline styles */
        .connection-health {
            margin-left: var(--space-sm);
            font-size: var(--font-size-xs);
            color: var(--text-muted);
            display: none;
        }

        .file-selection-container-positioned {
            position: relative;
        }

        .recent-files-btn {
            margin-top: var(--space-xs);
            width: 100%;
        }

        /* Reduce motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .particle {
                display: none;
            }
        }

        /* Dark mode enhancements */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-black: #0a0a0a;
                --bg-card: #111111;
                --text-primary: #f0f0f0;
            }
        }

        /* Print styles */
        @media print {
            .particle-container,
            .toast-container,
            .cyber-btn,
            .copy-btn {
                display: none !important;
            }
            
            body {
                background: white !important;
                color: black !important;
            }
        }

        /* Additional CSS Classes for inline style removal */
        .connection-text-bold {
            font-weight: 600;
        }

        .copy-btn-hidden {
            display: none;
        }

        .file-preview-layout {
            margin-top: var(--space-md);
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-header-spaced {
            margin-top: var(--space-xl);
        }

        /* SVG gradient stops */
        .gradient-stop-blue {
            stop-color: var(--neon-blue);
            stop-opacity: 1;
        }

        .gradient-stop-purple {
            stop-color: var(--neon-purple);
            stop-opacity: 1;
        }

        .gradient-stop-pink {
            stop-color: var(--neon-pink);
            stop-opacity: 1;
        }

        .gradient-stop-green {
            stop-color: var(--neon-green);
            stop-opacity: 1;
        }

        .copy-container .copy-content {
            flex: 1;
            min-width: 0; /* Allow text truncation */
        }

        /* Form Validation Styling */
        .config-input, .file-drop-zone {
            position: relative;
            transition: all 0.3s ease;
        }

        .config-input.valid {
            border-color: var(--success);
            box-shadow: 0 0 0 2px rgba(0, 255, 128, 0.1);
        }

        .config-input.invalid {
            border-color: var(--error);
            box-shadow: 0 0 0 2px rgba(255, 0, 64, 0.1);
            animation: shakeError 0.5s ease-in-out;
        }

        .config-input.warning {
            border-color: var(--warning);
            box-shadow: 0 0 0 2px rgba(255, 255, 0, 0.1);
        }

        /* Validation icons */
        .validation-icon {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            z-index: 1;
        }

        .validation-icon.valid {
            color: var(--success);
        }

        .validation-icon.invalid {
            color: var(--error);
        }

        .validation-icon.warning {
            color: var(--warning);
        }

        /* Validation helper text */
        .validation-helper {
            margin-top: 4px;
            font-size: var(--font-size-sm);
            line-height: 1.3;
            opacity: 0;
            transform: translateY(-4px);
            transition: all 0.2s ease;
        }

        .validation-helper.show {
            opacity: 1;
            transform: translateY(0);
        }

        .validation-helper.valid {
            color: var(--success);
        }

        .validation-helper.invalid {
            color: var(--error);
        }

        .validation-helper.warning {
            color: var(--warning);
        }

        /* Form field containers */
        .form-field {
            position: relative;
            margin-bottom: var(--space-md);
        }

        .form-field.has-validation .config-input {
            padding-right: 32px; /* Make room for validation icon */
        }

        /* File drop zone validation states */
        .file-drop-zone.valid {
            border-color: var(--success);
            background: rgba(0, 255, 128, 0.05);
        }

        .file-drop-zone.invalid {
            border-color: var(--error);
            background: rgba(255, 0, 64, 0.05);
            animation: shakeError 0.5s ease-in-out;
        }

        @keyframes shakeError {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }

        .cyber-btn.has-status .status-indicator.warning {
            background: var(--warning);
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.6);
        }

        /* File preview container */
        .file-preview-container {
            background: var(--bg-black);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            transition: var(--transition);
        }

        .file-preview-container:hover {
            border-color: var(--glass-border-active);
        }

        .file-icon-large {
            font-size: 2rem;
            opacity: 0.7;
        }

        .btn-group {
            display: flex;
            gap: var(--space-sm);
            flex-wrap: wrap;
            margin-top: var(--space-lg);
        }

        /* Enhanced Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--space-md);
            width: 100%;
            max-width: 600px;
        }

        .stat-card {
            background: var(--surface-02);
            border: 1px solid var(--glass-border);
            border-radius: 8px; /* Material Design card radius */
            padding: var(--space-16);
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: var(--md-elevation-2);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .stat-card:hover {
            border-color: var(--neon-blue);
            background: var(--surface-04);
            box-shadow: var(--md-elevation-8);
            transform: translateY(-4px);
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-value {
            font-size: 1.375rem;
            font-weight: 700;
            color: var(--neon-blue);
            margin-bottom: var(--space-sm);
            font-family: 'Share Tech Mono', monospace;
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Status Panel Improvements */
        .status-panel {
            grid-area: status;
        }

        .log-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            background: var(--bg-black);
        }

        /* Enhanced Security Badges */
        .security-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-lg);
        }

        .security-badge {
            padding: var(--space-12);
            background: var(--surface-02);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: var(--space-8);
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: relative;
            box-shadow: var(--md-elevation-1);
        }

        .security-badge.active {
            border-color: var(--success);
            background: color-mix(in srgb, var(--surface-04) 95%, var(--success));
            box-shadow: var(--md-elevation-4);
            animation: security-activation 0.6s ease-out;
        }
        
        .security-badge:hover {
            background: var(--surface-04);
            box-shadow: var(--md-elevation-2);
        }

        @keyframes security-activation {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .security-badge.active .badge-icon {
            color: var(--success);
            animation: security-pulse 2s infinite;
            filter: drop-shadow(var(--glow-green));
        }

        @keyframes security-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .badge-icon {
            font-size: 1.25rem;
        }

        .badge-text {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Theme Selector Improvements */
        .theme-selector {
            display: flex;
            gap: var(--space-md);
            justify-content: center;
            align-items: center;
            margin-top: var(--space-lg);
        }

        .theme-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 3px solid var(--glass-border);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            outline: none;
        }

        .theme-btn:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 3px;
        }

        .theme-btn.cyberpunk {
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-blue), var(--neon-purple));
        }

        .theme-btn.dark {
            background: linear-gradient(45deg, #2C3E50, #34495E, #1A1A1A);
        }

        .theme-btn.matrix {
            background: linear-gradient(45deg, #000000, var(--neon-green), #003300);
        }

        .theme-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 0 25px currentColor;
            border-color: var(--neon-blue);
        }

        .theme-btn.active {
            border-color: var(--neon-blue);
            box-shadow: var(--glow-blue);
            transform: scale(1.1);
        }

        .theme-btn.active::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        /* Enhanced Log System */
        .log-entry {
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
            transition: var(--transition);
            cursor: pointer;
            border-left: 3px solid transparent;
            position: relative;
        }

        .log-entry:hover {
            background: var(--bg-medium);
            border-left-color: var(--neon-blue);
            transform: translateX(5px);
        }

        .log-entry:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        .log-timestamp {
            font-size: 0.75rem;
            color: var(--text-dim);
            min-width: 60px;
        }

        .log-icon {
            font-size: 0.875rem;
            min-width: 16px;
        }

        .log-icon.success {
            color: var(--success);
        }

        .log-icon.error {
            color: var(--error);
        }

        .log-icon.info {
            color: var(--info);
        }

        .log-content {
            flex: 1;
        }

        .log-message {
            font-weight: 600;
            margin-bottom: var(--space-xs);
        }

        .log-details {
            font-size: 0.75rem;
            color: var(--text-dim);
            opacity: 0.8;
        }

        /* Enhanced Toast System with Better Stacking */
        .toast-container {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            max-width: 400px;
        }

        .toast {
            background: var(--surface-06);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: var(--space-12) var(--space-16);
            animation: toast-slide-in 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            box-shadow: var(--md-elevation-8);
            min-width: 300px;
        }

        .toast.success {
            border-left: 4px solid var(--success);
            box-shadow: var(--glow-green);
        }

        .toast.error {
            border-left: 4px solid var(--error);
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.3);
        }

        .toast.info {
            border-left: 4px solid var(--info);
            box-shadow: var(--glow-blue);
        }

        @keyframes toast-slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toast-slide-out {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: var(--space-md);
        }

        .toast-message {
            flex: 1;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: var(--transition);
            flex-shrink: 0;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        /* Enhanced Custom Modal System */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
            animation: modal-fade-in 0.3s ease-out;
        }

        @keyframes modal-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: var(--surface-08);
            border: 1px solid var(--glass-border);
            border-radius: 16px; /* Material Design large radius for modals */
            padding: var(--space-24);
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: modal-slide-up 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            box-shadow: var(--md-elevation-24);
        }

        @keyframes modal-slide-up {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--glass-border);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--neon-blue);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: var(--space-sm);
            border-radius: var(--radius-sm);
            transition: var(--transition);
        }

        .modal-close:hover {
            color: var(--neon-red);
            background: rgba(255, 0, 64, 0.1);
        }

        .confirm-modal .modal {
            max-width: 400px;
        }

        .confirm-modal .modal-title {
            color: var(--neon-yellow);
            margin-bottom: var(--space-lg);
        }

        .confirm-modal .modal-message {
            color: var(--text-secondary);
            margin-bottom: var(--space-xl);
            line-height: 1.5;
        }

        .confirm-modal .modal-buttons {
            display: flex;
            gap: var(--space-lg);
            justify-content: flex-end;
        }

        /* Debug Panel Improvements */
        .debug-panel {
            grid-area: debug;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            margin-bottom: var(--space-lg); /* Ensure spacing from bottom */
        }

        .debug-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .debug-content.show {
            max-height: 500px;
        }

        .debug-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .debug-section h3 {
            color: var(--neon-purple);
            margin-bottom: var(--space-md);
            font-size: 1.125rem;
        }

        .json-viewer {
            background: var(--bg-black);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Enhanced Mobile Responsiveness */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "main"
                    "config"
                    "status"
                    "debug";
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .debug-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: var(--space-md) var(--space-md) var(--space-2xl); /* Extra bottom padding on mobile */
                gap: var(--space-md);
            }

            .header {
                padding: var(--space-lg);
                flex-direction: column;
                gap: var(--space-md);
            }

            .logo-icon {
                font-size: 2rem;
            }

            .logo-text h1 {
                font-size: 1.75rem;
            }

            .progress-container {
                width: 250px;
                height: 250px;
            }

            .progress-percentage {
                font-size: 2.25rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .control-panel {
                flex-direction: column;
                align-items: center;
            }

            .cyber-btn.large {
                width: 100%;
                max-width: 250px;
            }

            .security-grid {
                grid-template-columns: 1fr;
            }

            .theme-selector {
                gap: var(--space-md);
            }

            .btn-group {
                flex-direction: column;
            }

            .toast-container {
                top: var(--space-md);
                right: var(--space-md);
                left: var(--space-md);
                max-width: none;
            }

            .toast {
                min-width: auto;
                width: 100%;
            }

            .debug-panel {
                margin-bottom: var(--space-2xl);
            }
        }

        /* Loading States */
        .loading {
            display: inline-block;
            animation: loading-pulse 1.5s infinite;
        }

        @keyframes loading-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .loading-spinner {
            display: inline-block;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid var(--glass-border);
            border-radius: 50%;
            border-top-color: var(--neon-blue);
            animation: spin 1s ease-in-out infinite;
        }

        /* Accessibility Improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        [aria-live] {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Focus management */
        *:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --glass-border: rgba(255, 255, 255, 0.8);
                --text-secondary: #FFFFFF;
                --text-dim: #CCCCCC;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div class="cyber-grid"></div>
    <div class="particle-container" id="particleContainer"></div>
    <div class="toast-container" id="toastContainer" role="status" aria-live="polite"></div>
    <div aria-live="polite" aria-atomic="true" class="sr-only" id="announcements"></div>
    
    <div class="container">
        <!-- Header -->
        <header class="header" role="banner">
            <div class="logo">
                <div class="logo-icon neon-text pink" tabindex="0" role="button" aria-label="CyberBackup Logo">‚ö°</div>
                <div class="logo-text">
                    <h1 class="neon-text pink">CYBERBACKUP PRO</h1>
                    <div class="subtitle">v3.0 (API Driven)</div>
                </div>
            </div>
            <div class="connection-status">
                <div class="status-led" id="connectionLed" aria-label="Connection status"></div>
                <span id="connectionText" class="connection-text-bold">OFFLINE</span>
                <div class="connection-health" id="connectionHealth">
                    <span id="healthIndicator">üì∂</span>
                    <span id="pingDisplay">-- ms</span>
                </div>
            </div>
        </header>

        <!-- Configuration Panel -->
        <aside class="config-panel glass-card" role="region" aria-label="Configuration">
            <div class="panel-header">
                <h2 class="panel-title">System Configuration</h2>
            </div>
            
            <div class="config-section">                <label class="config-label" for="serverInput">Server Address</label>
                <div class="copy-container">
                    <input type="text" class="config-input copy-content" id="serverInput" 
                           placeholder="127.0.0.1:1256" value="127.0.0.1:1256" aria-describedby="serverHelp">
                    <button type="button" class="copy-btn" id="copyServerAddress" title="Copy Server Address" aria-label="Copy Server Address">üìã</button>
                </div>
                <div id="serverHelp" class="sr-only">Enter server IP address and port</div>
            </div>
            
            <div class="config-section">
                <label class="config-label" for="usernameInput">Username</label>
                <input type="text" class="config-input" id="usernameInput"
                       placeholder="Enter your username" value="" maxlength="100" aria-describedby="usernameHelp">
                <div id="usernameHelp" class="sr-only">Username for authentication (max 100 characters)</div>
            </div>
            
            <div class="config-section">
                <label class="config-label">Target File</label>
                <div class="file-selection-container file-selection-container-positioned">
                    <div class="file-drop-zone" id="fileDropZone">
                        <input type="file" class="file-input" id="fileInput" 
                               aria-describedby="fileHelp" accept="*/*" 
                               title="Select a file to backup" 
                               aria-label="File selection for backup">
                        <div class="file-button">
                            üìÅ Select File to Backup
                            <span class="sr-only">or drag and drop a file here</span>
                        </div>
                    </div>
                    <button type="button" class="cyber-btn small secondary recent-files-btn" id="recentFilesBtn" 
                            title="Show recent files" aria-label="Show recent files">
                        üìÇ Recent Files
                    </button>
                </>
                <div id="fileHelp" class="sr-only">Select a file for backup or drag and drop</div>
                <div class="copy-container">
                    <div class="config-value copy-content" id="selectedFile">No file selected</div>
                    <button type="button" class="copy-btn copy-btn-hidden" id="copyFileInfo" title="Copy File Info" aria-label="Copy File Info">üìã</button>
                </div>
                <div id="filePreview" class="file-preview-container file-preview-layout"></div>
            </div>
            
            <div class="config-section">
                <label class="config-label">Client ID</label>
                <div class="copy-container">
                    <div class="config-value copy-content" id="clientId">Not connected</div>
                    <button type="button" class="copy-btn" id="copyClientId" title="Copy Client ID" aria-label="Copy Client ID">üìã</button>
                </div>
            </div>

            <div class="btn-group">
                <button type="button" class="cyber-btn success" data-action="save-config">üíæ Save Config</button>
            </div>

            <div class="panel-header panel-header-spaced">
                <h2 class="panel-title">Theme Selection</h2>
            </div>
            
            <div class="theme-selector">
                <button type="button" class="theme-btn cyberpunk active" 
                        aria-label="Cyberpunk theme" title="Cyberpunk Theme"></button>
                <button type="button" class="theme-btn dark" 
                        aria-label="Dark theme" title="Dark Theme"></button>
                <button type="button" class="theme-btn matrix" 
                        aria-label="Matrix theme" title="Matrix Theme"></button>
            </div>
        </aside>

        <!-- Main Panel -->
        <main class="main-panel glass-card" role="main">
            <div class="phase-display" id="currentPhase">
                <span class="neon-text purple">SYSTEM READY</span>
            </div>
            
            <div class="progress-container">
                <svg class="progress-ring" viewBox="0 0 300 300" role="img" aria-label="Transfer progress">
                    <defs>
                        <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" class="gradient-stop-blue" />
                            <stop offset="33%" class="gradient-stop-purple" />
                            <stop offset="66%" class="gradient-stop-pink" />
                            <stop offset="100%" class="gradient-stop-green" />
                        </linearGradient>
                    </defs>
                    <circle class="progress-bg" cx="150" cy="150" r="130" 
                            fill="none" stroke="var(--bg-light)" stroke-width="16"></circle>
                    <circle class="progress-fill" cx="150" cy="150" r="130" id="progressCircle"></circle>
                </svg>
                <div class="progress-text">
                    <div class="progress-percentage neon-text" id="progressPercentage">0%</div>
                    <div class="progress-label" id="progressStatus">READY</div>
                </div>
            </div>            <div class="control-panel">
                <button type="button" class="cyber-btn primary large control-btn" id="primaryAction">
                    <span class="btn-icon">üöÄ</span>
                    <span class="btn-text">CONNECT</span>
                </button>
                <button type="button" class="cyber-btn secondary large control-btn" id="pauseBtn" disabled>
                    <span class="btn-icon">‚è∏Ô∏è</span>
                    <span class="btn-text">PAUSE</span>
                </button>
                <button type="button" class="cyber-btn danger large control-btn" id="stopBtn" disabled>
                    <span class="btn-icon">üõë</span>
                    <span class="btn-text">STOP</span>
                </button>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="speedStat">0 B/s</div>
                    <div class="stat-label">Transfer Speed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="etaStat">--:--</div>
                    <div class="stat-label">ETA</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="transferredStat">0 B</div>
                    <div class="stat-label">Transferred</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="sizeStat">0 B</div>
                    <div class="stat-label">Total Size</div>
                </div>
            </div>
        </main>

        <!-- Status Panel -->
        <aside class="status-panel glass-card" role="region" aria-label="Operation log">
            <div class="panel-header">
                <h2 class="panel-title">Operation Log</h2>
                <div class="btn-group">
                    <button type="button" class="cyber-btn success small" data-action="export-log">üì• Export</button>
                    <button type="button" class="cyber-btn danger small" data-action="clear-log">üóëÔ∏è Clear</button>
                    <button type="button" class="cyber-btn primary small" id="autoScrollBtn">
                        üìú Auto-scroll: ON
                    </button>
                </div>
            </div>
            
            <div class="log-container" id="logContainer" role="log" aria-live="polite" aria-label="Activity log">
                <!-- Logs will be populated here -->
            </div>
        </aside>

        <!-- Debug Panel -->
        <div class="debug-panel glass-card" role="region" aria-label="Developer console">
            <div class="panel-header">
                <h2 class="panel-title">Developer Console</h2>
                <button type="button" class="cyber-btn primary small" id="debugToggle" 
                        aria-expanded="false">üîß Toggle Debug</button>
            </div>
            
            <div class="debug-content" id="debugContent">
                <div class="debug-grid">
                    <div class="debug-section">
                        <h3>üìä Last API Response</h3>
                        <div class="json-viewer" id="statusJsonViewer">Waiting for status data...</div>
                    </div>
                    <div class="debug-section">
                        <h3>üìà State Machine</h3>
                        <div class="json-viewer" id="progressJsonViewer">Waiting for state data...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Custom Confirmation Modal -->
    <div class="modal-overlay confirm-modal" id="confirmModal">
        <div class="modal">
            <h3 class="modal-title" id="confirmTitle">Confirm Action</h3>
            <p class="modal-message" id="confirmMessage">Are you sure?</p>
            <div class="modal-buttons">
                <button type="button" class="cyber-btn secondary" id="cancelModalBtn" data-action="cancel-modal">Cancel</button>
                <button type="button" class="cyber-btn danger" id="confirmOkBtn">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Socket.IO Client Library for Real-Time Communication -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
    
    <script>
        // === IMMEDIATE TEST ===
        console.log('JavaScript is working! Script started loading...');
        
        // === ENHANCED DEBUG LOGGING SYSTEM ===
        class DebugLogger {
            constructor() {
                this.levels = {
                    ERROR: { value: 0, color: '#ff0040', prefix: 'ERROR' },
                    WARN: { value: 1, color: '#ffff00', prefix: 'WARN' },
                    INFO: { value: 2, color: '#00ffff', prefix: 'INFO' },
                    DEBUG: { value: 3, color: '#00ff00', prefix: 'DEBUG' },
                    TRACE: { value: 4, color: '#888888', prefix: 'TRACE' }
                };
                
                this.currentLevel = this.levels.ERROR; // Only show errors to reduce spam
                this.filters = new Set(); // Category filters
                this.debugDiv = null;
                this.isEnabled = true;
                this.maxEntries = 1000; // Prevent memory issues
                this.entries = [];
                
                // Load preferences from localStorage
                this.loadPreferences();
                
                // Setup keyboard shortcut for debug toggle
                this.setupKeyboardShortcuts();
            }

            setLevel(levelName) {
                if (this.levels[levelName]) {
                    this.currentLevel = this.levels[levelName];
                    this.savePreferences();
                    this.log('DEBUG', 'DEBUG', `Debug level set to ${levelName}`);
                }
            }

            addFilter(category) {
                this.filters.add(category.toUpperCase());
                this.savePreferences();
            }

            removeFilter(category) {
                this.filters.delete(category.toUpperCase());
                this.savePreferences();
            }

            clearFilters() {
                this.filters.clear();
                this.savePreferences();
            }

            toggle() {
                this.isEnabled = !this.isEnabled;
                if (this.debugDiv) {
                    this.debugDiv.classList.toggle('u-hidden', !this.isEnabled);
                }
                this.savePreferences();
            }

            log(level, category, message) {
                const levelObj = this.levels[level];
                if (!levelObj || !this.isEnabled) return;
                
                // Check level filtering
                if (levelObj.value > this.currentLevel.value) return;
                
                // Check category filtering
                if (this.filters.size > 0 && !this.filters.has(category.toUpperCase())) return;

                const timestamp = new Date().toLocaleTimeString();
                const entry = { timestamp, level, category, message, levelObj };
                
                // Add to entries array
                this.entries.push(entry);
                if (this.entries.length > this.maxEntries) {
                    this.entries.shift(); // Remove oldest entry
                }

                // Console logging
                const consoleMessage = `[${levelObj.prefix}] [${category}] ${message}`;
                switch (level) {
                    case 'ERROR': console.error(consoleMessage); break;
                    case 'WARN': console.warn(consoleMessage); break;
                    case 'INFO': console.info(consoleMessage); break;
                    default: console.log(consoleMessage); break;
                }

                // Visual debug div
                this.updateDebugDiv(entry);
            }

            updateDebugDiv(entry) {
                if (!this.debugDiv) {
                    this.debugDiv = this.createDebugDiv();
                }

                const entryDiv = document.createElement('div');
                entryDiv.style.cssText = `color: ${entry.levelObj.color}; margin-bottom: 2px; font-size: 11px; line-height: 1.2;`;
                
                // Create safe DOM elements instead of innerHTML to prevent XSS
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'u-text-gray';
                timestampSpan.textContent = `[${entry.timestamp}]`;
                
                const levelSpan = document.createElement('span');
                levelSpan.style.cssText = `color: ${entry.levelObj.color}; font-weight: bold;`;
                levelSpan.textContent = `[${entry.levelObj.prefix}]`;
                
                const categorySpan = document.createElement('span');
                categorySpan.className = 'u-text-light-gray';
                categorySpan.textContent = `[${entry.category}]`;
                
                const messageSpan = document.createElement('span');
                messageSpan.textContent = ` ${entry.message}`;
                
                entryDiv.appendChild(timestampSpan);
                entryDiv.appendChild(document.createTextNode(' '));
                entryDiv.appendChild(levelSpan);
                entryDiv.appendChild(document.createTextNode(' '));
                entryDiv.appendChild(categorySpan);
                entryDiv.appendChild(messageSpan);
                
                this.debugDiv.appendChild(entryDiv);
                
                // Auto-scroll to bottom
                this.debugDiv.scrollTop = this.debugDiv.scrollHeight;
                
                // Limit entries in DOM
                if (this.debugDiv.children.length > 200) {
                    this.debugDiv.removeChild(this.debugDiv.firstChild);
                }
            }

            createDebugDiv() {
                const div = document.createElement('div');
                div.id = 'debug-output';
                div.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    width: 450px;
                    height: 300px;
                    background: rgba(0, 0, 0, 0.95);
                    color: #00ff00;
                    padding: 10px;
                    border: 2px solid #00ffff;
                    border-radius: 8px;
                    overflow-y: auto;
                    z-index: 9999;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    -webkit-backdrop-filter: blur(10px);
                    backdrop-filter: blur(10px);
                    display: ${this.isEnabled ? 'block' : 'none'};
                `;
                
                // Add header with controls
                const header = document.createElement('div');
                header.style.cssText = 'position: sticky; top: 0; background: rgba(0, 0, 0, 0.9); padding: 5px 0; border-bottom: 1px solid #00ffff; margin-bottom: 5px;';
                header.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #00ffff; font-weight: bold;">Debug Console</span>
                        <div>
                            <button type="button" onclick="debugLogger.clearEntries()" style="background: none; border: 1px solid #00ffff; color: #00ffff; padding: 2px 6px; font-size: 10px; cursor: pointer;">Clear</button>
                            <button type="button" onclick="debugLogger.toggle()" style="background: none; border: 1px solid #ff0040; color: #ff0040; padding: 2px 6px; font-size: 10px; cursor: pointer;">√ó</button>
                        </div>
                    </div>
                `;
                
                div.appendChild(header);
                document.body.appendChild(div);
                return div;
            }

            clearEntries() {
                this.entries = [];
                if (this.debugDiv) {
                    // Keep only the header
                    const header = this.debugDiv.firstChild;
                    this.debugDiv.textContent = ''; // Clear safely
                    this.debugDiv.appendChild(header);
                }
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ctrl+Shift+D toggles debug console
                    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                        e.preventDefault();
                        this.toggle();
                    }
                });
            }

            savePreferences() {
                const prefs = {
                    level: Object.keys(this.levels).find(key => this.levels[key] === this.currentLevel),
                    filters: Array.from(this.filters),
                    enabled: this.isEnabled
                };
                localStorage.setItem('cyberbackup_debug_prefs', JSON.stringify(prefs));
            }

            loadPreferences() {
                try {
                    const saved = localStorage.getItem('cyberbackup_debug_prefs');
                    if (saved) {
                        const prefs = JSON.parse(saved);
                        if (prefs.level && this.levels[prefs.level]) {
                            this.currentLevel = this.levels[prefs.level];
                        }
                        if (prefs.filters) {
                            this.filters = new Set(prefs.filters);
                        }
                        if (typeof prefs.enabled === 'boolean') {
                            this.isEnabled = prefs.enabled;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load debug preferences:', error);
                }
            }

            getStatus() {
                return {
                    level: Object.keys(this.levels).find(key => this.levels[key] === this.currentLevel),
                    filters: Array.from(this.filters),
                    enabled: this.isEnabled,
                    entryCount: this.entries.length
                };
            }
        }

        // Create global debug logger instance
        const debugLogger = new DebugLogger();

        // Backward compatibility function
        function debugLog(message, category = 'GENERAL') {
            debugLogger.log('DEBUG', category, message);
        }

        debugLog('=== SCRIPT LOADING STARTED ===');

        /**
         * =================================================================
         * API-DRIVEN CLIENT GUI v3.0
         * =================================================================
         * This version has been refactored to communicate with a local
         * C++ web server (via Boost.Beast) instead of a file-based system.
         * The GUI now acts as a true frontend to the C++ backend.
         * =================================================================
         */

        // Interval Manager to prevent leaks
        debugLog('Defining IntervalManager class...');
        class IntervalManager {
            constructor() {
                this.intervals = new Map();
                this.timeouts = new Map();
                
                // Add cleanup on page unload
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });
            }
            
            set(name, callback, delay) {
                this.clear(name);
                const intervalId = setInterval(() => {
                    try {
                        callback();
                    } catch (error) {
                        console.error(`[IntervalManager] Error in interval '${name}':`, error);
                        // Don't clear the interval automatically to prevent infinite error loops
                    }
                }, delay);
                this.intervals.set(name, intervalId);
                debugLog(`Interval '${name}' set with ${delay}ms delay`, 'INTERVAL_MANAGER');
                return intervalId;
            }
            
            setTimeout(name, callback, delay) {
                this.clearTimeout(name);
                const timeoutId = setTimeout(() => {
                    try {
                        callback();
                    } catch (error) {
                        console.error(`[IntervalManager] Error in timeout '${name}':`, error);
                    } finally {
                        this.timeouts.delete(name); // Auto-cleanup completed timeouts
                    }
                }, delay);
                this.timeouts.set(name, timeoutId);
                debugLog(`Timeout '${name}' set with ${delay}ms delay`, 'INTERVAL_MANAGER');
                return timeoutId;
            }
            
            clear(name) {
                if (this.intervals.has(name)) {
                    clearInterval(this.intervals.get(name));
                    this.intervals.delete(name);
                    debugLog(`Interval '${name}' cleared`, 'INTERVAL_MANAGER');
                    return true;
                }
                return false;
            }
            
            clearTimeout(name) {
                if (this.timeouts.has(name)) {
                    clearTimeout(this.timeouts.get(name));
                    this.timeouts.delete(name);
                    debugLog(`Timeout '${name}' cleared`, 'INTERVAL_MANAGER');
                    return true;
                }
                return false;
            }
            
            clearAll() {
                this.intervals.forEach((id, name) => {
                    clearInterval(id);
                    debugLog(`Clearing interval '${name}'`, 'INTERVAL_MANAGER');
                });
                this.timeouts.forEach((id, name) => {
                    clearTimeout(id);
                    debugLog(`Clearing timeout '${name}'`, 'INTERVAL_MANAGER');
                });
                this.intervals.clear();
                this.timeouts.clear();
                debugLog('All intervals and timeouts cleared', 'INTERVAL_MANAGER');
            }
            
            has(name) {
                return this.intervals.has(name) || this.timeouts.has(name);
            }
            
            getStats() {
                return {
                    intervalCount: this.intervals.size,
                    timeoutCount: this.timeouts.size,
                    intervalNames: Array.from(this.intervals.keys()),
                    timeoutNames: Array.from(this.timeouts.keys())
                };
            }
            
            cleanup() {
                debugLog('Performing cleanup...', 'INTERVAL_MANAGER');
                this.clearAll();
            }
        }
        debugLog('IntervalManager class defined successfully');

        // Event Listener Manager to prevent memory leaks
        debugLog('Defining EventListenerManager class...');
        class EventListenerManager {
            constructor() {
                this.listeners = new Map(); // Map<string, {element, event, handler, options}>
                
                // Add cleanup on page unload
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });
            }
            
            add(name, element, event, handler, options = false) {
                // Validate element exists
                if (!element) {
                    console.error(`[EventListenerManager] Cannot add listener '${name}': element is null/undefined`);
                    return null;
                }
                
                if (typeof element.addEventListener !== 'function') {
                    console.error(`[EventListenerManager] Cannot add listener '${name}': element does not support addEventListener`);
                    return null;
                }
                
                // Remove existing listener with the same name
                this.remove(name);
                
                try {
                    // Add the new listener
                    element.addEventListener(event, handler, options);
                    
                    // Store for cleanup
                    this.listeners.set(name, {
                        element,
                        event,
                        handler,
                        options
                    });
                    
                    debugLog(`Event listener '${name}' added for ${event} on ${element.tagName || 'object'}`, 'EVENT_MANAGER');
                    return handler;
                } catch (error) {
                    console.error(`[EventListenerManager] Failed to add listener '${name}':`, error);
                    return null;
                }
            }
            
            remove(name) {
                if (this.listeners.has(name)) {
                    const {element, event, handler, options} = this.listeners.get(name);
                    element.removeEventListener(event, handler, options);
                    this.listeners.delete(name);
                    debugLog(`Event listener '${name}' removed`, 'EVENT_MANAGER');
                    return true;
                }
                return false;
            }
            
            has(name) {
                return this.listeners.has(name);
            }
            
            cleanup() {
                debugLog('Cleaning up event listeners...', 'EVENT_MANAGER');
                this.listeners.forEach((listener, name) => {
                    const {element, event, handler, options} = listener;
                    try {
                        element.removeEventListener(event, handler, options);
                        debugLog(`Cleaned up event listener '${name}'`, 'EVENT_MANAGER');
                    } catch (error) {
                        console.warn(`Failed to clean up event listener '${name}':`, error);
                    }
                });
                this.listeners.clear();
                debugLog('All event listeners cleaned up', 'EVENT_MANAGER');
            }
            
            getStats() {
                return {
                    listenerCount: this.listeners.size,
                    listenerNames: Array.from(this.listeners.keys())
                };
            }
        }
        debugLog('EventListenerManager class defined successfully');

        /**
         * NEW: ApiClient
         * Handles all communication with the local C++ web server.
         */
        debugLog('Defining ApiClient class...');
        class ApiClient {
            constructor(baseUrl = 'http://127.0.0.1:9090') {
                this.baseUrl = baseUrl;
                this.defaultTimeout = 30000; // 30 seconds default
                this.statusTimeout = 5000;   // 5 seconds for status checks (reduced from 10s)
                this.connectTimeout = 15000; // 15 seconds for connection attempts
                this.uploadTimeout = 300000; // 5 minutes for file uploads
            }

            // Helper method to create fetch requests with timeout
            async fetchWithTimeout(url, options = {}, timeoutMs = this.defaultTimeout) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                }, timeoutMs);

                try {
                    const startTime = performance.now();
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    const endTime = performance.now();
                    const responseTime = endTime - startTime;

                    clearTimeout(timeoutId);
                    
                    // Store response time for debugging
                    this.lastResponseTime = responseTime;
                    // debugLog(`API call to ${url} completed in ${responseTime.toFixed(0)}ms`, 'API_TIMING');

                    return response;
                } catch (error) {
                    clearTimeout(timeoutId);
                    
                    if (error.name === 'AbortError') {
                        throw new Error(`Request timeout after ${timeoutMs}ms`);
                    }
                    throw error;
                }
            }

            async getStatus() {
                debugLog('Fetching status...', 'API');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/status`, {}, this.statusTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                // debugLog('Status response:' + JSON.stringify(data), 'API');
                return data;
            }

            async connect(config) {
                debugLog('Connecting to server...' + JSON.stringify(config), 'API');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/connect`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(config),
                }, this.connectTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                debugLog('Connect response:' + JSON.stringify(data), 'API');
                return data;
            }

            async startBackup(file, config) {
                debugLog('Starting backup...', 'API');
                console.log('[DEBUG] startBackup called with:', {file: file.name, config});
                console.log('[DEBUG] API URL:', `${this.baseUrl}/api/start_backup`);
                const formData = new FormData();
                formData.append('file', file);
                formData.append('username', config.username);
                formData.append('server', config.serverIP);
                formData.append('port', config.serverPort);
                console.log('[DEBUG] FormData prepared:', {
                    file: file.name,
                    username: config.username,
                    server: config.serverIP,
                    port: config.serverPort
                });

                console.log('[DEBUG] Sending POST request to Flask API...');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/start_backup`, {
                    method: 'POST',
                    body: formData,
                }, this.uploadTimeout);
                console.log('[DEBUG] Response received:', response.status, response.statusText);
                if (!response.ok) {
                    console.log('[ERROR] HTTP error in startBackup:', response.status, response.statusText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('[DEBUG] Start backup response data:', data);
                debugLog('Start backup response:' + JSON.stringify(data), 'API');
                return data;
            }

            async stopBackup() {
                debugLog('Stopping backup...', 'API');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/stop`, { method: 'POST' }, this.defaultTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                debugLog('Stop backup response:' + JSON.stringify(data), 'API');
                return data;
            }

            async pauseBackup() {
                debugLog('Pausing backup...', 'API');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/pause`, { method: 'POST' }, this.defaultTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                debugLog('Pause backup response:' + JSON.stringify(data), 'API');
                return data;
            }

            async resumeBackup() {
                debugLog('Resuming backup...', 'API');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/resume`, { method: 'POST' }, this.defaultTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                debugLog('Resume backup response:' + JSON.stringify(data), 'API');
                return data;
            }

            async getServerInfo() {
                debugLog('Fetching server info...', 'API');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/server_info`, {}, this.defaultTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                debugLog('Server info response:' + JSON.stringify(data), 'API');
                return data;
            }

            async getReceivedFiles() {
                debugLog('Fetching received files...', 'API');
                const response = await this.fetchWithTimeout(`${this.baseUrl}/api/received_files`, {}, this.defaultTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                debugLog('Received files response:' + JSON.stringify(data), 'API');
                return data;
            }

            // Get timing and performance information
            getPerformanceInfo() {
                return {
                    lastResponseTime: this.lastResponseTime || 0,
                    baseUrl: this.baseUrl,
                    timeouts: {
                        default: this.defaultTimeout,
                        status: this.statusTimeout,
                        connect: this.connectTimeout,
                        upload: this.uploadTimeout
                    }
                };
            }

            // Update timeout settings
            updateTimeouts(timeouts) {
                if (timeouts.default) this.defaultTimeout = timeouts.default;
                if (timeouts.status) this.statusTimeout = timeouts.status;
                if (timeouts.connect) this.connectTimeout = timeouts.connect;
                if (timeouts.upload) this.uploadTimeout = timeouts.upload;
                debugLog('API timeouts updated', 'API');
            }
        }
        debugLog('ApiClient class defined successfully');

        /**
         * NEW: FileManager
         * Handles file selection (modern File System Access API with fallback).
         */
        debugLog('Defining FileManager class...');
        class FileManager {
            constructor() {
                this.supportsFileSystemAccess = 'showOpenFilePicker' in window;
                debugLog(`File System Access API supported: ${this.supportsFileSystemAccess}`, 'FILE_MANAGER');
                
                // File validation settings
                this.maxFileSize = 5 * 1024 * 1024 * 1024; // 5GB default
                this.allowedTypes = new Set([
                    // Documents
                    'application/pdf', 'text/plain', 'text/csv', 'application/json',
                    'application/xml', 'text/xml', 'application/rtf',
                    
                    // Microsoft Office
                    'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
                    
                    // Images
                    'image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/svg+xml',
                    'image/tiff', 'image/ico',
                    
                    // Audio
                    'audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/mp3', 'audio/flac', 'audio/aac',
                    
                    // Video
                    'video/mp4', 'video/webm', 'video/ogg', 'video/avi', 'video/mov', 'video/wmv',
                    'video/flv', 'video/mkv',
                    
                    // Archives
                    'application/zip', 'application/x-rar-compressed', 'application/x-7z-compressed',
                    'application/gzip', 'application/x-tar',
                    
                    // Code files
                    'text/javascript', 'text/css', 'text/html', 'application/javascript',
                    'text/x-python', 'text/x-java-source', 'text/x-c', 'text/x-c++',
                    
                    // Other common types
                    'application/octet-stream' // Binary files (fallback)
                ]);
                
                this.blockedExtensions = new Set([
                    '.exe', '.msi', '.bat', '.cmd', '.scr', '.pif', '.com', '.vbs', '.js', '.jar',
                    '.dll', '.sys', '.drv', '.ocx', '.cpl', '.reg', '.inf', '.ini'
                ]);
            }
            
            validateFile(file) {
                const errors = [];
                const warnings = [];
                
                // Check file size
                if (file.size > this.maxFileSize) {
                    errors.push(`File too large: ${this.formatFileSize(file.size)}. Maximum allowed: ${this.formatFileSize(this.maxFileSize)}`);
                }
                
                if (file.size === 0) {
                    errors.push('File is empty (0 bytes)');
                }
                
                // Check file extension for security
                const fileName = file.name.toLowerCase();
                const hasBlockedExtension = Array.from(this.blockedExtensions).some(ext => fileName.endsWith(ext));
                
                if (hasBlockedExtension) {
                    errors.push(`File type not allowed for security reasons: ${fileName.split('.').pop()}`);
                }
                
                // Check MIME type if available
                if (file.type) {
                    if (!this.allowedTypes.has(file.type)) {
                        // Don't block it entirely, but warn
                        warnings.push(`File type '${file.type}' is not in the common allowed list. Upload may still work.`);
                    }
                } else {
                    warnings.push('File type could not be determined. Proceed with caution.');
                }
                
                // Large file warning
                if (file.size > 100 * 1024 * 1024) { // 100MB
                    warnings.push(`Large file detected (${this.formatFileSize(file.size)}). Upload may take a long time.`);
                }
                
                return {
                    isValid: errors.length === 0,
                    errors,
                    warnings,
                    fileInfo: {
                        name: file.name,
                        size: file.size,
                        type: file.type || 'unknown',
                        lastModified: new Date(file.lastModified).toLocaleString()
                    }
                };
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
            }
            
            updateValidationSettings(settings) {
                if (settings.maxFileSize) {
                    this.maxFileSize = settings.maxFileSize;
                }
                if (settings.allowedTypes) {
                    this.allowedTypes = new Set(settings.allowedTypes);
                }
                if (settings.blockedExtensions) {
                    this.blockedExtensions = new Set(settings.blockedExtensions);
                }
                debugLog('File validation settings updated', 'FILE_MANAGER');
            }

            async selectFile() {
                // First try modern File System Access API
                if (this.supportsFileSystemAccess) {
                    try {
                        // console.log('[FileManager] Attempting modern file picker...');
                        const [fileHandle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'All files',
                                accept: {
                                    '*/*': ['.*']
                                }
                            }],
                            multiple: false
                        });
                        
                        const file = await fileHandle.getFile();
                        // console.log('[FileManager] Modern file picker succeeded:', file.name);
                        return file;
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            console.warn('[FileManager] Modern file picker failed:', error);
                            console.log('[FileManager] Falling back to traditional input...');
                        } else {
                            console.log('[FileManager] User cancelled modern file picker');
                            return null;
                        }
                    }
                }
                
                // Fallback to traditional file input - improved version
                console.log('[FileManager] Using traditional file input fallback');
                return new Promise((resolve, reject) => {
                    try {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = '*/*';
                        input.style.display = 'none';
                        
                        // Add to DOM for better browser compatibility
                        document.body.appendChild(input);
                        
                        // Set up event handlers
                        const cleanup = () => {
                            if (input.parentNode) {
                                input.parentNode.removeChild(input);
                            }
                        };
                        
                        input.onchange = (event) => {
                            const file = event.target.files[0] || null;
                            console.log('[FileManager] Traditional file picker result:', file ? file.name : 'No file selected');
                            cleanup();
                            resolve(file);
                        };
                        
                        input.oncancel = () => {
                            console.log('[FileManager] User cancelled traditional file picker');
                            cleanup();
                            resolve(null);
                        };
                        
                        // Handle case where user closes dialog without triggering change
                        const handleFocus = () => {
                            setTimeout(() => {
                                if (!input.files.length) {
                                    console.log('[FileManager] Focus returned, assuming dialog was cancelled');
                                    cleanup();
                                    resolve(null);
                                }
                                window.removeEventListener('focus', handleFocus);
                            }, 300);
                        };
                        
                        window.addEventListener('focus', handleFocus);
                        
                        // Trigger file dialog
                        input.click();
                        
                        // Safety timeout
                        setTimeout(() => {
                            if (input.parentNode) {
                                console.warn('[FileManager] File picker timeout, cleaning up');
                                cleanup();
                                resolve(null);
                            }
                        }, 30000);
                        
                    } catch (error) {
                        console.error('[FileManager] Fallback file picker error:', error);
                        reject(error);
                    }
                });
            }

            setupDragAndDrop(dropZone, onFileSelected) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });

                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('drag-over');
                });

                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    if (e.dataTransfer.files.length > 0) {
                        onFileSelected(e.dataTransfer.files[0]);
                    }
                });

                // Handle click on the drop zone to trigger file input
                dropZone.addEventListener('click', () => {
                    const fileInput = dropZone.querySelector('.file-input');
                    if (fileInput) {
                        fileInput.click();
                    }
                });

                // Handle file input change directly
                const fileInput = dropZone.querySelector('.file-input');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        if (e.target.files.length > 0) {
                            onFileSelected(e.target.files[0]);
                        }
                    });
                }
            }
        }
        debugLog('FileManager class defined successfully');

        /**
         * NEW: SystemManager
         * Handles system-level interactions like notifications, modals, and keyboard shortcuts.
         */
        debugLog('Defining SystemManager class...');
        class SystemManager {
            constructor() {
                this.notifications = new NotificationManager();
                this.fileManager = new FileManager();
                this.modal = new ModalManager();
                this.confirmModal = new ConfirmModalManager();
            }

            announce(message) {
                // Announce to screen readers for accessibility
                if ('speechSynthesis' in window) {
                    // Use speech synthesis if available (optional)
                    // speechSynthesis.speak(new SpeechSynthesisUtterance(message));
                }
                // Create a live region for screen readers
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.className = 'u-sr-only';
                liveRegion.textContent = message;
                document.body.appendChild(liveRegion);

                // Remove after announcement
                setTimeout(() => {
                    if (liveRegion.parentNode) {
                        liveRegion.parentNode.removeChild(liveRegion);
                    }
                }, 1000);
            }

            setupKeyboardShortcuts(appInstance) {
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.modal.hide();
                        this.confirmModal.hide();
                    }
                    // Ctrl+S to save config
                    if (e.ctrlKey && e.key === 's') {
                        e.preventDefault();
                        appInstance.saveConfig();
                    }
                    // Ctrl+B to start backup
                    if (e.ctrlKey && e.key === 'b') {
                        e.preventDefault();
                        appInstance.handlePrimaryAction();
                    }
                    // Ctrl+P to pause/resume
                    if (e.ctrlKey && e.key === 'p') {
                        e.preventDefault();
                        appInstance.togglePause();
                    }
                    // Ctrl+T to stop
                    if (e.ctrlKey && e.key === 't') {
                        e.preventDefault();
                        appInstance.stopBackup();
                    }
                });
            }
        }
        debugLog('SystemManager class defined successfully');

        /**
         * NEW: NotificationManager
         * Handles browser notifications.
         */
        debugLog('Defining NotificationManager class...');
        class NotificationManager {
            constructor() {
                if (!('Notification' in window)) {
                    debugLog('Browser does not support notifications.', 'NOTIFICATIONS');
                }
            }

            async requestPermission() {
                if (!('Notification' in window)) return;
                const permission = await Notification.requestPermission();
                debugLog(`Notification permission: ${permission}`, 'NOTIFICATIONS');
                return permission;
            }

            show(title, body, options = {}) {
                if (!('Notification' in window) || Notification.permission !== 'granted') {
                    debugLog('Notification permission not granted or not supported.', 'NOTIFICATIONS');
                    return;
                }
                const notification = new Notification(title, { body, ...options });
                debugLog(`Notification shown: ${title} - ${body}`, 'NOTIFICATIONS');
                return notification;
            }
        }
        debugLog('NotificationManager class defined successfully');

        /**
         * NEW: ModalManager
         * Handles generic modal dialogs.
         */
        debugLog('Defining ModalManager class...');
        class ModalManager {
            constructor() {
                // Get elements directly from DOM - no circular dependency
                this.modalOverlay = document.getElementById('confirmModal');
                this.modalTitle = document.getElementById('confirmTitle');
                this.modalMessage = document.getElementById('confirmMessage');
                this.confirmOkBtn = document.getElementById('confirmOkBtn');
                this.cancelBtn = document.getElementById('cancelModalBtn');

                this.resolve = null;
                this.reject = null;

                if (this.cancelBtn) {
                    this.cancelBtn.addEventListener('click', () => this.hide());
                }
                if (this.modalOverlay) {
                    this.modalOverlay.addEventListener('click', (e) => {
                        if (e.target === this.modalOverlay) {
                            this.hide();
                        }
                    });
                }
            }

            show(title, message, onConfirm) {
                this.modalTitle.textContent = title;
                this.modalMessage.textContent = message;
                this.confirmOkBtn.onclick = () => {
                    onConfirm();
                    this.hide();
                };
                this.modalOverlay.classList.add('show');
            }

            hide() {
                this.modalOverlay.classList.remove('show');
            }
        }
        debugLog('ModalManager class defined successfully');

        /**
         * NEW: ConfirmModalManager
         * Handles confirmation dialogs with Promises.
         */
        debugLog('Defining ConfirmModalManager class...');
        class ConfirmModalManager extends ModalManager {
            constructor() {
                super();
                // Override the parent event listeners for promise-based flow
                if (this.confirmOkBtn) {
                    this.confirmOkBtn.onclick = null; // Clear any existing onclick
                    this.confirmOkBtn.addEventListener('click', () => {
                        if (this.resolve) this.resolve(true);
                        this.hide();
                    });
                }
                if (this.cancelBtn) {
                    this.cancelBtn.onclick = null; // Clear any existing onclick
                    this.cancelBtn.addEventListener('click', () => {
                        if (this.resolve) this.resolve(false);
                        this.hide();
                    });
                }
            }

            async confirm(title, message) {
                this.modalTitle.textContent = title;
                this.modalMessage.textContent = message;
                this.modalOverlay.classList.add('show');
                return new Promise((resolve, reject) => {
                    this.resolve = resolve;
                    this.reject = reject;
                });
            }
        }
        debugLog('ConfirmModalManager class defined successfully');

        /**
         * ThemeManager - Handles theme switching
         */
        debugLog('Defining ThemeManager class...');
        class ThemeManager {
            constructor() {
                this.currentTheme = 'cyberpunk';
                this.themes = {
                    cyberpunk: 'cyberpunk',
                    dark: 'dark', 
                    matrix: 'matrix'
                };
            }
            
            loadSavedTheme() {
                try {
                    const savedTheme = localStorage.getItem('cyberbackup_theme');
                    if (savedTheme && this.themes[savedTheme]) {
                        this.setTheme(savedTheme);
                    }
                } catch (error) {
                    console.warn('Failed to load saved theme:', error);
                }
            }
            
            setTheme(theme) {
                if (this.themes[theme]) {
                    this.currentTheme = theme;
                    document.body.className = theme;
                    try {
                        localStorage.setItem('cyberbackup_theme', theme);
                    } catch (error) {
                        console.warn('Failed to save theme:', error);
                    }
                    console.log('Theme set to:', theme);
                }
            }
        }
        debugLog('ThemeManager class defined successfully');

        /**
         * Main Application Logic (App class)
         */
        debugLog('Defining App class...');
        class App {
            constructor() {
                this.apiClient = new ApiClient();
                this.system = new SystemManager();
                this.intervals = new IntervalManager();
                this.eventListeners = new EventListenerManager();
                this.buttonStateManager = new ButtonStateManager();
                this.errorMessageFormatter = new ErrorMessageFormatter();
                this.copyManager = new CopyManager();
                this.formValidator = new FormValidator();
                this.fileMemoryManager = new FileMemoryManager();
                this.backupHistoryManager = new BackupHistoryManager();
                this.connectionHealthMonitor = new ConnectionHealthMonitor();
                
                // Initialize WebSocket connection for real-time updates
                this.socket = null;
                this.socketConnected = false;
                this.initializeWebSocket();

                this.elements = {
                    connectionLed: document.getElementById('connectionLed'),
                    connectionText: document.getElementById('connectionText'),
                    serverInput: document.getElementById('serverInput'),
                    usernameInput: document.getElementById('usernameInput'),
                    fileDropZone: document.getElementById('fileDropZone'),
                    fileInput: document.getElementById('fileInput'),
                    recentFilesBtn: document.getElementById('recentFilesBtn'),
                    selectedFileDisplay: document.getElementById('selectedFile'),
                    filePreview: document.getElementById('filePreview'),
                    clientIdDisplay: document.getElementById('clientId'),
                    copyClientIdButton: document.getElementById('copyClientId'),
                    copyServerAddressButton: document.getElementById('copyServerAddress'),
                    copyFileInfoButton: document.getElementById('copyFileInfo'),
                    primaryActionButton: document.getElementById('primaryAction'),
                    pauseButton: document.getElementById('pauseBtn'),
                    stopButton: document.getElementById('stopBtn'),
                    currentPhaseDisplay: document.getElementById('currentPhase'),
                    progressCircle: document.getElementById('progressCircle'),
                    progressPercentage: document.getElementById('progressPercentage'),
                    progressStatus: document.getElementById('progressStatus'),
                    speedStat: document.getElementById('speedStat'),
                    etaStat: document.getElementById('etaStat'),
                    transferredStat: document.getElementById('transferredStat'),
                    sizeStat: document.getElementById('sizeStat'),
                    logContainer: document.getElementById('logContainer'),
                    autoScrollBtn: document.getElementById('autoScrollBtn'),
                    debugToggle: document.getElementById('debugToggle'),
                    debugContent: document.getElementById('debugContent'),
                    statusJsonViewer: document.getElementById('statusJsonViewer'),
                    progressJsonViewer: document.getElementById('progressJsonViewer'),
                    toastContainer: document.getElementById('toastContainer'),
                    confirmModal: document.getElementById('confirmModal'),
                    confirmTitle: document.getElementById('confirmTitle'),
                    confirmMessage: document.getElementById('confirmMessage'),
                    confirmOkBtn: document.getElementById('confirmOkBtn'),
                    cancelModalBtn: document.getElementById('cancelModalBtn'),
                    connectionHealth: document.getElementById('connectionHealth'),
                    healthIndicator: document.getElementById('healthIndicator'),
                    pingDisplay: document.getElementById('pingDisplay'),
                    // Additional frequently accessed elements
                    saveConfigBtn: document.querySelector('[data-action="save-config"]'),
                    exportLogBtn: document.querySelector('[data-action="export-log"]'),
                    clearLogBtn: document.querySelector('[data-action="clear-log"]'),
                    advancedSettings: document.querySelector('.advanced-settings'),
                    debugPanel: document.querySelector('.debug-panel'),
                    particleContainer: document.getElementById('particleContainer'),
                    // Cached NodeLists for bulk operations
                    themeButtons: document.querySelectorAll('.theme-btn'),
                    lazyComponents: document.querySelectorAll('[data-lazy-component]')
                };

                // Verify critical DOM elements exist
                this.verifyDOMElements();

                this.state = {
                    isConnected: false,
                    isRunning: false,
                    isPaused: false,
                    phase: 'SYSTEM_READY',
                    progress: 0,
                    file_name: '',
                    file_size: 0,
                    transferred: 0,
                    speed: 0,
                    eta: '--:--',
                    clientId: null,
                    log: { operation: 'System Initialized', success: true, details: '' },
                    lastApiStatus: null,
                    selectedFile: null
                };

                // Enhanced state management for preventing race conditions and optimizing performance
                this.stateManagement = {
                    isPolling: false,
                    isUpdatingUI: false,
                    lastPollTime: 0,
                    pollCooldown: 2000, // Minimum time between polls in ms (increased from 500ms to 2s)
                    adaptivePollInterval: 3000, // Dynamic interval that adapts based on activity (increased from 1s to 3s)
                    maxPollInterval: 10000, // Maximum interval when idle (increased from 5s to 10s)
                    minPollInterval: 2000, // Minimum interval when active (increased from 500ms to 2s)
                    consecutiveNoChangeCount: 0, // Track periods of no activity
                    uiUpdateQueue: [],
                    updateUIDebounced: null // Will be set after debounce method is defined
                };
                
                this.pendingConfirmAction = null;
                this.autoScrollLog = true;
                this.themeManager = new ThemeManager();

                // Modal managers are already initialized in SystemManager constructor
                
                // Set up debounced UI update after methods are defined
                this.stateManagement.updateUIDebounced = this.debounce(() => this._updateAllUI(), 150);

                // Verify critical DOM elements exist before initialization
                if (!this.verifyDOMElements()) {
                    console.error('[DOM_VERIFICATION] CRITICAL: Missing DOM elements - buttons will not work');
                    alert('Error: Critical UI elements are missing. Please refresh the page.');
                    return;
                }
                
                this.initEventListeners();
                this.loadSavedConfig();
                this.themeManager.loadSavedTheme();
                this.system.setupKeyboardShortcuts(this); // Add keyboard shortcuts

                // Initialize lazy loading system for performance
                this.lazyComponents = new Map();
                this.initializeLazyLoading();

                // Setup cleanup handlers for memory leak prevention
                this.setupPageUnloadHandler();

                // Initialize real-time WebSocket communication (replaces polling)
                this.uiUpdateTimeout = null; // For debounced UI updates
                this.progressConfig = null; // Progress configuration for rich UX
                this.phaseStartTime = null; // For ETA calculations
                this.loadProgressConfiguration();
                this.connectWebSocket();
                this.addLog('System Initialized', 'success', 'Real-time communication enabled.');
                this.system.notifications.show('CyberBackup Pro', 'Application ready', { type: 'info', silent: true });
                
                // Request notification permission on startup
                this.system.notifications.requestPermission();
                
                // Setup form validation
                this.setupFormValidation();
                
                // Initialize connection health monitoring
                this.setupConnectionHealthMonitoring();
            }

            /**
             * Initialize WebSocket connection for real-time progress updates
             */
            initializeWebSocket() {
                debugLog('Initializing WebSocket connection...', 'WEBSOCKET');
                this.socket = io();
                this.setupWebSocketEventHandlers();
            }

            /**
             * Setup WebSocket event handlers for real-time communication
             */
            setupWebSocketEventHandlers() {
                // Connection events
                this.socket.on('connect', () => {
                    this.socketConnected = true;
                    debugLog('WebSocket connected successfully', 'WEBSOCKET');
                    this.addLog('Real-time connection', 'success', 'WebSocket connected - live updates enabled');
                    this.updateConnectionStatus(true);
                });

                this.socket.on('disconnect', () => {
                    this.socketConnected = false;
                    debugLog('WebSocket disconnected', 'WEBSOCKET');
                    this.addLog('Connection lost', 'warning', 'WebSocket disconnected - falling back to polling');
                    this.updateConnectionStatus(false);
                    // Fallback to polling if WebSocket fails
                    this.startPollingFallback();
                });

                // Real-time progress updates
                this.socket.on('progress_update', (data) => {
                    debugLog('Received progress update via WebSocket:', data, 'WEBSOCKET');
                    this.handleRealTimeProgressUpdate(data);
                });

                // Status updates
                this.socket.on('status', (data) => {
                    debugLog('Received status update via WebSocket:', data, 'WEBSOCKET');
                    this.state.isConnected = data.connected;
                    this.updateAllUI();
                });

                // Pong response for connection testing
                this.socket.on('pong', (data) => {
                    debugLog('WebSocket ping response received', 'WEBSOCKET');
                });

                // Error handling for backup failures
                this.socket.on('backup_error', (data) => {
                    debugLog('Backup error received via WebSocket:', data, 'ERROR');
                    this.handleBackupError(data);
                });

                // Connection error handling
                this.socket.on('connect_error', (error) => {
                    debugLog('WebSocket connection error:', error, 'ERROR');
                    this.handleConnectionError(error);
                });
            }

            /**
             * Connect to WebSocket server
             */
            connectWebSocket() {
                if (this.socket && this.socketConnected) {
                    debugLog('WebSocket already connected', 'WEBSOCKET');
                    return;
                }

                try {
                    debugLog('Attempting WebSocket connection...', 'WEBSOCKET');
                    this.initializeWebSocket();
                } catch (error) {
                    console.error('WebSocket connection failed:', error);
                    this.addLog('WebSocket error', 'error', 'Failed to connect - using polling fallback');
                    this.startPollingFallback();
                }
            }

            /**
             * Handle real-time progress updates from WebSocket with rich context
             */
            handleRealTimeProgressUpdate(data) {
                const { job_id, phase, data: progressData, timestamp, progress } = data;
                
                // Only process updates for current job
                if (job_id && this.state.jobId && job_id !== this.state.jobId) {
                    debugLog('Ignoring progress update for different job', 'WEBSOCKET');
                    return;
                }

                // Track phase transitions for ETA calculations
                if (phase && phase !== this.state.phase) {
                    this.phaseStartTime = Date.now();
                    debugLog(`Phase transition: ${this.state.phase} ‚Üí ${phase}`, 'PROGRESS');
                }

                // Update state with real-time data
                if (phase) {
                    this.state.phase = phase;
                    // Use rich phase description from configuration
                    this.state.phaseDescription = this.getPhaseDescription(phase);
                }
                
                if (progress !== null && progress !== undefined) {
                    this.state.progress = progress;
                }

                // Process the progress data with enhanced context
                if (progressData) {
                    if (typeof progressData === 'object') {
                        const message = progressData.message || this.state.phaseDescription;
                        this.state.log = { operation: phase, success: true, details: message };
                        
                        if (progressData.progress !== undefined) {
                            this.state.progress = progressData.progress;
                        }
                    } else {
                        const message = progressData || this.state.phaseDescription;
                        this.state.log = { operation: phase, success: true, details: message };
                    }
                }

                // Calculate and update ETA
                if (this.phaseStartTime && phase) {
                    const elapsedMs = Date.now() - this.phaseStartTime;
                    const etaSeconds = this.calculateETA(phase, elapsedMs);
                    if (etaSeconds !== null) {
                        this.state.eta = this.formatETA(etaSeconds);
                        this.state.etaSeconds = etaSeconds;
                    }
                }

                // Debounced UI update for smooth performance (50ms debounce)
                this.debouncedUIUpdate();
                
                // Add timestamped log entry with rich context
                const timestampStr = new Date(timestamp * 1000).toLocaleTimeString();
                const phaseDesc = this.state.phaseDescription || phase;
                const etaInfo = this.state.eta ? ` (ETA: ${this.state.eta})` : '';
                debugLog(`Real-time update [${timestampStr}]: ${phaseDesc} - ${progress}%${etaInfo}`, 'PROGRESS');
                
                // Show phase transition notifications for important phases
                if (phase && ['CONNECTING', 'AUTHENTICATING', 'ENCRYPTING', 'TRANSFERRING', 'VERIFYING', 'COMPLETED'].includes(phase)) {
                    this.showPhaseTransitionNotification(phase, this.state.phaseDescription);
                }
            }

            /**
             * Show subtle notification for phase transitions
             */
            showPhaseTransitionNotification(phase, description) {
                // Only show notifications for significant phase changes, not every progress update
                if (this.lastNotificationPhase === phase) return;
                
                this.lastNotificationPhase = phase;
                
                // Use the existing toast system for phase notifications
                if (phase === 'COMPLETED') {
                    this.showToast(description, 'success', 3000);
                } else if (phase === 'TRANSFERRING') {
                    this.showToast(description, 'info', 2000);
                } else {
                    // Subtle notifications for other phases
                    debugLog(`Phase: ${description}`, 'PHASE');
                }
            }

            /**
             * Handle backup errors with restart option
             */
            handleBackupError(errorData) {
                const { message, phase, job_id } = errorData;
                
                // Update state to reflect error
                this.state.phase = 'ERROR';
                this.state.isRunning = false;
                this.state.hasError = true;
                this.state.errorMessage = message || 'Backup failed unexpectedly';
                this.state.errorPhase = phase || 'UNKNOWN';
                
                // Clear progress and ETA
                this.state.progress = 0;
                this.state.eta = null;
                this.state.etaSeconds = 0;
                
                // Add error log entry
                this.addLog('Backup failed', 'error', this.state.errorMessage);
                
                // Show error toast with restart option
                this.showErrorWithRestart(this.state.errorMessage);
                
                // Update UI to show error state
                this.updateAllUI();
                
                debugLog(`Backup error in phase ${this.state.errorPhase}: ${this.state.errorMessage}`, 'ERROR');
            }

            /**
             * Handle WebSocket connection errors
             */
            handleConnectionError(error) {
                debugLog('WebSocket connection error, falling back to polling', 'ERROR');
                this.addLog('Connection error', 'warning', 'WebSocket failed, using polling fallback');
                this.startPollingFallback();
            }

            /**
             * Show error message with restart button
             */
            showErrorWithRestart(errorMessage) {
                // Create error notification with restart button
                const errorHtml = `
                    <div class="error-restart-container">
                        <div class="error-message">‚ùå ${errorMessage}</div>
                        <button id="restartBackupBtn" class="restart-btn" 
                                onclick="window.app.restartBackup()" 
                                style="margin-top: 10px; padding: 8px 16px; background: var(--neon-blue); color: var(--bg-dark); border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                            üîÑ Restart Backup
                        </button>
                    </div>
                `;
                
                // Show persistent error toast
                this.showToast(errorHtml, 'error', 0); // 0 = persistent (won't auto-hide)
                
                // Also update any error display elements in the UI
                this.updateErrorDisplay();
            }

            /**
             * Update error display elements in the UI
             */
            updateErrorDisplay() {
                // Find error display elements and update them
                const errorElements = document.querySelectorAll('.error-display, .backup-error');
                errorElements.forEach(element => {
                    if (this.state.hasError) {
                        element.innerHTML = `
                            <div class="error-content">
                                <div class="error-text">‚ùå ${this.state.errorMessage}</div>
                                <button class="restart-btn" onclick="window.app.restartBackup()">
                                    üîÑ Restart Backup
                                </button>
                            </div>
                        `;
                        element.style.display = 'block';
                    } else {
                        element.style.display = 'none';
                    }
                });
            }

            /**
             * Restart backup operation (called by restart button)
             */
            restartBackup() {
                debugLog('Manual backup restart requested', 'RESTART');
                
                // Clear error state
                this.clearErrorState();
                
                // Reset progress state
                this.resetProgressState();
                
                // Close any error toasts
                this.clearErrorToasts();
                
                // Start fresh backup with current settings
                this.startBackup();
                
                this.addLog('Backup restarted', 'info', 'Manual restart initiated');
                this.showToast('Backup restarted - attempting fresh upload', 'info', 3000);
            }

            /**
             * Clear error state
             */
            clearErrorState() {
                this.state.hasError = false;
                this.state.errorMessage = null;
                this.state.errorPhase = null;
                this.state.phase = 'READY';
                this.lastNotificationPhase = null;
                
                // Update error display elements
                this.updateErrorDisplay();
            }

            /**
             * Reset progress state for fresh start
             */
            resetProgressState() {
                this.state.progress = 0;
                this.state.eta = null;
                this.state.etaSeconds = 0;
                this.state.isRunning = false;
                this.state.phaseDescription = null;
                this.phaseStartTime = null;
            }

            /**
             * Clear error toast notifications
             */
            clearErrorToasts() {
                // Find and remove error toasts
                const errorToasts = document.querySelectorAll('.toast.error');
                errorToasts.forEach(toast => {
                    toast.remove();
                });
            }

            /**
             * Enhanced error detection for backup failures
             */
            detectBackupFailure(statusData) {
                // Detect failure conditions from status data
                if (statusData.status === 'error' || statusData.phase === 'FAILED') {
                    const errorMessage = statusData.message || 'Backup operation failed';
                    this.handleBackupError({
                        message: errorMessage,
                        phase: statusData.phase || 'UNKNOWN',
                        job_id: this.state.jobId
                    });
                    return true;
                }
                
                // Detect timeout conditions
                if (this.state.isRunning && this.state.progress === 0) {
                    const elapsedTime = Date.now() - (this.backupStartTime || Date.now());
                    if (elapsedTime > 60000) { // 60 seconds with no progress
                        this.handleBackupError({
                            message: 'Backup appears to be stuck - no progress after 60 seconds',
                            phase: this.state.phase || 'TIMEOUT',
                            job_id: this.state.jobId
                        });
                        return true;
                    }
                }
                
                return false;
            }

            /**
             * Debounced UI update for smooth real-time progress
             */
            debouncedUIUpdate() {
                if (this.uiUpdateTimeout) {
                    clearTimeout(this.uiUpdateTimeout);
                }
                
                this.uiUpdateTimeout = setTimeout(() => {
                    requestAnimationFrame(() => {
                        this.updateAllUI();
                    });
                }, 50); // 50ms debounce for smooth UI updates
            }

            /**
             * Start polling fallback when WebSocket fails
             */
            startPollingFallback() {
                if (this.socketConnected) {
                    debugLog('WebSocket connected, skipping polling fallback', 'WEBSOCKET');
                    return;
                }

                debugLog('Starting polling fallback...', 'POLL');
                this.startAdaptivePolling();
            }

            /**
             * Load progress configuration for rich UX
             */
            async loadProgressConfiguration() {
                try {
                    const response = await fetch('/progress_config.json');
                    if (response.ok) {
                        this.progressConfig = await response.json();
                        debugLog('Progress configuration loaded successfully', 'CONFIG');
                        this.addLog('Progress system', 'success', 'Rich progress context enabled');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.warn('Could not load progress configuration:', error);
                    this.addLog('Progress config', 'warning', 'Using default progress display');
                    // Use fallback configuration
                    this.progressConfig = this.getDefaultProgressConfig();
                }
            }

            /**
             * Get default progress configuration if file loading fails
             */
            getDefaultProgressConfig() {
                return {
                    phases: {
                        "CONNECTING": { weight: 0.10, description: "Connecting to server...", progress_range: [0, 10] },
                        "AUTHENTICATING": { weight: 0.15, description: "Authenticating...", progress_range: [10, 25] },
                        "ENCRYPTING": { weight: 0.30, description: "Encrypting file...", progress_range: [25, 55] },
                        "TRANSFERRING": { weight: 0.35, description: "Transferring data...", progress_range: [55, 90] },
                        "VERIFYING": { weight: 0.10, description: "Verifying integrity...", progress_range: [90, 100] },
                        "COMPLETED": { weight: 0.00, description: "Backup completed!", progress_range: [100, 100] }
                    },
                    calibration_info: { total_avg_duration_ms: 4200 }
                };
            }

            /**
             * Calculate ETA based on current phase and elapsed time
             */
            calculateETA(currentPhase, elapsedMs) {
                if (!this.progressConfig || !currentPhase) return null;

                const phaseConfig = this.progressConfig.phases[currentPhase];
                if (!phaseConfig) return null;

                // Calculate total expected duration
                const totalExpectedMs = this.progressConfig.calibration_info.total_avg_duration_ms || 4200;
                
                // Calculate progress through current phase
                const phaseProgress = this.getPhaseProgress(currentPhase);
                
                // Estimate remaining time
                const completedWeight = this.getCompletedWeight(currentPhase, phaseProgress);
                const remainingWeight = 1.0 - completedWeight;
                const estimatedRemainingMs = remainingWeight * totalExpectedMs;

                return Math.max(0, Math.round(estimatedRemainingMs / 1000)); // Return seconds
            }

            /**
             * Get progress within current phase (0.0 to 1.0)
             */
            getPhaseProgress(currentPhase) {
                if (!this.progressConfig || !currentPhase) return 0;
                
                const phaseConfig = this.progressConfig.phases[currentPhase];
                if (!phaseConfig || !phaseConfig.progress_range) return 0;
                
                const [rangeStart, rangeEnd] = phaseConfig.progress_range;
                const rangeSize = rangeEnd - rangeStart;
                
                if (rangeSize <= 0) return 1.0;
                
                // Calculate progress within this phase based on current overall progress
                const currentProgress = this.state.progress || 0;
                const progressInRange = Math.max(0, Math.min(currentProgress - rangeStart, rangeSize));
                
                return progressInRange / rangeSize;
            }

            /**
             * Get total completed weight across all phases
             */
            getCompletedWeight(currentPhase, phaseProgress) {
                if (!this.progressConfig) return 0;
                
                let completedWeight = 0;
                const phases = Object.keys(this.progressConfig.phases);
                const currentPhaseIndex = phases.indexOf(currentPhase);
                
                // Add weight from completed phases
                for (let i = 0; i < currentPhaseIndex; i++) {
                    const phase = phases[i];
                    completedWeight += this.progressConfig.phases[phase].weight || 0;
                }
                
                // Add partial weight from current phase
                if (currentPhaseIndex >= 0) {
                    const currentPhaseWeight = this.progressConfig.phases[currentPhase].weight || 0;
                    completedWeight += currentPhaseWeight * phaseProgress;
                }
                
                return Math.min(1.0, completedWeight);
            }

            /**
             * Get rich phase description from configuration
             */
            getPhaseDescription(phase) {
                if (!this.progressConfig || !phase) return phase;
                
                const phaseConfig = this.progressConfig.phases[phase];
                return phaseConfig ? phaseConfig.description : phase;
            }

            /**
             * Format ETA for display
             */
            formatETA(seconds) {
                if (!seconds || seconds <= 0) return 'Calculating...';
                
                if (seconds < 60) {
                    return `${seconds}s remaining`;
                } else if (seconds < 3600) {
                    const minutes = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${minutes}m ${secs}s remaining`;
                } else {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    return `${hours}h ${minutes}m remaining`;
                }
            }

            /**
             * Test WebSocket connection
             */
            testWebSocketConnection() {
                if (this.socketConnected) {
                    this.socket.emit('ping');
                    debugLog('WebSocket ping sent', 'WEBSOCKET');
                    return true;
                }
                return false;
            }

            /**
             * Update connection status in UI
             */
            updateConnectionStatus(connected) {
                // This method can be enhanced to show WebSocket connection status
                // in addition to server connection status
                this.state.websocketConnected = connected;
                // The existing updateAllUI() will handle the visual updates
            }

            /**
             * Setup form validation rules and real-time validation
             */
            setupFormValidation() {
                // Add validation rules
                this.formValidator.addRule('serverInput', 'serverAddress', 'Please enter a valid server address (IP:PORT)');
                this.formValidator.addRule('usernameInput', 'username', 'Username must be 2-32 characters (letters, numbers, _ -)');

                // Setup real-time validation
                this.formValidator.setupRealTimeValidation(this.elements.serverInput, 'serverInput');
                this.formValidator.setupRealTimeValidation(this.elements.usernameInput, 'usernameInput');
            }

            /**
             * Setup connection health monitoring system
             */
            setupConnectionHealthMonitoring() {
                // Initialize the health monitor with the UI elements
                this.connectionHealthMonitor.initialize(
                    this.elements.connectionHealth,
                    this.elements.healthIndicator,
                    this.elements.pingDisplay
                );
            }

            verifyDOMElements() {
                const criticalElements = [
                    'primaryActionButton',
                    'serverInput',
                    'usernameInput',
                    'fileDropZone',
                    'logContainer',
                    'saveConfigBtn',
                    'exportLogBtn',
                    'clearLogBtn'
                ];

                const missingElements = [];
                for (const elementName of criticalElements) {
                    if (!this.elements[elementName]) {
                        missingElements.push(elementName);
                        console.error(`[DOM_VERIFICATION] Critical element missing: ${elementName}`);
                    }
                }

                if (missingElements.length > 0) {
                    const errorMsg = `Missing DOM elements: ${missingElements.join(', ')}`;
                    console.error('[DOM_VERIFICATION] CRITICAL:', errorMsg);
                    
                    // Try to show user-friendly error
                    try {
                        alert(`GUI Error: Some interface elements are missing. Please refresh the page.\n\nMissing: ${missingElements.join(', ')}`);
                    } catch (e) {
                        console.error('[DOM_VERIFICATION] Could not show alert:', e);
                    }
                    
                    throw new Error(errorMsg);
                }
                
                console.log('[DOM_VERIFICATION] All critical elements found successfully');
            }

            initEventListeners() {
                console.log('[EVENT_DEBUG] Initializing event listeners...');
                console.log('[EVENT_DEBUG] Primary action button element:', this.elements.primaryActionButton);
                
                // Main action buttons - using managed event listeners for cleanup
                const primaryResult = this.eventListeners.add('primary-action', this.elements.primaryActionButton, 'click', () => this.handlePrimaryAction());
                console.log('[EVENT_DEBUG] Primary action listener result:', primaryResult);
                this.eventListeners.add('pause-action', this.elements.pauseButton, 'click', () => this.togglePause());
                this.eventListeners.add('stop-action', this.elements.stopButton, 'click', () => this.stopBackup());
                
                // Copy buttons - using managed event listeners
                this.eventListeners.add('copy-client-id', this.elements.copyClientIdButton, 'click', () => this.copyClientId());
                this.eventListeners.add('copy-server-addr', this.elements.copyServerAddressButton, 'click', () => this.copyServerAddress());
                this.eventListeners.add('copy-file-info', this.elements.copyFileInfoButton, 'click', () => this.copyFileInfo());
                
                // Recent files button
                this.elements.recentFilesBtn.addEventListener('click', () => this.showRecentFiles());
                
                // Config save button
                this.elements.saveConfigBtn.addEventListener('click', () => this.saveConfig());

                // File drop zone
                this.system.fileManager.setupDragAndDrop(
                    this.elements.fileDropZone,
                    (file) => this.handleFileSelection(file)
                );

                // Log controls
                this.elements.exportLogBtn.addEventListener('click', () => this.exportLog());
                this.elements.clearLogBtn.addEventListener('click', () => this.clearLog());
                this.elements.autoScrollBtn.addEventListener('click', () => this.toggleAutoScroll());

                // Debug toggle
                this.elements.debugToggle.addEventListener('click', () => this.toggleDebugConsole());

                // Theme buttons - using managed event listeners to prevent memory leaks
                this.elements.themeButtons.forEach((btn, index) => {
                    this.eventListeners.add(`theme-btn-${index}`, btn, 'click', (e) => {
                        const theme = e.target.classList[1]; // e.g., 'cyberpunk', 'dark', 'matrix'
                        this.themeManager.setTheme(theme);
                    });
                });

                // Modals
                this.elements.confirmOkBtn.addEventListener('click', () => {
                    if (this.pendingConfirmAction) {
                        this.pendingConfirmAction.resolve(true);
                        this.pendingConfirmAction = null;
                    }
                    this.system.confirmModal.hide();
                });
                this.elements.cancelModalBtn.addEventListener('click', () => {
                    if (this.pendingConfirmAction) {
                        this.pendingConfirmAction.resolve(false);
                        this.pendingConfirmAction = null;
                    }
                    this.system.confirmModal.hide();
                });
            }

            async pollStatus() {
                if (this.stateManagement.isPolling) {
                    debugLog('Skipping poll: already polling', 'POLL');
                    return;
                }

                const now = Date.now();
                if (now - this.stateManagement.lastPollTime < this.stateManagement.pollCooldown) {
                    debugLog('Skipping poll: cooldown active', 'POLL');
                    return;
                }

                this.stateManagement.isPolling = true;
                this.stateManagement.lastPollTime = now;

                try {
                    const status = await this.apiClient.getStatus(this.state.jobId);

                    if (status.events && status.events.length > 0) {
                        this.processStatusQueue(status.events);
                    }

                    // Update general status from the latest snapshot
                    this.state.isConnected = status.isConnected;
                    this.state.isRunning = status.backing_up;
                    this.updateAllUI();

                } catch (error) {
                    console.error('Error polling status:', error);
                    this.state.isConnected = false;
                    this.updateAllUI();
                } finally {
                    this.stateManagement.isPolling = false;
                }
            }

            processStatusQueue(events) {
                if (this.stateManagement.isProcessingQueue) {
                    this.stateManagement.eventQueue.push(...events);
                    return;
                }

                this.stateManagement.isProcessingQueue = true;
                this.stateManagement.eventQueue.push(...events);

                const processNextEvent = () => {
                    if (this.stateManagement.eventQueue.length === 0) {
                        this.stateManagement.isProcessingQueue = false;
                        return;
                    }

                    const event = this.stateManagement.eventQueue.shift();

                    this.state.phase = event.phase;
                    if (event.data && typeof event.data === 'object') {
                        if (event.data.progress >= 0) {
                            this.state.progress = event.data.progress;
                        }
                        this.state.log = { operation: event.phase, success: true, details: event.data.message };
                    } else {
                        this.state.log = { operation: event.phase, success: true, details: event.data };
                    }

                    this.updateAllUI();

                    setTimeout(processNextEvent, 400); // Slower timeout for better visual effect
                };

                processNextEvent();
            }

            processStatusQueue(events) {
                if (this.stateManagement.isProcessingQueue) {
                    this.stateManagement.eventQueue.push(...events);
                    return;
                }

                this.stateManagement.isProcessingQueue = true;
                this.stateManagement.eventQueue.push(...events);

                const processNextEvent = () => {
                    if (this.stateManagement.eventQueue.length === 0) {
                        this.stateManagement.isProcessingQueue = false;
                        return;
                    }

                    const event = this.stateManagement.eventQueue.shift();

                    this.state.phase = event.phase;
                    if (event.progress >= 0) {
                        this.state.progress = event.progress;
                    }
                    this.state.log = { operation: event.phase, success: true, details: event.details };

                    this.updateAllUI();

                    setTimeout(processNextEvent, 300);
                };

                processNextEvent();
            }

            // Lazy loading system for performance optimization
            initializeLazyLoading() {
                // Mark components for lazy initialization
                this.lazyComponents.set('debugConsole', {
                    initialized: false,
                    element: '#debugContent',
                    initFunction: () => this.initializeDebugConsole()
                });
                
                this.lazyComponents.set('advancedSettings', {
                    initialized: false,
                    element: '.advanced-settings',
                    initFunction: () => this.initializeAdvancedSettings()
                });

                // Set up intersection observer for components that become visible
                if ('IntersectionObserver' in window) {
                    this.setupLazyLoadObserver();
                }
                
                console.log('[LazyLoad] Lazy loading system initialized for', this.lazyComponents.size, 'components');
            }

            setupLazyLoadObserver() {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const componentId = entry.target.getAttribute('data-lazy-component');
                            if (componentId && this.lazyComponents.has(componentId)) {
                                this.loadLazyComponent(componentId);
                            }
                        }
                    });
                }, { threshold: 0.1 });

                // Observe elements marked for lazy loading
                this.elements.lazyComponents.forEach(el => {
                    observer.observe(el);
                });
            }

            loadLazyComponent(componentId) {
                const component = this.lazyComponents.get(componentId);
                if (component && !component.initialized) {
                    console.log('[LazyLoad] Loading component:', componentId);
                    try {
                        component.initFunction();
                        component.initialized = true;
                        console.log('[LazyLoad] Component loaded successfully:', componentId);
                    } catch (error) {
                        console.error('[LazyLoad] Failed to load component:', componentId, error);
                    }
                }
            }

            initializeDebugConsole() {
                // Initialize debug console only when needed
                const debugContent = this.elements.debugContent;
                if (debugContent && !debugContent.getAttribute('data-initialized')) {
                    debugContent.setAttribute('data-initialized', 'true');
                    // Additional heavy debug console initialization can go here
                    console.log('[LazyLoad] Debug console initialized');
                }
            }

            initializeAdvancedSettings() {
                // Initialize advanced settings panel only when accessed
                const advancedSettings = this.elements.advancedSettings;
                if (advancedSettings && !advancedSettings.getAttribute('data-initialized')) {
                    advancedSettings.setAttribute('data-initialized', 'true');
                    // Additional heavy settings initialization can go here  
                    console.log('[LazyLoad] Advanced settings initialized');
                }
            }

            // Adaptive polling system - adjusts frequency based on activity
            startAdaptivePolling() {
                const scheduleNextPoll = () => {
                    if (this.intervals && this.intervals.has) {
                        this.intervals.clear('statusPoll');
                        this.intervals.set('statusPoll', () => {
                            this.pollStatus().then(() => {
                                scheduleNextPoll(); // Schedule next poll with updated interval
                            }).catch(() => {
                                scheduleNextPoll(); // Continue even on error
                            });
                        }, this.stateManagement.adaptivePollInterval);
                    } else {
                        // Fallback using managed timeout to prevent leaks
                        this.intervals.setTimeout('statusPollFallback', () => {
                            this.pollStatus().then(() => {
                                scheduleNextPoll();
                            }).catch(() => {
                                scheduleNextPoll();
                            });
                        }, this.stateManagement.adaptivePollInterval);
                    }
                };
                
                // Start the adaptive polling
                scheduleNextPoll();
                // console.log('[Polling] Adaptive polling started with initial interval:', this.stateManagement.adaptivePollInterval + 'ms');
            }

            // Public UI Update Function (uses debouncing)
            updateAllUI() {
                this.stateManagement.updateUIDebounced();
            }

            _updateAllUI() {
                debugLog('Updating all UI elements...', 'UI');
                if (this.stateManagement.isUpdatingUI) {
                    debugLog('Skipping UI update: already updating', 'UI');
                    return;
                }
                this.stateManagement.isUpdatingUI = true;

                try {
                    // Update connection status
                    this.elements.connectionLed.classList.toggle('connected', this.state.isConnected);
                    this.elements.connectionLed.classList.toggle('connecting', this.state.phase === 'CONNECT');
                    this.elements.connectionText.textContent = this.state.isConnected ? 'ONLINE' : 'OFFLINE';

                    // Update primary action button
                    if (this.state.isConnected && !this.state.isRunning) {
                        this.updateButtonContent(this.elements.primaryActionButton, 'üöÄ', 'START BACKUP');
                        this.elements.primaryActionButton.classList.remove('primary');
                        this.elements.primaryActionButton.classList.add('success');
                        this.elements.primaryActionButton.disabled = false;
                    } else if (this.state.isRunning) {
                        this.updateButtonContent(this.elements.primaryActionButton, 'üîÑ', 'BACKING UP...');
                        this.elements.primaryActionButton.classList.remove('success');
                        this.elements.primaryActionButton.classList.add('primary');
                        this.elements.primaryActionButton.disabled = true;
                    } else {
                        this.updateButtonContent(this.elements.primaryActionButton, 'üöÄ', 'CONNECT');
                        this.elements.primaryActionButton.classList.remove('success');
                        this.elements.primaryActionButton.classList.add('primary');
                        this.elements.primaryActionButton.disabled = false;
                    }

                    // Update pause/stop buttons
                    this.elements.pauseButton.disabled = !this.state.isRunning;
                    this.elements.stopButton.disabled = !this.state.isRunning;
                    this.elements.pauseButton.textContent = this.state.isPaused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
                    this.elements.pauseButton.classList.toggle('primary', this.state.isPaused);
                    this.elements.pauseButton.classList.toggle('secondary', !this.state.isPaused);

                    // Update phase display
                    this.elements.currentPhaseDisplay.querySelector('span').textContent = this.state.phase.replace(/_/g, ' ');
                    this.elements.currentPhaseDisplay.querySelector('span').className = `neon-text ${this.getPhaseColor(this.state.phase)}`;

                    // Update progress ring
                    const radius = this.elements.progressCircle.r.baseVal.value;
                    const circumference = radius * 2 * Math.PI;
                    const offset = circumference - (this.state.progress / 100) * circumference;
                    this.elements.progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
                    this.elements.progressCircle.style.strokeDashoffset = offset;
                    this.elements.progressCircle.classList.toggle('active', this.state.isRunning);

                    this.elements.progressPercentage.textContent = `${Math.round(this.state.progress)}%`;
                    this.elements.progressStatus.textContent = this.state.log.operation || this.state.message;

                    // Update stats grid
                    this.elements.speedStat.textContent = this.formatBytesPerSecond(this.state.speed);
                    this.elements.etaStat.textContent = this.formatTime(this.state.eta);
                    this.elements.transferredStat.textContent = this.formatBytes(this.state.transferred);
                    this.elements.sizeStat.textContent = this.formatBytes(this.state.file_size);

                    // Update selected file display
                    if (this.state.selectedFile) {
                        // Create safe DOM elements instead of innerHTML to prevent XSS
                        const fileIcon = document.createElement('span');
                        fileIcon.className = 'file-icon neon-text blue';
                        fileIcon.textContent = 'üìÑ';
                        
                        const fileDetails = document.createElement('div');
                        fileDetails.className = 'file-details';
                        
                        const fileName = document.createElement('div');
                        fileName.className = 'file-name';
                        fileName.textContent = this.state.selectedFile.name;
                        
                        const fileSize = document.createElement('div');
                        fileSize.className = 'file-size';
                        fileSize.textContent = this.formatBytes(this.state.selectedFile.size);
                        
                        fileDetails.appendChild(fileName);
                        fileDetails.appendChild(fileSize);
                        
                        this.elements.selectedFileDisplay.textContent = '';
                        this.elements.selectedFileDisplay.appendChild(fileIcon);
                        this.elements.selectedFileDisplay.appendChild(fileDetails);
                        this.elements.selectedFileDisplay.classList.add('file-info');
                        this.elements.copyFileInfoButton.classList.remove('u-hidden');
                        this.elements.copyFileInfoButton.classList.add('u-inline-flex'); // Show copy button
                        this.elements.filePreview.textContent = ''; // Clear previous preview safely
                        this.elements.filePreview.style.display = 'flex';
                        this.renderFilePreview(this.state.selectedFile);
                    } else {
                        this.elements.selectedFileDisplay.textContent = 'No file selected';
                        this.elements.selectedFileDisplay.classList.remove('file-info');
                        this.elements.copyFileInfoButton.classList.add('u-hidden'); // Hide copy button
                        this.elements.filePreview.classList.add('u-hidden');
                    }

                    // Update client ID
                    this.elements.clientIdDisplay.textContent = this.state.clientId ? this.state.clientId.substring(0, 8) + '...' : 'Not connected';

                    // Update debug JSON viewers
                    if (this.elements.statusJsonViewer) {
                        this.elements.statusJsonViewer.textContent = JSON.stringify(this.state.lastApiStatus, null, 2);
                    }
                    if (this.elements.progressJsonViewer) {
                        this.elements.progressJsonViewer.textContent = JSON.stringify(this.state, null, 2);
                    }

                    // Update browser tab title with progress
                    this.updateTabTitle();

                } catch (error) {
                    console.error('Error updating UI:', error);
                    debugLog('Error updating UI: ' + error.message, 'ERROR');
                } finally {
                    this.stateManagement.isUpdatingUI = false;
                }
            }

            /**
             * Update browser tab title with progress information
             */
            updateTabTitle() {
                try {
                    const baseTitle = 'CyberBackup';
                    let titleParts = [baseTitle];

                    if (this.state.isRunning && this.state.progress !== undefined) {
                        // Show progress percentage when backup is running
                        const progressPercent = Math.round(this.state.progress);
                        titleParts.unshift(`${progressPercent}%`);
                        
                        // Add operation status
                        if (this.state.isPaused) {
                            titleParts.push('(Paused)');
                        } else if (this.state.phase === 'BACKING_UP') {
                            titleParts.push('(Backing up)');
                        } else if (this.state.phase === 'VERIFY') {
                            titleParts.push('(Verifying)');
                        }
                    } else if (this.state.isConnected) {
                        // Show connection status when connected but not running
                        titleParts.push('(Connected)');
                    } else if (this.state.phase === 'COMPLETED') {
                        // Show completion status
                        titleParts.unshift('‚úÖ Complete');
                    } else if (this.state.phase === 'FAILED' || this.state.phase === 'ERROR') {
                        // Show error status
                        titleParts.unshift('‚ùå Failed');
                    }

                    // Set the title
                    document.title = titleParts.join(' ');
                    
                } catch (error) {
                    console.error('Error updating tab title:', error);
                    debugLog('Error updating tab title: ' + error.message, 'ERROR');
                }
            }

            getPhaseColor(phase) {
                switch (phase) {
                    case 'SYSTEM_READY': return 'purple';
                    case 'CONNECT': return 'blue';
                    case 'CONNECTED': return 'green';
                    case 'START': return 'blue';
                    case 'BACKING_UP': return 'blue';
                    case 'VERIFY': return 'yellow';
                    case 'COMPLETED': return 'green';
                    case 'SUCCESS': return 'green';
                    case 'PAUSED': return 'yellow';
                    case 'STOPPED': return 'pink';
                    case 'FAILED': return 'red';
                    case 'ERROR': return 'red';
                    case 'CONNECTION_FAILED': return 'red';
                    case 'SERVER_OFFLINE': return 'red';
                    default: return 'purple';
                }
            }

            updateProgressData(progressData) {
                // Update progress information from API status
                if (progressData) {
                    if (progressData.progress !== undefined) {
                        this.state.progress = progressData.progress;
                    }
                    if (progressData.transferred !== undefined) {
                        this.state.transferred = progressData.transferred;
                    }
                    if (progressData.speed !== undefined) {
                        this.state.speed = progressData.speed;
                    }
                    if (progressData.eta !== undefined) {
                        this.state.eta = progressData.eta;
                    }
                }
            }

            updateButtonContent(button, icon, text) {
                // Safely update button content while preserving span structure
                if (!button) return;

                const iconSpan = button.querySelector('.btn-icon');
                const textSpan = button.querySelector('.btn-text');

                if (iconSpan && textSpan) {
                    iconSpan.textContent = icon;
                    textSpan.textContent = text;
                } else {
                    // Fallback: recreate the structure if spans are missing
                    button.innerHTML = `<span class="btn-icon">${icon}</span><span class="btn-text">${text}</span>`;
                }
            }

            async handlePrimaryAction() {
                console.log('[BUTTON_DEBUG] handlePrimaryAction called!');
                
                // Prevent multiple simultaneous actions
                if (this.buttonStateManager.isLoading(this.elements.primaryActionButton)) {
                    console.log('[BUTTON_DEBUG] Button is loading, skipping action');
                    return;
                }

                if (!this.state.isConnected) {
                    // Connect to server
                    const serverAddress = this.elements.serverInput.value;
                    const username = this.elements.usernameInput.value;
                    const [serverIP, serverPortStr] = serverAddress.split(':');
                    const serverPort = parseInt(serverPortStr);

                    if (!serverIP || isNaN(serverPort) || !username) {
                        this.buttonStateManager.setError(this.elements.primaryActionButton, '‚ùå Invalid Input');
                        this.showToast('Please enter valid server address and username.', 'error');
                        this.addLog('Connection failed', 'error', 'Invalid server address or username.');
                        return;
                    }

                    // Set loading state
                    this.buttonStateManager.setLoading(this.elements.primaryActionButton, 'üîÑ Connecting...');
                    
                    this.addLog(`Attempting to connect to ${serverIP}:${serverPort} as ${username}...`, 'info');
                    this.state.phase = 'CONNECT';
                    this.state.log = { operation: 'Connecting...', success: true, details: '' };
                    this.updateAllUI();

                    try {
                        // Include filepath in connect call if file is selected
                        const connectConfig = { host: serverIP, port: serverPort, username: username };
                        if (this.state.selectedFile) {
                            connectConfig.filepath = this.state.selectedFile.name;
                        }

                        const result = await this.apiClient.connect(connectConfig);
                        if (result.success) {
                            this.buttonStateManager.setSuccess(this.elements.primaryActionButton, '‚úÖ Connected!');
                            this.showToast('Connected to server successfully!', 'success');
                            this.addLog('Connected to server', 'success', `Server: ${serverIP}:${serverPort}`);
                            this.state.isConnected = true;
                            this.state.phase = 'CONNECTED';
                            this.state.log = { operation: 'Ready for backup', success: true, details: '' };
                            this.updateAllUI();
                        } else {
                            const errorInfo = this.errorMessageFormatter.formatError('connection', result.message);
                            this.buttonStateManager.setError(this.elements.primaryActionButton, '‚ùå Failed');
                            this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                            this.addLog('Connection failed', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                            this.state.isConnected = false;
                            this.state.phase = 'CONNECTION_FAILED';
                            this.state.log = { operation: 'Connection Failed', success: false, details: result.message };
                            this.updateAllUI();
                        }
                    } catch (error) {
                        const errorInfo = this.errorMessageFormatter.formatError('connection', error.message);
                        this.buttonStateManager.setError(this.elements.primaryActionButton, '‚ùå Error');
                        this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                        this.addLog('Connection Error', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                        this.state.isConnected = false;
                        this.state.phase = 'ERROR';
                        this.state.log = { operation: 'API Error', success: false, details: error.message };
                        this.updateAllUI();
                    }
                } else if (this.state.isConnected && !this.state.isRunning) {
                    // Start backup
                    if (!this.state.selectedFile) {
                        this.buttonStateManager.setError(this.elements.primaryActionButton, '‚ùå No File');
                        this.showToast('Please select a file to backup first.', 'warning');
                        this.addLog('Backup failed', 'warning', 'No file selected.');
                        return;
                    }

                    const confirm = await this.system.confirmModal.confirm(
                        'Confirm Backup',
                        `Are you sure you want to backup "${this.state.selectedFile.name}" to ${this.elements.serverInput.value}?`
                    );

                    if (confirm) {
                        // Set loading state
                        this.buttonStateManager.setLoading(this.elements.primaryActionButton, 'üöÄ Starting...');
                        
                        this.addLog(`Starting backup of ${this.state.selectedFile.name}...`, 'info');
                        this.state.isRunning = true;
                        this.state.phase = 'START';
                        this.state.log = { operation: 'Initiating backup', success: true, details: '' };
                        this.updateAllUI();

                        try {
                            const result = await this.apiClient.startBackup(
                                this.state.selectedFile,
                                { 
                                    username: this.elements.usernameInput.value,
                                    serverIP: this.elements.serverInput.value.split(':')[0],
                                    serverPort: parseInt(this.elements.serverInput.value.split(':')[1])
                                }
                            );
                            if (result.success) {
                                this.buttonStateManager.setSuccess(this.elements.primaryActionButton, '‚úÖ Started!');
                                this.showToast('Backup process started!', 'success');
                                this.addLog('Backup initiated', 'success', `File: ${result.filename}`);
                                // Status polling will update the rest
                            } else {
                                const errorInfo = this.errorMessageFormatter.formatError('backup', result.message);
                                this.buttonStateManager.setError(this.elements.primaryActionButton, '‚ùå Failed');
                                this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                                this.addLog('Backup failed', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                                this.state.isRunning = false;
                                this.state.phase = 'FAILED';
                                this.state.log = { operation: 'Backup Failed', success: false, details: result.message };
                                this.updateAllUI();
                            }
                        } catch (error) {
                            const errorInfo = this.errorMessageFormatter.formatError('backup', error.message);
                            this.buttonStateManager.setError(this.elements.primaryActionButton, '‚ùå Error');
                            this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                            this.addLog('Backup Error', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                            this.state.isRunning = false;
                            this.state.phase = 'ERROR';
                            this.state.log = { operation: 'API Error', success: false, details: error.message };
                            this.updateAllUI();
                        }
                    } else {
                        this.addLog('Backup cancelled by user', 'info');
                        this.showToast('Backup cancelled.', 'info');
                    }
                }
            }

            async togglePause() {
                // Prevent multiple simultaneous actions
                if (this.buttonStateManager.isLoading(this.elements.pauseButton)) {
                    return;
                }

                if (this.state.isRunning) {
                    if (this.state.isPaused) {
                        // Resume
                        this.buttonStateManager.setLoading(this.elements.pauseButton, '‚ñ∂Ô∏è Resuming...');
                        this.addLog('Resuming backup...', 'info');
                        this.state.phase = 'RESUME';
                        this.state.log = { operation: 'Resuming backup', success: true, details: '' };
                        this.updateAllUI();
                        try {
                            const result = await this.apiClient.resumeBackup();
                            if (result.success) {
                                this.buttonStateManager.setSuccess(this.elements.pauseButton, '‚úÖ Resumed!');
                                this.showToast('Backup resumed!', 'info');
                                this.addLog('Backup resumed', 'success');
                                this.state.isPaused = false;
                                this.state.phase = 'BACKING_UP';
                                this.state.log = { operation: 'Backing up...', success: true, details: '' };
                                this.updateAllUI();
                            } else {
                                const errorInfo = this.errorMessageFormatter.formatError('resume', result.message);
                                this.buttonStateManager.setError(this.elements.pauseButton, '‚ùå Failed');
                                this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                                this.addLog('Resume failed', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                            }
                        } catch (error) {
                            const errorInfo = this.errorMessageFormatter.formatError('resume', error.message);
                            this.buttonStateManager.setError(this.elements.pauseButton, '‚ùå Error');
                            this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                            this.addLog('Resume Error', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                        }
                    } else {
                        // Pause
                        this.buttonStateManager.setLoading(this.elements.pauseButton, '‚è∏Ô∏è Pausing...');
                        this.addLog('Pausing backup...', 'info');
                        this.state.phase = 'PAUSE';
                        this.state.log = { operation: 'Pausing backup', success: true, details: '' };
                        this.updateAllUI();
                        try {
                            const result = await this.apiClient.pauseBackup();
                            if (result.success) {
                                this.buttonStateManager.setSuccess(this.elements.pauseButton, '‚è∏Ô∏è Paused!');
                                this.showToast('Backup paused!', 'warning');
                                this.addLog('Backup paused', 'warning');
                                this.state.isPaused = true;
                                this.state.phase = 'PAUSED';
                                this.state.log = { operation: 'Backup paused', success: true, details: '' };
                                this.updateAllUI();
                            } else {
                                const errorInfo = this.errorMessageFormatter.formatError('pause', result.message);
                                this.buttonStateManager.setError(this.elements.pauseButton, '‚ùå Failed');
                                this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                                this.addLog('Pause failed', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                            }
                        } catch (error) {
                            const errorInfo = this.errorMessageFormatter.formatError('pause', error.message);
                            this.buttonStateManager.setError(this.elements.pauseButton, '‚ùå Error');
                            this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                            this.addLog('Pause Error', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                        }
                    }
                }
            }

            async stopBackup() {
                // Prevent multiple simultaneous actions
                if (this.buttonStateManager.isLoading(this.elements.stopButton)) {
                    return;
                }

                if (this.state.isRunning) {
                    const confirm = await this.system.confirmModal.confirm(
                        'Confirm Stop',
                        'Are you sure you want to stop the current backup operation?'
                    );

                    if (confirm) {
                        this.buttonStateManager.setLoading(this.elements.stopButton, 'üõë Stopping...');
                        this.addLog('Stopping backup...', 'info');
                        this.state.phase = 'STOP';
                        this.state.log = { operation: 'Stopping backup', success: true, details: '' };
                        this.updateAllUI();
                        try {
                            const result = await this.apiClient.stopBackup();
                            if (result.success) {
                                this.buttonStateManager.setSuccess(this.elements.stopButton, '‚úÖ Stopped!');
                                this.showToast('Backup stopped!', 'info');
                                this.addLog('Backup stopped', 'info');
                                this.state.isRunning = false;
                                this.state.isPaused = false;
                                this.state.progress = 0;
                                this.state.phase = 'STOPPED';
                                this.state.log = { operation: 'Backup stopped', success: true, details: '' };
                                this.updateAllUI();
                            } else {
                                const errorInfo = this.errorMessageFormatter.formatError('stop', result.message);
                                this.buttonStateManager.setError(this.elements.stopButton, '‚ùå Failed');
                                this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                                this.addLog('Stop failed', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                            }
                        } catch (error) {
                            const errorInfo = this.errorMessageFormatter.formatError('stop', error.message);
                            this.buttonStateManager.setError(this.elements.stopButton, '‚ùå Error');
                            this.showToast(`${errorInfo.userMessage}. ${errorInfo.suggestion}`, 'error');
                            this.addLog('Stop Error', 'error', `${errorInfo.userMessage} - ${errorInfo.technical}`);
                        }
                    } else {
                        this.addLog('Stop cancelled by user', 'info');
                        this.showToast('Stop cancelled.', 'info');
                    }
                } else {
                    this.buttonStateManager.setError(this.elements.stopButton, '‚ùå Not Running');
                    this.showToast('No backup is currently running.', 'info');
                }
            }

            handleFileSelection(file) {
                debugLog('File selected:' + file.name, 'FILE_MANAGER');
                
                // Validate the file before accepting it
                const validation = this.system.fileManager.validateFile(file);
                
                if (!validation.isValid) {
                    // File has errors - reject it
                    const errorInfo = this.errorMessageFormatter.formatFileValidationError(validation.errors);
                    this.addLog(`File rejected: ${file.name}`, 'error', `${errorInfo.message} - ${validation.errors.join('; ')}`);
                    this.showToast(`${errorInfo.message}. ${errorInfo.suggestion}`, 'error', 5000);
                    
                    // Show detailed error in a modal
                    this.system.modal.show(
                        'File Validation Failed',
                        `The selected file cannot be used for backup:\n\n${validation.errors.join('\n\n')}`,
                        () => {}
                    );
                    return;
                }
                
                // File is valid - show warnings if any
                if (validation.warnings.length > 0) {
                    validation.warnings.forEach(warning => {
                        this.addLog(`File warning: ${file.name}`, 'warning', warning);
                        this.showToast(warning, 'warning', 4000);
                    });
                }
                
                // Accept the file
                this.state.selectedFile = file;
                
                // Save file to memory for future quick access
                this.fileMemoryManager.saveFileSelection(file);
                
                this.updateAllUI();
                this.addLog(`File selected: ${file.name}`, 'success', 
                    `Size: ${this.formatBytes(file.size)}, Type: ${file.type || 'unknown'}`);
                
                // Show success with file details
                this.showToast(
                    `File selected: ${file.name} (${this.system.fileManager.formatFileSize(file.size)})`, 
                    'success', 
                    3000
                );
            }

            renderFilePreview(file) {
                const previewContainer = this.elements.filePreview;
                previewContainer.textContent = ''; // Clear safely

                // Create enhanced preview with metadata
                const previewWrapper = document.createElement('div');
                previewWrapper.className = 'enhanced-file-preview';
                previewWrapper.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: var(--space-sm);
                    padding: var(--space-md);
                    background: rgba(0, 0, 0, 0.2);
                    border-radius: var(--radius-md);
                    border: 1px solid var(--glass-border);
                `;

                const fileInfo = this.getFileTypeInfo(file);
                
                // File icon and type
                const iconElement = document.createElement('div');
                iconElement.className = 'file-preview-icon';
                iconElement.style.cssText = `
                    font-size: 2.5rem;
                    color: ${fileInfo.color};
                    text-shadow: 0 0 10px ${fileInfo.color}40;
                    margin-bottom: var(--space-xs);
                `;
                iconElement.textContent = fileInfo.icon;
                previewWrapper.appendChild(iconElement);

                // File type label
                const typeLabel = document.createElement('div');
                typeLabel.className = 'file-type-label';
                typeLabel.style.cssText = `
                    font-size: var(--font-size-sm);
                    color: var(--text-secondary);
                    font-weight: 500;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                `;
                typeLabel.textContent = fileInfo.typeLabel;
                previewWrapper.appendChild(typeLabel);

                // File metadata
                const metadata = document.createElement('div');
                metadata.className = 'file-metadata';
                metadata.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 2px;
                    font-size: var(--font-size-xs);
                    color: var(--text-muted);
                    text-align: center;
                `;
                
                // Batch metadata elements using DocumentFragment to reduce reflows
                const metadataFragment = document.createDocumentFragment();
                
                const sizeInfo = document.createElement('div');
                sizeInfo.textContent = `Size: ${this.formatBytes(file.size)}`;
                metadataFragment.appendChild(sizeInfo);
                
                const lastModified = document.createElement('div');
                lastModified.textContent = `Modified: ${new Date(file.lastModified).toLocaleDateString()}`;
                metadataFragment.appendChild(lastModified);
                
                metadata.appendChild(metadataFragment);
                
                previewWrapper.appendChild(metadata);

                // Content preview for specific file types
                if (file.type.startsWith('image/')) {
                    this.addImagePreview(previewWrapper, file);
                } else if (file.type.startsWith('text/') || file.name.endsWith('.json') || file.name.endsWith('.xml')) {
                    this.addTextPreview(previewWrapper, file);
                } else if (file.type === 'application/pdf') {
                    this.addPdfPreview(previewWrapper, file);
                }

                previewContainer.appendChild(previewWrapper);
            }

            /**
             * Get file type information with icon and color
             */
            getFileTypeInfo(file) {
                const ext = file.name.split('.').pop().toLowerCase();
                const type = file.type;

                const fileTypes = {
                    // Images
                    'image/': { icon: 'üñºÔ∏è', color: 'var(--neon-blue)', typeLabel: 'Image File' },
                    'jpg': { icon: 'üñºÔ∏è', color: 'var(--neon-blue)', typeLabel: 'JPEG Image' },
                    'png': { icon: 'üñºÔ∏è', color: 'var(--neon-blue)', typeLabel: 'PNG Image' },
                    'gif': { icon: 'üéûÔ∏è', color: 'var(--neon-purple)', typeLabel: 'GIF Animation' },
                    'svg': { icon: 'üé®', color: 'var(--neon-blue)', typeLabel: 'SVG Vector' },
                    
                    // Documents
                    'application/pdf': { icon: 'üìÑ', color: 'var(--error)', typeLabel: 'PDF Document' },
                    'txt': { icon: 'üìù', color: 'var(--text-primary)', typeLabel: 'Text File' },
                    'md': { icon: 'üìã', color: 'var(--neon-blue)', typeLabel: 'Markdown' },
                    'json': { icon: 'üîß', color: 'var(--warning)', typeLabel: 'JSON Data' },
                    'xml': { icon: 'üè∑Ô∏è', color: 'var(--neon-green)', typeLabel: 'XML Data' },
                    'csv': { icon: 'üìä', color: 'var(--success)', typeLabel: 'CSV Data' },
                    
                    // Code files
                    'js': { icon: '‚ö°', color: 'var(--warning)', typeLabel: 'JavaScript' },
                    'html': { icon: 'üåê', color: 'var(--neon-orange)', typeLabel: 'HTML' },
                    'css': { icon: 'üé®', color: 'var(--neon-blue)', typeLabel: 'CSS' },
                    'py': { icon: 'üêç', color: 'var(--neon-green)', typeLabel: 'Python' },
                    'cpp': { icon: '‚öôÔ∏è', color: 'var(--neon-blue)', typeLabel: 'C++' },
                    'c': { icon: '‚öôÔ∏è', color: 'var(--neon-blue)', typeLabel: 'C' },
                    
                    // Archives
                    'zip': { icon: 'üì¶', color: 'var(--neon-purple)', typeLabel: 'ZIP Archive' },
                    'rar': { icon: 'üì¶', color: 'var(--neon-purple)', typeLabel: 'RAR Archive' },
                    'tar': { icon: 'üì¶', color: 'var(--neon-purple)', typeLabel: 'TAR Archive' },
                    '7z': { icon: 'üì¶', color: 'var(--neon-purple)', typeLabel: '7-Zip Archive' },
                    
                    // Media
                    'mp3': { icon: 'üéµ', color: 'var(--neon-green)', typeLabel: 'MP3 Audio' },
                    'mp4': { icon: 'üé¨', color: 'var(--neon-red)', typeLabel: 'MP4 Video' },
                    'avi': { icon: 'üé¨', color: 'var(--neon-red)', typeLabel: 'AVI Video' },
                    'wav': { icon: 'üéµ', color: 'var(--neon-green)', typeLabel: 'WAV Audio' },
                    
                    // Default
                    'default': { icon: 'üìÑ', color: 'var(--text-secondary)', typeLabel: 'Unknown File' }
                };

                // Check by MIME type first
                for (const [key, value] of Object.entries(fileTypes)) {
                    if (type.startsWith(key)) {
                        return value;
                    }
                }

                // Check by extension
                return fileTypes[ext] || fileTypes.default;
            }

            /**
             * Add image preview
             */
            addImagePreview(container, file) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(file);
                img.style.cssText = `
                    max-width: 120px;
                    max-height: 80px;
                    border-radius: var(--radius-sm);
                    border: 1px solid var(--glass-border);
                    margin-top: var(--space-sm);
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                `;
                img.onerror = () => {
                    img.style.display = 'none';
                };
                container.appendChild(img);
            }

            /**
             * Add text file preview
             */
            addTextPreview(container, file) {
                if (file.size > 50000) return; // Skip large files
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const previewText = document.createElement('pre');
                    previewText.textContent = content.substring(0, 150) + (content.length > 150 ? '...' : '');
                    previewText.style.cssText = `
                        font-family: 'Share Tech Mono', monospace;
                        font-size: 0.7rem;
                        color: var(--text-dim);
                        background: var(--bg-black);
                        padding: var(--space-sm);
                        border-radius: var(--radius-sm);
                        border: 1px solid var(--glass-border);
                        margin-top: var(--space-sm);
                        max-width: 200px;
                        overflow: hidden;
                        white-space: pre-wrap;
                        line-height: 1.2;
                    `;
                    container.appendChild(previewText);
                };
                reader.readAsText(file);
            }

            /**
             * Add PDF preview placeholder
             */
            addPdfPreview(container, file) {
                const pdfInfo = document.createElement('div');
                pdfInfo.style.cssText = `
                    margin-top: var(--space-sm);
                    padding: var(--space-sm);
                    background: rgba(255, 0, 64, 0.1);
                    border-radius: var(--radius-sm);
                    border: 1px solid var(--error);
                    font-size: var(--font-size-xs);
                    color: var(--text-secondary);
                    text-align: center;
                `;
                pdfInfo.textContent = 'PDF preview requires external viewer';
                container.appendChild(pdfInfo);
            }

            addLog(message, type = 'info', details = '') {
                // Store log entry for potential batching
                this._pendingLogs = this._pendingLogs || [];
                this._pendingLogs.push({ message, type, details, timestamp: new Date() });
                
                // Debounce DOM updates but show critical logs immediately
                if (!this._logUpdateDebounced) {
                    this._logUpdateDebounced = this.debounce(() => this._flushPendingLogs(), 50);
                }
                
                // Show critical errors immediately
                if (type === 'error') {
                    this._flushPendingLogs();
                } else {
                    this._logUpdateDebounced();
                }
            }

            _flushPendingLogs() {
                if (!this._pendingLogs || this._pendingLogs.length === 0) return;

                // Process all pending logs
                const fragment = document.createDocumentFragment();
                
                this._pendingLogs.forEach(logData => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${logData.type}`;
                    logEntry.setAttribute('tabindex', '0');
                    
                    // Create safe DOM elements instead of innerHTML
                    const timestamp = document.createElement('span');
                    timestamp.className = 'log-timestamp';
                    timestamp.textContent = logData.timestamp.toLocaleTimeString();
                    
                    const icon = document.createElement('span');
                    icon.className = `log-icon ${logData.type}`;
                    icon.textContent = this.getLogIcon(logData.type);
                    
                    const content = document.createElement('div');
                    content.className = 'log-content';
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'log-message';
                    messageDiv.textContent = logData.message;
                    content.appendChild(messageDiv);
                    
                    if (logData.details) {
                        const detailsDiv = document.createElement('div');
                        detailsDiv.className = 'log-details';
                        detailsDiv.textContent = logData.details;
                        content.appendChild(detailsDiv);
                    }
                    
                    logEntry.appendChild(timestamp);
                    logEntry.appendChild(icon);
                    logEntry.appendChild(content);
                    
                    fragment.appendChild(logEntry);
                });
                
                // Add all entries at once to reduce reflows
                this.elements.logContainer.prepend(fragment);
                
                // Clear pending logs
                this._pendingLogs = [];

                // Debounce cleanup operations to avoid excessive DOM manipulation
                if (!this._logCleanupDebounced) {
                    this._logCleanupDebounced = this.debounce(() => this._cleanupLogEntries(), 1000);
                }
                this._logCleanupDebounced();
            }

            _cleanupLogEntries() {
                // Limit log entries - batch removal for better performance
                const logContainer = this.elements.logContainer;
                const childrenToRemove = logContainer.children.length - 200;
                if (childrenToRemove > 0) {
                    // Remove excess children in batch to reduce reflows
                    const elementsToRemove = Array.from(logContainer.children).slice(-childrenToRemove);
                    elementsToRemove.forEach(element => logContainer.removeChild(element));
                }

                if (this.autoScrollLog) {
                    this.elements.logContainer.scrollTop = 0; // Scroll to top for prepend
                }
            }

            getLogIcon(type) {
                switch (type) {
                    case 'success': return '‚úÖ';
                    case 'error': return '‚ùå';
                    case 'warning': return '‚ö†Ô∏è';
                    case 'info': return '‚ÑπÔ∏è';
                    default: return 'üí¨';
                }
            }

            clearLog() {
                this.elements.logContainer.innerHTML = '';
                this.addLog('Log cleared', 'info');
                this.showToast('Operation log cleared.', 'info');
            }

            exportLog() {
                const logEntries = Array.from(this.elements.logContainer.children).map(entryDiv => {
                    const timestamp = entryDiv.querySelector('.log-timestamp').textContent;
                    const message = entryDiv.querySelector('.log-message').textContent;
                    const details = entryDiv.querySelector('.log-details') ? entryDiv.querySelector('.log-details').textContent : '';
                    const type = entryDiv.classList.contains('success') ? 'SUCCESS' :
                                 entryDiv.classList.contains('error') ? 'ERROR' :
                                 entryDiv.classList.contains('warning') ? 'WARNING' : 'INFO';
                    return `[${timestamp}] [${type}] ${message} ${details}`.trim();
                }).reverse(); // Reverse to get chronological order

                const blob = new Blob([logEntries.join('\n')], { type: 'text/plain;charset=utf-8' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `cyberbackup_log_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                this.showToast('Log exported successfully.', 'success');
            }

            toggleAutoScroll() {
                this.autoScrollLog = !this.autoScrollLog;
                this.elements.autoScrollBtn.textContent = `üìú Auto-scroll: ${this.autoScrollLog ? 'ON' : 'OFF'}`;
                this.showToast(`Auto-scroll ${this.autoScrollLog ? 'enabled' : 'disabled'}.`, 'info');
            }

            toggleDebugConsole() {
                const debugPanel = this.elements.debugPanel;
                const debugContent = this.elements.debugContent;
                const isExpanded = this.elements.debugToggle.getAttribute('aria-expanded') === 'true';

                if (isExpanded) {
                    debugPanel.style.maxHeight = '0';
                    debugContent.classList.remove('show');
                    this.elements.debugToggle.setAttribute('aria-expanded', 'false');
                } else {
                    debugPanel.style.maxHeight = debugPanel.scrollHeight + 'px'; // Set to actual height
                    debugContent.classList.add('show');
                    this.elements.debugToggle.setAttribute('aria-expanded', 'true');
                    this.loadLazyComponent('debugConsole'); // Lazy load debug console content
                }
            }

            showToast(message, type = 'info', duration = 3000) {
                const toast = document.createElement('div');
                toast.className = `toast toast-enhanced ${type} fade-in`;
                toast.setAttribute('role', 'alert');
                toast.setAttribute('aria-live', 'polite');
                toast.setAttribute('tabindex', '-1');
                
                // Add type-specific icons
                const icons = {
                    success: '‚úÖ',
                    error: '‚ùå',
                    warning: '‚ö†Ô∏è',
                    info: '‚ÑπÔ∏è'
                };
                
                toast.innerHTML = `
                    <div class="toast-content">
                        <span class="toast-icon" aria-hidden="true">${icons[type] || icons.info}</span>
                        <span class="toast-message">${message}</span>
                        <button type="button" class="toast-close" aria-label="Close notification" tabindex="0">&times;</button>
                    </div>
                `;
                
                // Enhanced styling
                toast.style.cssText += `
                    position: relative;
                    margin-bottom: var(--space-xs);
                    border-radius: var(--radius-md);
                    overflow: hidden;
                `;
                
                this.elements.toastContainer.prepend(toast); // Add to top

                // Focus management for accessibility
                if (type === 'error') {
                    setTimeout(() => toast.focus(), 100);
                }

                const closeToast = () => {
                    toast.style.animation = 'slideOutRight 0.4s forwards';
                    toast.addEventListener('animationend', () => {
                        if (toast.parentNode) toast.remove();
                    });
                };

                toast.querySelector('.toast-close').addEventListener('click', closeToast);

                // Keyboard accessibility
                toast.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeToast();
                    }
                });

                // Use managed timeout to prevent memory leaks
                const toastId = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                this.intervals.setTimeout(toastId, () => {
                    if (toast.parentNode) {
                        closeToast();
                    }
                }, duration);
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
                return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
            }

            formatBytesPerSecond(bytesPerSecond) {
                if (bytesPerSecond === 0) return '0 B/s';
                const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s', 'TB/s'];
                const i = parseInt(Math.floor(Math.log(bytesPerSecond) / Math.log(1024)));
                return Math.round(bytesPerSecond / Math.pow(1024, i), 2) + ' ' + sizes[i];
            }

            formatTime(seconds) {
                if (seconds === '--:--') return seconds; // Handle initial state
                if (seconds < 0) return '--:--';
                const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
                const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
                const s = Math.floor(seconds % 60).toString().padStart(2, '0');
                return `${h}:${m}:${s}`;
            }

            debounce(func, delay) {
                let timeoutId;
                return function (...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => func.apply(this, args), delay);
                };
            }

            verifyDOMElements() {
                console.log('[DOM_VERIFICATION] Verifying critical DOM elements...');
                const criticalElements = [
                    'primaryActionButton',
                    'pauseButton', 
                    'stopButton',
                    'serverInput',
                    'usernameInput',
                    'fileDropZone',
                    'saveConfigBtn',
                    'confirmModal'
                ];
                
                const missingElements = [];
                
                for (const elementKey of criticalElements) {
                    const element = this.elements[elementKey];
                    if (!element) {
                        missingElements.push(elementKey);
                        console.error(`[DOM_VERIFICATION] Critical element missing: ${elementKey}`);
                    } else {
                        console.log(`[DOM_VERIFICATION] ‚úì Found: ${elementKey}`);
                    }
                }
                
                if (missingElements.length > 0) {
                    console.error('[DOM_VERIFICATION] CRITICAL: Missing DOM elements:', missingElements);
                    return false;
                }
                
                console.log('[DOM_VERIFICATION] All critical elements found successfully');
                return true;
            }

            saveConfig() {
                const config = {
                    serverAddress: this.elements.serverInput.value,
                    username: this.elements.usernameInput.value,
                };
                localStorage.setItem('cyberbackup_config', JSON.stringify(config));
                this.showToast('Configuration saved!', 'success');
                this.addLog('Configuration saved', 'info');
            }

            loadSavedConfig() {
                try {
                    const savedConfig = localStorage.getItem('cyberbackup_config');
                    if (savedConfig) {
                        const config = JSON.parse(savedConfig);
                        this.elements.serverInput.value = config.serverAddress || '127.0.0.1:1256';
                        this.elements.usernameInput.value = config.username || '';  // No default username - let user enter their own
                        this.addLog('Loaded saved configuration', 'info');
                    }
                } catch (error) {
                    console.warn('Failed to load saved config:', error);
                    this.addLog('Failed to load config', 'warning', error.message);
                }
            }

            /**
             * Copy client ID to clipboard
             */
            copyClientId() {
                const clientId = this.state.clientId;
                if (!clientId) {
                    this.showToast('No client ID available to copy', 'warning');
                    return;
                }
                
                this.copyManager.copyToClipboard(
                    clientId, 
                    this.elements.copyClientIdButton,
                    'Client ID copied to clipboard!'
                );
            }

            /**
             * Copy server address to clipboard
             */
            copyServerAddress() {
                const serverAddress = this.elements.serverInput.value;
                if (!serverAddress) {
                    this.showToast('No server address to copy', 'warning');
                    return;
                }
                
                this.copyManager.copyToClipboard(
                    serverAddress, 
                    this.elements.copyServerAddressButton,
                    'Server address copied to clipboard!'
                );
            }

            /**
             * Copy selected file information to clipboard
             */
            copyFileInfo() {
                if (!this.state.selectedFile) {
                    this.showToast('No file selected to copy', 'warning');
                    return;
                }
                
                const fileInfo = `File: ${this.state.selectedFile.name}\nSize: ${this.formatBytes(this.state.selectedFile.size)}\nType: ${this.state.selectedFile.type || 'Unknown'}`;
                
                this.copyManager.copyToClipboard(
                    fileInfo, 
                    null,
                    'File information copied to clipboard!'
                );
            }

            /**
             * Show recent files dropdown
             */
            showRecentFiles() {
                const container = this.elements.recentFilesBtn.parentElement;
                
                // Remove any existing dropdown
                const existingDropdown = container.querySelector('.recent-files-dropdown');
                if (existingDropdown) {
                    existingDropdown.remove();
                    return; // Toggle behavior
                }
                
                // Create and show recent files dropdown
                this.fileMemoryManager.createRecentFilesUI(container, (fileInfo) => {
                    // Create a simulated file object from stored info
                    const simulatedFile = {
                        name: fileInfo.name,
                        size: fileInfo.size,
                        type: fileInfo.type,
                        lastModified: fileInfo.lastModified
                    };
                    
                    // Update state and UI as if user selected this file
                    this.state.selectedFile = simulatedFile;
                    this.addLog(`Recent file selected: ${fileInfo.name}`, 'info', 
                        `Size: ${fileInfo.sizeFormatted}, Selected ${fileInfo.timeAgo}`);
                    
                    this.showToast(`Selected recent file: ${fileInfo.displayName}`, 'success', 2000);
                    this.updateAllUI();
                });
                
                // Update button text temporarily
                const originalText = this.elements.recentFilesBtn.textContent;
                this.elements.recentFilesBtn.textContent = '‚ú® Select from recent...';
                
                setTimeout(() => {
                    this.elements.recentFilesBtn.textContent = originalText;
                }, 3000);
            }

            /**
             * Record a backup to history when it completes or fails
             * @param {Object} status - Current backup status
             * @param {boolean} success - Whether the backup was successful
             */
            recordBackupToHistory(status, success) {
                try {
                    const backupInfo = {
                        status: success ? 'completed' : 'failed',
                        filename: this.state.file_name || status.file_name || 'unknown',
                        fileSize: this.state.file_size || status.file_size || 0,
                        server: this.elements.serverInput?.value || 'unknown',
                        username: this.elements.usernameInput?.value || 'unknown',
                        duration: status.duration || 0,
                        transferSpeed: this.state.speed || status.speed || 0,
                        phase: status.phase,
                        clientId: this.state.clientId,
                        error: success ? null : (status.error || status.log?.operation || 'Unknown error')
                    };

                    const backupId = this.backupHistoryManager.addBackup(backupInfo);
                    
                    if (success) {
                        this.addLog(`Backup recorded to history`, 'success', 
                            `File: ${backupInfo.filename}, Size: ${this.formatBytes(backupInfo.fileSize)}`);
                        this.showToast(`‚úÖ Backup completed and saved to history`, 'success', 4000);
                    } else {
                        this.addLog(`Failed backup recorded to history`, 'warning', 
                            `File: ${backupInfo.filename}, Error: ${backupInfo.error}`);
                        this.showToast(`‚ùå Backup failed - recorded to history`, 'error', 4000);
                    }
                    
                    debugLog(`Backup ${success ? 'completed' : 'failed'} - recorded to history with ID: ${backupId}`, 'BACKUP_HISTORY');
                } catch (error) {
                    console.warn('Failed to record backup to history:', error);
                    debugLog('Failed to record backup to history: ' + error.message, 'ERROR');
                }
            }

            /**
             * Format bytes for display
             */
            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // Enhanced cleanup method to prevent memory leaks
            cleanup() {
                debugLog('Performing app cleanup...', 'APP_CLEANUP');
                
                try {
                    // Clear all intervals and timeouts
                    if (this.intervals) {
                        this.intervals.clearAll();
                    }

                    // Clear state management intervals
                    if (this.stateManagement && this.stateManagement.updateUIDebounced) {
                        // Clear any pending debounced updates
                        clearTimeout(this.stateManagement.updateUIDebounced);
                    }

                    // Cleanup file manager (remove any created elements)
                    if (this.system && this.system.fileManager) {
                        // Remove any temporary file inputs created by FileManager
                        const tempFileInputs = document.querySelectorAll('input[type="file"]');
                        tempFileInputs.forEach(input => {
                            if (input.style.display === 'none' && !input.id) {
                                input.remove();
                            }
                        });
                    }

                    // Cleanup modals and overlays
                    if (this.system && this.system.modal) {
                        this.system.modal.hide();
                    }
                    if (this.system && this.system.confirmModal) {
                        this.system.confirmModal.hide();
                    }

                    // Clear any pending toast notifications
                    if (this.elements && this.elements.toastContainer) {
                        this.elements.toastContainer.textContent = ''; // Clear safely
                    }

                    // Clear large log entries to free memory
                    if (this.elements && this.elements.logContainer) {
                        const logContainer = this.elements.logContainer;
                        const childrenToRemove = logContainer.children.length - 10;
                        if (childrenToRemove > 0) {
                            // Batch remove for better performance
                            const elementsToRemove = Array.from(logContainer.children).slice(-childrenToRemove);
                            elementsToRemove.forEach(element => logContainer.removeChild(element));
                        }
                    }

                    // Cleanup particle system
                    if (this.particleSystem) {
                        this.particleSystem.destroy();
                    }
                

                    // Cleanup error boundary
                    if (this.errorBoundary) {
                        this.errorBoundary.reset();
                    }

                    // Revoke any object URLs that might have been created for file previews
                    document.querySelectorAll('img[src^="blob:"]').forEach(img => {
                        URL.revokeObjectURL(img.src);
                    });

                    debugLog('App cleanup completed successfully', 'APP_CLEANUP');
                } catch (error) {
                    console.error('[App] Cleanup error:', error);
                    debugLog('App cleanup failed: ' + error.message, 'APP_CLEANUP');
                }
            }

            // Add page unload handler for cleanup
            setupPageUnloadHandler() {
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });

                // Also cleanup on page visibility change (when tab becomes hidden)
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        // Pause expensive operations when tab is hidden
                        if (this.particleSystem) {
                            this.particleSystem.toggle();
                        }
                        // Reduce polling frequency
                        if (this.stateManagement) {
                            this.stateManagement.adaptivePollInterval = Math.min(
                                this.stateManagement.maxPollInterval,
                                this.stateManagement.adaptivePollInterval * 2
                            );
                        }
                    } else {
                        // Resume normal operations when tab becomes visible
                        if (this.particleSystem && !this.particleSystem.isEnabled) {
                            this.particleSystem.toggle();
                        }
                        // Reset polling frequency
                        if (this.stateManagement) {
                            this.stateManagement.adaptivePollInterval = this.stateManagement.minPollInterval;
                        }
                    }
                });
            }
        }
        debugLog('App class defined successfully');


        /**
         * NEW: ParticleSystem
         * Creates floating particles for the cyberpunk aesthetic
         */
        debugLog('Defining ParticleSystem class...');
        class ParticleSystem {
            constructor(app) {
                this.container = app.elements.particleContainer;
                this.particles = [];
                this.maxParticles = 50;
                this.colors = ['#00FFFF', '#FF00FF', '#00FF00', '#FFFF00', '#FF0040'];
                this.isEnabled = true;
                this.animationId = null;
                
                // Performance optimization - reduce particles on smaller screens
                if (window.innerWidth < 768) {
                    this.maxParticles = 25;
                } else if (window.innerWidth < 1200) {
                    this.maxParticles = 35;
                }
            }

            init() {
                if (!this.container || !this.isEnabled) return;
                
                this.createInitialParticles();
                this.startAnimation();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
                
                console.log('[ParticleSystem] Initialized with', this.maxParticles, 'max particles');
            }

            createInitialParticles() {
                for (let i = 0; i < this.maxParticles * 0.3; i++) {
                    this.createParticle();
                }
            }

            createParticle() {
                if (this.particles.length >= this.maxParticles) return null;

                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                const size = Math.random() * 3 + 1;
                const startX = Math.random() * window.innerWidth;
                const speed = Math.random() * 2 + 0.5;
                const drift = (Math.random() - 0.5) * 2;
                
                particle.style.cssText = `
                    left: ${startX}px;
                    top: ${window.innerHeight + 10}px;
                    background: ${color};
                    width: ${size}px;
                    height: ${size}px;
                    box-shadow: 0 0 ${size * 3}px ${color};
                `;

                const particleData = {
                    element: particle,
                    x: startX,
                    y: window.innerHeight + 10,
                    speed: speed,
                    drift: drift,
                    opacity: Math.random() * 0.5 + 0.5,
                    fadeSpeed: Math.random() * 0.02 + 0.01
                };

                this.particles.push(particleData);
                this.container.appendChild(particle);
                
                return particleData;
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.y -= particle.speed;
                    particle.x += particle.drift;
                    
                    // Update opacity for twinkling effect
                    particle.opacity += (Math.random() - 0.5) * particle.fadeSpeed;
                    particle.opacity = Math.max(0.1, Math.min(1, particle.opacity));
                    
                    // Apply changes
                    particle.element.style.transform = `translate(${particle.x}px, ${particle.y}px)`;
                    particle.element.style.opacity = particle.opacity;
                    
                    // Remove particles that are off-screen
                    if (particle.y < -10 || particle.x < -10 || particle.x > window.innerWidth + 10) {
                        particle.element.remove();
                        this.particles.splice(i, 1);
                    }
                }
                
                // Randomly create new particles
                if (Math.random() < 0.3 && this.particles.length < this.maxParticles) {
                    this.createParticle();
                }
            }

            startAnimation() {
                const animate = () => {
                    if (this.isEnabled) {
                        this.updateParticles();
                        this.animationId = requestAnimationFrame(animate);
                    }
                };
                animate();
            }

            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            toggle() {
                this.isEnabled = !this.isEnabled;
                if (this.isEnabled) {
                    this.startAnimation();
                } else {
                    this.stopAnimation();
                }
            }

            destroy() {
                this.stopAnimation();
                this.particles.forEach(particle => particle.element.remove());
                this.particles = [];
            }

            handleResize() {
                // Adjust particle count based on screen size
                const oldMax = this.maxParticles;
                if (window.innerWidth < 768) {
                    this.maxParticles = 25;
                } else if (window.innerWidth < 1200) {
                    this.maxParticles = 35;
                } else {
                    this.maxParticles = 50;
                }
                
                // Remove excess particles if screen got smaller
                if (this.maxParticles < oldMax) {
                    // Batch remove excess particles for better performance
                    const particlesToRemove = this.particles.length - this.maxParticles;
                    if (particlesToRemove > 0) {
                        const removedParticles = this.particles.splice(-particlesToRemove);
                        removedParticles.forEach(particle => particle.element.remove());
                    }
                }
            }
        }
        debugLog('ParticleSystem class defined successfully');

        /**
         * NEW: ErrorBoundary
         * Global error handling and recovery system
         */
        debugLog('Setting up ErrorBoundary...');
        class ErrorBoundary {
            constructor(app) {
                this.app = app;
                this.errorCount = 0;
                this.lastErrors = [];
                this.maxErrors = 10;
                
                // Error loop prevention safeguards
                this.isProcessingError = false;
                this.errorTimestamps = [];
                this.maxErrorsPerWindow = 10;
                this.errorTimeWindow = 5000; // 5 seconds
                this.circuitBreakerOpen = false;
                this.circuitBreakerResetTime = 30000; // 30 seconds
                
                this.setupGlobalHandlers();
            }

            setupGlobalHandlers() {
                // Handle uncaught JavaScript errors
                window.addEventListener('error', (event) => {
                    this.handleError('JavaScript Error', event.error, {
                        filename: event.filename,
                        lineno: event.lineno,
                        colno: event.colno
                    });
                });

                // Handle unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    this.handleError('Unhandled Promise Rejection', event.reason, {
                        promise: event.promise
                    });
                    event.preventDefault(); // Prevent default browser behavior
                });

                // Handle API errors specifically
                this.setupApiErrorHandling();
            }

            setupApiErrorHandling() {
                // Wrap existing API calls with error boundaries
                if (this.app && this.app.apiClient) {
                    const originalMethods = ['getStatus', 'connect', 'startBackup', 'stopBackup', 'pauseBackup', 'resumeBackup'];
                    
                    originalMethods.forEach(methodName => {
                        const original = this.app.apiClient[methodName];
                        if (original) {
                            this.app.apiClient[methodName] = async (...args) => {
                                try {
                                    return await original.apply(this.app.apiClient, args);
                                } catch (error) {
                                    this.handleError(`API Error: ${methodName}`, error, { method: methodName, args });
                                    throw error; // Re-throw for upstream handling
                                }
                            };
                        }
                    });
                }
            }

            handleError(type, error, context = {}) {
                // SAFEGUARD 1: Prevent recursive error processing
                if (this.isProcessingError) {
                    console.warn('[ErrorBoundary] Recursive error detected, ignoring:', type);
                    return;
                }
                
                // SAFEGUARD 2: Circuit breaker - stop processing if too many errors
                if (this.circuitBreakerOpen) {
                    const now = Date.now();
                    if (now - this.circuitBreakerOpenTime < this.circuitBreakerResetTime) {
                        console.warn('[ErrorBoundary] Circuit breaker open, ignoring error:', type);
                        return;
                    } else {
                        // Reset circuit breaker
                        this.circuitBreakerOpen = false;
                        console.info('[ErrorBoundary] Circuit breaker reset');
                    }
                }
                
                // SAFEGUARD 3: Rate limiting - prevent error spam
                const now = Date.now();
                this.errorTimestamps = this.errorTimestamps.filter(timestamp => 
                    now - timestamp < this.errorTimeWindow
                );
                
                if (this.errorTimestamps.length >= this.maxErrorsPerWindow) {
                    console.warn('[ErrorBoundary] Too many errors, opening circuit breaker');
                    this.circuitBreakerOpen = true;
                    this.circuitBreakerOpenTime = now;
                    return;
                }
                
                this.errorTimestamps.push(now);
                this.isProcessingError = true;
                
                try {
                    this.errorCount++;
                    const errorInfo = {
                        type,
                        message: error?.message || String(error),
                        stack: error?.stack,
                        context,
                        timestamp: new Date().toISOString(),
                        userAgent: navigator.userAgent,
                        url: window.location.href
                    };

                    // Store error for debugging
                    this.lastErrors.push(errorInfo);
                    if (this.lastErrors.length > this.maxErrors) {
                        this.lastErrors.shift();
                    }

                    // Log to console and debug system
                    console.error(`[ErrorBoundary] ${type}:`, error, context);
                    debugLogger.log('ERROR', 'ERROR_BOUNDARY', `${type}: ${errorInfo.message}`);

                    // Update UI with error information - wrapped in additional safety
                    try {
                        this.updateErrorUI(errorInfo);
                    } catch (uiError) {
                        console.error('[ErrorBoundary] Failed to update UI during error handling:', uiError);
                    }

                    // Attempt recovery if possible
                    this.attemptRecovery(type, error);

                    // Show user-friendly notification
                    this.showErrorNotification(errorInfo);
                    
                } catch (processingError) {
                    // If error processing itself fails, log to console only
                    console.error('[ErrorBoundary] Error processing failed:', processingError);
                } finally {
                    // Always reset the processing flag
                    this.isProcessingError = false;
                }
            }

            updateErrorUI(errorInfo) {
                try {
                    if (this.app) {
                        // Add to operation log
                        this.app.addLog(`Error: ${errorInfo.type}`, 'error', errorInfo.message);
                        
                        // Update connection status if it's an API error
                        if (errorInfo.type.includes('API')) {
                            this.app.state.isConnected = false;
                            this.app.state.phase = 'ERROR';
                            this.app.updateAllUI();
                        }
                    }
                } catch (uiError) {
                    console.error('[ErrorBoundary] Failed to update UI:', uiError);
                }
            }

            attemptRecovery(type, error) {
                try {
                    // Attempt different recovery strategies based on error type
                    if (type.includes('API') && this.app) {
                        // For API errors, reset connection state and try to recover
                        this.app.state.isRunning = false;
                        this.app.state.isPaused = false;
                        
                        // Clear any running intervals that might be causing issues
                        if (this.app.intervals) {
                            this.app.intervals.clearAll();
                            // Restart adaptive polling
                            setTimeout(() => {
                                if (this.app.startAdaptivePolling) {
                                    this.app.startAdaptivePolling();
                                }
                            }, 2000);
                        }
                    }

                    // Memory cleanup
                    if (type.includes('Memory') || type.includes('OutOfMemory')) {
                        this.performMemoryCleanup();
                    }

                } catch (recoveryError) {
                    console.error('[ErrorBoundary] Recovery attempt failed:', recoveryError);
                }
            }

            performMemoryCleanup() {
                try {
                    // Clear any large data structures
                    if (this.app) {
                        // Limit log entries
                        const logContainer = this.app.elements?.logContainer;
                        if (logContainer && logContainer.children.length > 50) {
                            // Batch remove for better performance  
                            const childrenToRemove = logContainer.children.length - 25;
                            const elementsToRemove = Array.from(logContainer.children).slice(-childrenToRemove);
                            elementsToRemove.forEach(element => logContainer.removeChild(element));
                        }

                        // Clear debug logger entries
                        if (debugLogger && debugLogger.clearEntries) {
                            debugLogger.clearEntries();
                        }
                    }

                    // Force garbage collection if available
                    if (window.gc) {
                        window.gc();
                    }
                } catch (cleanupError) {
                    console.error('[ErrorBoundary] Memory cleanup failed:', cleanupError);
                }
            }

            showErrorNotification(errorInfo) {
                try {
                    let message = 'An unexpected error occurred';
                    
                    // Provide more specific messages for common errors
                    if (errorInfo.type.includes('API')) {
                        message = 'Connection error. Please check your network and try again.';
                    } else if (errorInfo.message.includes('fetch')) {
                        message = 'Network request failed. Please check your connection.';
                    } else if (errorInfo.message.includes('timeout')) {
                        message = 'Operation timed out. Please try again.';
                    }

                    if (this.app && this.app.showToast) {
                        this.app.showToast(message, 'error', 5000);
                    }
                } catch (notificationError) {
                    console.error('[ErrorBoundary] Failed to show notification:', notificationError);
                }
            }

            getErrorStats() {
                return {
                    totalErrors: this.errorCount,
                    recentErrors: this.lastErrors.slice(-5),
                    errorTypes: this.lastErrors.reduce((acc, error) => {
                        acc[error.type] = (acc[error.type] || 0) + 1;
                        return acc;
                    }, {})
                };
            }

            reset() {
                this.errorCount = 0;
                this.lastErrors = [];
            }
        }
        debugLog('ErrorBoundary defined successfully');

        /**
         * NEW: ButtonStateManager
         * Manages loading states and visual feedback for buttons
         */
        debugLog('Defining ButtonStateManager class...');
        class ButtonStateManager {
            constructor() {
                this.activeButtons = new Map();
                this.originalStates = new Map();
            }

            setLoading(button, loadingText = null) {
                if (!button) return;
                
                const buttonId = button.id || button.textContent.trim();
                
                // Store original state
                if (!this.originalStates.has(buttonId)) {
                    const iconSpan = button.querySelector('.btn-icon');
                    const textSpan = button.querySelector('.btn-text');
                    this.originalStates.set(buttonId, {
                        icon: iconSpan ? iconSpan.textContent : '',
                        text: textSpan ? textSpan.textContent : button.textContent,
                        disabled: button.disabled,
                        classList: Array.from(button.classList)
                    });
                }

                // Apply loading state
                button.classList.add('loading');
                button.disabled = true;

                if (loadingText) {
                    this.updateButtonText(button, loadingText);
                }

                this.activeButtons.set(buttonId, button);
                debugLog(`Button ${buttonId} set to loading state`, 'BUTTON_STATE');
            }

            setSuccess(button, successText = null, duration = 2000) {
                if (!button) return;
                
                const buttonId = button.id || this.originalStates.get(button.id)?.text || 'unknown';
                
                // Remove loading state
                button.classList.remove('loading');
                button.classList.add('success-flash');
                
                if (successText) {
                    this.updateButtonText(button, successText);
                }

                // Add status indicator
                this.addStatusIndicator(button, 'success');

                // Reset after duration
                setTimeout(() => {
                    this.reset(button);
                }, duration);

                debugLog(`Button ${buttonId} set to success state`, 'BUTTON_STATE');
            }

            setError(button, errorText = null, duration = 3000) {
                if (!button) return;
                
                const buttonId = button.id || this.originalStates.get(button.id)?.text || 'unknown';
                
                // Remove loading state
                button.classList.remove('loading');
                button.classList.add('error-shake');
                
                if (errorText) {
                    this.updateButtonText(button, errorText);
                }

                // Add status indicator
                this.addStatusIndicator(button, 'error');

                // Reset after duration
                setTimeout(() => {
                    this.reset(button);
                    button.classList.remove('error-shake');
                }, duration);

                debugLog(`Button ${buttonId} set to error state`, 'BUTTON_STATE');
            }

            reset(button) {
                if (!button) return;
                
                const buttonId = button.id || button.textContent.trim();
                const originalState = this.originalStates.get(buttonId);
                
                if (originalState) {
                    // Restore original state
                    const iconSpan = button.querySelector('.btn-icon');
                    const textSpan = button.querySelector('.btn-text');

                    if (iconSpan && textSpan) {
                        iconSpan.textContent = originalState.icon;
                        textSpan.textContent = originalState.text;
                    } else {
                        // Fallback: recreate structure or use plain text
                        if (originalState.icon) {
                            button.innerHTML = `<span class="btn-icon">${originalState.icon}</span><span class="btn-text">${originalState.text}</span>`;
                        } else {
                            button.textContent = originalState.text;
                        }
                    }

                    button.disabled = originalState.disabled;
                    button.className = originalState.classList.join(' ');

                    // Remove any status indicators
                    this.removeStatusIndicator(button);

                    this.originalStates.delete(buttonId);
                }
                
                this.activeButtons.delete(buttonId);
                debugLog(`Button ${buttonId} reset to original state`, 'BUTTON_STATE');
            }

            updateButtonText(button, text) {
                // Safely update button text while preserving span structure
                const textSpan = button.querySelector('.btn-text');
                if (textSpan) {
                    textSpan.textContent = text;
                } else {
                    // Fallback for buttons without span structure
                    button.textContent = text;
                }
            }

            addStatusIndicator(button, type) {
                this.removeStatusIndicator(button); // Remove existing indicator
                
                const indicator = document.createElement('div');
                indicator.className = `status-indicator ${type}`;
                indicator.setAttribute('data-button-status', 'true');
                
                button.classList.add('has-status');
                button.appendChild(indicator);
            }

            removeStatusIndicator(button) {
                const existing = button.querySelector('[data-button-status]');
                if (existing) {
                    existing.remove();
                }
                button.classList.remove('has-status');
            }

            isLoading(button) {
                return button && button.classList.contains('loading');
            }

            // Batch operations
            setMultipleLoading(buttons, loadingText = null) {
                buttons.forEach(button => this.setLoading(button, loadingText));
            }

            resetMultiple(buttons) {
                buttons.forEach(button => this.reset(button));
            }

            // Clean up all states
            resetAll() {
                this.activeButtons.forEach(button => this.reset(button));
                this.activeButtons.clear();
                this.originalStates.clear();
                debugLog('All button states reset', 'BUTTON_STATE');
            }

            // Get stats for debugging
            getStats() {
                return {
                    activeButtons: this.activeButtons.size,
                    storedStates: this.originalStates.size,
                    buttonIds: Array.from(this.activeButtons.keys())
                };
            }
        }
        debugLog('ButtonStateManager class defined successfully');

        /**
         * NEW: ErrorMessageFormatter
         * Provides user-friendly error messages with actionable suggestions
         */
        debugLog('Defining ErrorMessageFormatter class...');
        class ErrorMessageFormatter {
            constructor() {
                this.commonErrorPatterns = {
                    connection: {
                        patterns: ['ECONNREFUSED', 'ENOTFOUND', 'ETIMEDOUT', 'connection refused', 'network error'],
                        userMessage: 'Unable to connect to the backup server',
                        suggestion: 'Check server address, port, and network connection. Ensure the backup server is running.'
                    },
                    authentication: {
                        patterns: ['authentication failed', 'invalid credentials', 'unauthorized', 'login failed'],
                        userMessage: 'Authentication failed',
                        suggestion: 'Verify your username and ensure your client keys are properly configured.'
                    },
                    fileAccess: {
                        patterns: ['ENOENT', 'EACCES', 'permission denied', 'file not found', 'access denied'],
                        userMessage: 'File access problem',
                        suggestion: 'Check file permissions and ensure the file exists and is accessible.'
                    },
                    serverError: {
                        patterns: ['server error', '500', 'internal server error'],
                        userMessage: 'Server encountered an error',
                        suggestion: 'The backup server experienced an issue. Try again in a few moments.'
                    },
                    timeout: {
                        patterns: ['timeout', 'request timed out', 'operation timed out'],
                        userMessage: 'Operation timed out',
                        suggestion: 'The operation took too long. Check network speed and server load, then try again.'
                    },
                    encryption: {
                        patterns: ['encryption failed', 'decryption failed', 'key error', 'crypto error'],
                        userMessage: 'Encryption/decryption error',
                        suggestion: 'Verify RSA keys are properly configured and compatible with the server.'
                    },
                    diskSpace: {
                        patterns: ['no space', 'disk full', 'insufficient space', 'ENOSPC'],
                        userMessage: 'Insufficient storage space',
                        suggestion: 'Free up disk space on the server or select a smaller file to backup.'
                    },
                    fileSize: {
                        patterns: ['file too large', 'size limit', 'maximum size exceeded'],
                        userMessage: 'File is too large',
                        suggestion: 'Select a smaller file or check server file size limits.'
                    }
                };

                this.operationSpecificMessages = {
                    connection: {
                        success: 'Successfully connected to backup server',
                        failure: 'Failed to establish connection'
                    },
                    backup: {
                        success: 'Backup completed successfully',
                        failure: 'Backup operation failed'
                    },
                    pause: {
                        success: 'Backup paused successfully',
                        failure: 'Failed to pause backup'
                    },
                    resume: {
                        success: 'Backup resumed successfully',
                        failure: 'Failed to resume backup'
                    },
                    stop: {
                        success: 'Backup stopped successfully',
                        failure: 'Failed to stop backup'
                    }
                };
            }

            /**
             * Format an error message to be more user-friendly
             * @param {string} operation - The operation that failed (e.g., 'connection', 'backup')
             * @param {string} rawError - The raw error message from the system
             * @param {Object} context - Additional context (optional)
             * @returns {Object} Formatted error with userMessage and suggestion
             */
            formatError(operation, rawError, context = {}) {
                const lowerError = rawError.toLowerCase();
                
                // Find matching error pattern
                for (const [category, config] of Object.entries(this.commonErrorPatterns)) {
                    if (config.patterns.some(pattern => lowerError.includes(pattern))) {
                        return {
                            userMessage: this.getOperationMessage(operation, 'failure') || config.userMessage,
                            suggestion: config.suggestion,
                            category: category,
                            technical: rawError
                        };
                    }
                }

                // If no pattern matches, provide a generic but helpful message
                return {
                    userMessage: this.getOperationMessage(operation, 'failure') || 'An unexpected error occurred',
                    suggestion: this.getGenericSuggestion(operation),
                    category: 'unknown',
                    technical: rawError
                };
            }

            /**
             * Get operation-specific message
             */
            getOperationMessage(operation, type) {
                return this.operationSpecificMessages[operation]?.[type];
            }

            /**
             * Get generic suggestion based on operation
             */
            getGenericSuggestion(operation) {
                const suggestions = {
                    connection: 'Verify server address and port, then try again.',
                    backup: 'Check file selection and server connection, then retry.',
                    pause: 'Ensure backup is running before attempting to pause.',
                    resume: 'Ensure backup is paused before attempting to resume.',
                    stop: 'Ensure backup is running before attempting to stop.',
                    default: 'Check your connection and settings, then try again.'
                };
                return suggestions[operation] || suggestions.default;
            }

            /**
             * Format a success message
             */
            formatSuccess(operation, details = '') {
                const message = this.getOperationMessage(operation, 'success') || 'Operation completed successfully';
                return {
                    userMessage: message,
                    details: details
                };
            }

            /**
             * Get user-friendly file validation error
             */
            formatFileValidationError(errors) {
                const errorMap = {
                    'File size exceeds maximum limit': {
                        message: 'File is too large for backup',
                        suggestion: 'Select a smaller file or compress it before backup.'
                    },
                    'Invalid file type': {
                        message: 'File type not supported',
                        suggestion: 'Select a different file type or check server configuration.'
                    },
                    'File is empty': {
                        message: 'Cannot backup empty file',
                        suggestion: 'Select a file with content to backup.'
                    },
                    'Special characters in filename': {
                        message: 'Filename contains unsupported characters',
                        suggestion: 'Rename the file to remove special characters, then try again.'
                    }
                };

                const firstError = errors[0];
                const errorInfo = Object.entries(errorMap).find(([key]) => 
                    firstError.includes(key)
                );

                if (errorInfo) {
                    return errorInfo[1];
                } else {
                    return {
                        message: 'File validation failed',
                        suggestion: 'Check file properties and try selecting a different file.'
                    };
                }
            }
        }
        debugLog('ErrorMessageFormatter class defined successfully');

        /**
         * NEW: CopyManager
         * Handles copy-to-clipboard functionality with visual feedback
         */
        debugLog('Defining CopyManager class...');
        class CopyManager {
            constructor() {
                this.copyTimeout = null;
            }

            /**
             * Copy text to clipboard with visual feedback
             * @param {string} text - Text to copy
             * @param {HTMLElement} button - Button element for visual feedback
             * @param {string} successMessage - Toast message on success
             */
            async copyToClipboard(text, button = null, successMessage = 'Copied to clipboard!') {
                try {
                    // Use modern clipboard API if available
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(text);
                    } else {
                        // Fallback for older browsers or non-secure contexts
                        this.fallbackCopyToClipboard(text);
                    }

                    // Visual feedback on button
                    if (button) {
                        this.showCopyFeedback(button);
                    }

                    // Show success toast
                    if (window.app && window.app.showToast) {
                        window.app.showToast(successMessage, 'success', 2000);
                    }

                    return true;
                } catch (error) {
                    console.error('Copy failed:', error);
                    
                    // Show error toast
                    if (window.app && window.app.showToast) {
                        window.app.showToast('Failed to copy to clipboard', 'error', 3000);
                    }
                    
                    return false;
                }
            }

            /**
             * Fallback copy method for older browsers
             */
            fallbackCopyToClipboard(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                } finally {
                    document.body.removeChild(textArea);
                }
            }

            /**
             * Show visual feedback on copy button
             */
            showCopyFeedback(button) {
                if (!button) return;

                // Clear any existing timeout
                if (this.copyTimeout) {
                    clearTimeout(this.copyTimeout);
                }

                // Add copied class for animation
                button.classList.add('copied');

                // Remove class after animation
                this.copyTimeout = setTimeout(() => {
                    button.classList.remove('copied');
                }, 1500);
            }

            /**
             * Create a copy button element
             * @param {string} text - Text to copy when clicked
             * @param {string} tooltip - Tooltip text
             * @returns {HTMLElement} Copy button element
             */
            createCopyButton(text, tooltip = 'Copy to clipboard') {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.innerHTML = 'üìã';
                button.title = tooltip;
                button.setAttribute('aria-label', tooltip);
                
                button.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    await this.copyToClipboard(text, button);
                });

                return button;
            }

            /**
             * Add copy functionality to an existing element
             * @param {HTMLElement} element - Element to make copyable
             * @param {string} text - Text to copy (optional, uses element text if not provided)
             * @param {string} position - Where to place the copy button ('after', 'before', 'inside')
             */
            makeCopyable(element, text = null, position = 'after') {
                if (!element) return null;

                const textToCopy = text || element.textContent.trim();
                const copyButton = this.createCopyButton(textToCopy);

                switch (position) {
                    case 'before':
                        element.parentNode.insertBefore(copyButton, element);
                        break;
                    case 'inside':
                        element.appendChild(copyButton);
                        break;
                    case 'after':
                    default:
                        element.parentNode.insertBefore(copyButton, element.nextSibling);
                        break;
                }

                return copyButton;
            }

            /**
             * Create a copy container with text and copy button
             * @param {string} text - Text to display and copy
             * @param {string} className - Additional CSS class for the container
             */
            createCopyContainer(text, className = '') {
                const container = document.createElement('div');
                container.className = `copy-container ${className}`.trim();

                const content = document.createElement('span');
                content.className = 'copy-content';
                content.textContent = text;

                const copyButton = this.createCopyButton(text);

                container.appendChild(content);
                container.appendChild(copyButton);

                return container;
            }
        }
        debugLog('CopyManager class defined successfully');

        /**
         * NEW: FormValidator
         * Handles real-time form validation with visual feedback
         */
        debugLog('Defining FormValidator class...');
        class FormValidator {
            constructor() {
                this.rules = new Map();
                this.validators = {
                    required: (value) => value && value.trim().length > 0,
                    serverAddress: (value) => {
                        if (!value) return false;
                        const parts = value.split(':');
                        if (parts.length !== 2) return false;
                        const [ip, port] = parts;
                        const portNum = parseInt(port);
                        return ip.length > 0 && portNum > 0 && portNum <= 65535;
                    },
                    username: (value) => {
                        if (!value) return false;
                        return /^[a-zA-Z0-9_-]{2,32}$/.test(value);
                    }
                };
            }

            /**
             * Add validation rule to a field
             */
            addRule(fieldId, validatorName, message, required = true) {
                if (!this.rules.has(fieldId)) {
                    this.rules.set(fieldId, []);
                }
                this.rules.get(fieldId).push({
                    validator: validatorName,
                    message: message,
                    required: required
                });
            }

            /**
             * Validate a single field
             */
            validateField(fieldId, value) {
                const rules = this.rules.get(fieldId);
                if (!rules) return { isValid: true, message: '' };

                for (const rule of rules) {
                    const validator = this.validators[rule.validator];
                    if (validator && !validator(value)) {
                        return { 
                            isValid: false, 
                            message: rule.message,
                            level: rule.required ? 'invalid' : 'warning'
                        };
                    }
                }

                return { isValid: true, message: 'Valid input', level: 'valid' };
            }

            /**
             * Apply visual validation state to field
             */
            applyValidationState(fieldElement, state) {
                if (!fieldElement) return;

                // Remove existing states
                fieldElement.classList.remove('valid', 'invalid', 'warning');
                
                // Add new state
                if (state.level) {
                    fieldElement.classList.add(state.level);
                }

                // Update validation icon and helper text
                this.updateValidationUI(fieldElement, state);
            }

            /**
             * Update validation UI elements
             */
            updateValidationUI(fieldElement, state) {
                const container = fieldElement.closest('.form-field') || fieldElement.parentElement;
                if (!container) return;

                // Update or create validation icon
                let icon = container.querySelector('.validation-icon');
                if (!icon && state.level !== 'valid') {
                    icon = document.createElement('span');
                    icon.className = 'validation-icon';
                    container.appendChild(icon);
                }

                if (icon) {
                    icon.className = `validation-icon ${state.level}`;
                    icon.textContent = this.getValidationIcon(state.level);
                    icon.style.display = state.level === 'valid' ? 'none' : 'block';
                }

                // Update or create helper text
                let helper = container.querySelector('.validation-helper');
                if (!helper && state.message) {
                    helper = document.createElement('div');
                    helper.className = 'validation-helper';
                    container.appendChild(helper);
                }

                if (helper && state.message) {
                    helper.className = `validation-helper ${state.level} show`;
                    helper.textContent = state.message;
                } else if (helper) {
                    helper.classList.remove('show');
                }
            }

            /**
             * Get validation icon for state
             */
            getValidationIcon(level) {
                const icons = {
                    valid: '‚úì',
                    invalid: '‚úó',
                    warning: '‚ö†'
                };
                return icons[level] || '';
            }

            /**
             * Setup real-time validation for a field
             */
            setupRealTimeValidation(fieldElement, fieldId) {
                if (!fieldElement) return;

                const validateAndUpdate = () => {
                    const value = fieldElement.value;
                    const state = this.validateField(fieldId, value);
                    this.applyValidationState(fieldElement, state);
                };

                // Validate on input (real-time)
                fieldElement.addEventListener('input', validateAndUpdate);
                
                // Validate on blur
                fieldElement.addEventListener('blur', validateAndUpdate);

                // Initial validation
                validateAndUpdate();
            }
        }
        debugLog('FormValidator class defined successfully');

        /**
         * NEW: FileMemoryManager
         * Remembers file selection history and provides file path suggestions
         */
        debugLog('Defining FileMemoryManager class...');
        class FileMemoryManager {
            constructor() {
                this.storageKey = 'cyberbackup_file_memory';
                this.maxHistorySize = 10;
            }

            /**
             * Save file information to memory
             * @param {File} file - The selected file
             */
            saveFileSelection(file) {
                try {
                    const fileInfo = {
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified,
                        timestamp: Date.now(),
                        // Note: webkitRelativePath available for directory selection
                        path: file.webkitRelativePath || file.name
                    };

                    // Get existing history
                    const history = this.getFileHistory();
                    
                    // Remove duplicate entries (same name and size)
                    const filteredHistory = history.filter(item => 
                        !(item.name === fileInfo.name && item.size === fileInfo.size)
                    );
                    
                    // Add new entry at the beginning
                    filteredHistory.unshift(fileInfo);
                    
                    // Limit history size
                    const trimmedHistory = filteredHistory.slice(0, this.maxHistorySize);
                    
                    // Save to localStorage
                    localStorage.setItem(this.storageKey, JSON.stringify(trimmedHistory));
                    
                    debugLog(`File selection saved to memory: ${file.name}`, 'FILE_MEMORY');
                } catch (error) {
                    console.warn('Failed to save file selection to memory:', error);
                }
            }

            /**
             * Get file selection history
             * @returns {Array} Array of file info objects
             */
            getFileHistory() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.warn('Failed to load file history:', error);
                    return [];
                }
            }

            /**
             * Get the most recently selected file info
             * @returns {Object|null} Last file info or null
             */
            getLastFile() {
                const history = this.getFileHistory();
                return history.length > 0 ? history[0] : null;
            }

            /**
             * Clear file selection history
             */
            clearHistory() {
                localStorage.removeItem(this.storageKey);
                debugLog('File selection history cleared', 'FILE_MEMORY');
            }

            /**
             * Get file suggestions for UI display
             * @returns {Array} Array of recent files with formatted info
             */
            getFileSuggestions() {
                const history = this.getFileHistory();
                return history.map(file => ({
                    ...file,
                    sizeFormatted: this.formatBytes(file.size),
                    timeAgo: this.formatTimeAgo(file.timestamp),
                    displayName: file.name.length > 30 ? 
                        file.name.substring(0, 27) + '...' : file.name
                }));
            }

            /**
             * Format bytes for display
             */
            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            /**
             * Format time ago for display
             */
            formatTimeAgo(timestamp) {
                const now = Date.now();
                const diff = now - timestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (minutes < 1) return 'Just now';
                if (minutes < 60) return `${minutes}m ago`;
                if (hours < 24) return `${hours}h ago`;
                return `${days}d ago`;
            }

            /**
             * Create recent files dropdown UI
             * @param {HTMLElement} container - Container to add the dropdown to
             * @param {Function} onFileSelect - Callback when file is selected from history
             */
            createRecentFilesUI(container, onFileSelect) {
                const suggestions = this.getFileSuggestions();
                if (suggestions.length === 0) return;

                const dropdown = document.createElement('div');
                dropdown.className = 'recent-files-dropdown fade-in';
                dropdown.style.cssText = `
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background: var(--bg-card);
                    border: 1px solid var(--glass-border);
                    border-radius: var(--radius-md);
                    padding: var(--space-sm);
                    z-index: 1000;
                    max-height: 200px;
                    overflow-y: auto;
                    margin-top: 4px;
                `;

                const title = document.createElement('div');
                title.textContent = 'Recent Files';
                title.style.cssText = `
                    font-size: var(--font-size-xs);
                    color: var(--text-secondary);
                    margin-bottom: var(--space-xs);
                    text-transform: uppercase;
                    font-weight: 600;
                `;
                dropdown.appendChild(title);

                // Batch dropdown items using DocumentFragment to reduce reflows
                const dropdownFragment = document.createDocumentFragment();
                
                suggestions.slice(0, 5).forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'recent-file-item';
                    item.style.cssText = `
                        padding: var(--space-xs);
                        border-radius: var(--radius-sm);
                        cursor: pointer;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        transition: background 0.2s ease;
                    `;

                    item.innerHTML = `
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: var(--font-size-sm); color: var(--text-primary); truncate;">
                                ${file.displayName}
                            </div>
                            <div style="font-size: var(--font-size-xs); color: var(--text-muted);">
                                ${file.sizeFormatted} ‚Ä¢ ${file.timeAgo}
                            </div>
                        </div>
                    `;

                    item.addEventListener('mouseenter', () => {
                        item.style.background = 'rgba(0, 191, 255, 0.1)';
                    });

                    item.addEventListener('mouseleave', () => {
                        item.style.background = 'transparent';
                    });

                    item.addEventListener('click', () => {
                        onFileSelect(file);
                        dropdown.remove();
                    });

                    dropdownFragment.appendChild(item);
                });
                
                dropdown.appendChild(dropdownFragment);

                container.appendChild(dropdown);

                // Remove dropdown when clicking outside
                setTimeout(() => {
                    const clickOutside = (e) => {
                        if (!dropdown.contains(e.target)) {
                            dropdown.remove();
                            document.removeEventListener('click', clickOutside);
                        }
                    };
                    document.addEventListener('click', clickOutside);
                }, 100);
            }
        }
        debugLog('FileMemoryManager class defined successfully');

        /**
         * NEW: BackupHistoryManager
         * Tracks and manages backup history with localStorage persistence
         */
        debugLog('Defining BackupHistoryManager class...');
        
        class BackupHistoryManager {
            constructor() {
                this.storageKey = 'cyberbackup_history';
                this.maxHistorySize = 50;
            }

            /**
             * Add a completed backup to history
             * @param {Object} backupInfo - Backup details
             */
            addBackup(backupInfo) {
                try {
                    const backup = {
                        id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                        timestamp: Date.now(),
                        status: backupInfo.status || 'completed',
                        filename: backupInfo.filename || 'unknown',
                        fileSize: backupInfo.fileSize || 0,
                        server: backupInfo.server || 'unknown',
                        username: backupInfo.username || 'unknown',
                        duration: backupInfo.duration || 0,
                        transferSpeed: backupInfo.transferSpeed || 0,
                        phase: backupInfo.phase || 'completed',
                        clientId: backupInfo.clientId || null,
                        error: backupInfo.error || null
                    };

                    const history = this.getHistory();
                    history.unshift(backup);
                    
                    // Limit history size
                    const trimmedHistory = history.slice(0, this.maxHistorySize);
                    localStorage.setItem(this.storageKey, JSON.stringify(trimmedHistory));
                    
                    debugLog(`Backup added to history: ${backup.filename}`, 'BACKUP_HISTORY');
                    return backup.id;
                } catch (error) {
                    console.warn('Failed to add backup to history:', error);
                    return null;
                }
            }

            /**
             * Get backup history
             * @returns {Array} Array of backup records
             */
            getHistory() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.warn('Failed to load backup history:', error);
                    return [];
                }
            }

            /**
             * Get formatted history for UI display
             * @returns {Array} Array of formatted backup records
             */
            getFormattedHistory() {
                const history = this.getHistory();
                return history.map(backup => ({
                    ...backup,
                    dateFormatted: this.formatDate(backup.timestamp),
                    timeAgo: this.formatTimeAgo(backup.timestamp),
                    sizeFormatted: this.formatBytes(backup.fileSize),
                    durationFormatted: this.formatDuration(backup.duration),
                    speedFormatted: this.formatSpeed(backup.transferSpeed),
                    statusIcon: this.getStatusIcon(backup.status),
                    statusColor: this.getStatusColor(backup.status)
                }));
            }

            /**
             * Get successful backups only
             * @returns {Array} Array of successful backup records
             */
            getSuccessfulBackups() {
                return this.getHistory().filter(backup => backup.status === 'completed');
            }

            /**
             * Get failed backups only
             * @returns {Array} Array of failed backup records
             */
            getFailedBackups() {
                return this.getHistory().filter(backup => backup.status === 'failed' || backup.error);
            }

            /**
             * Get backup statistics
             * @returns {Object} Statistics object
             */
            getStatistics() {
                const history = this.getHistory();
                const successful = this.getSuccessfulBackups();
                const failed = this.getFailedBackups();
                
                const totalSize = successful.reduce((sum, backup) => sum + (backup.fileSize || 0), 0);
                const totalDuration = successful.reduce((sum, backup) => sum + (backup.duration || 0), 0);
                const averageSpeed = successful.length > 0 ? 
                    successful.reduce((sum, backup) => sum + (backup.transferSpeed || 0), 0) / successful.length : 0;

                return {
                    totalBackups: history.length,
                    successfulBackups: successful.length,
                    failedBackups: failed.length,
                    successRate: history.length > 0 ? ((successful.length / history.length) * 100).toFixed(1) : '0',
                    totalSizeTransferred: totalSize,
                    totalSizeFormatted: this.formatBytes(totalSize),
                    averageSpeed,
                    averageSpeedFormatted: this.formatSpeed(averageSpeed),
                    totalDuration,
                    totalDurationFormatted: this.formatDuration(totalDuration)
                };
            }

            /**
             * Clear backup history
             */
            clearHistory() {
                localStorage.removeItem(this.storageKey);
                debugLog('Backup history cleared', 'BACKUP_HISTORY');
            }

            /**
             * Remove a specific backup from history
             * @param {string} backupId - ID of backup to remove
             */
            removeBackup(backupId) {
                try {
                    const history = this.getHistory();
                    const filteredHistory = history.filter(backup => backup.id !== backupId);
                    localStorage.setItem(this.storageKey, JSON.stringify(filteredHistory));
                    debugLog(`Backup removed from history: ${backupId}`, 'BACKUP_HISTORY');
                } catch (error) {
                    console.warn('Failed to remove backup from history:', error);
                }
            }

            // Helper methods for formatting
            formatDate(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            }

            formatTimeAgo(timestamp) {
                const now = Date.now();
                const diff = now - timestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (minutes < 1) return 'Just now';
                if (minutes < 60) return `${minutes}m ago`;
                if (hours < 24) return `${hours}h ago`;
                return `${days}d ago`;
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            formatDuration(seconds) {
                if (seconds < 60) return `${seconds.toFixed(1)}s`;
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
            }

            formatSpeed(bytesPerSecond) {
                if (bytesPerSecond === 0) return '0 B/s';
                const k = 1024;
                const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
                const i = Math.floor(Math.log(bytesPerSecond) / Math.log(k));
                return parseFloat((bytesPerSecond / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            getStatusIcon(status) {
                const icons = {
                    'completed': '‚úÖ',
                    'failed': '‚ùå',
                    'cancelled': '‚èπÔ∏è',
                    'in_progress': '‚è≥'
                };
                return icons[status] || '‚ùì';
            }

            getStatusColor(status) {
                const colors = {
                    'completed': 'var(--success)',
                    'failed': 'var(--error)',
                    'cancelled': 'var(--warning)',
                    'in_progress': 'var(--primary)'
                };
                return colors[status] || 'var(--text-muted)';
            }
        }
        debugLog('BackupHistoryManager class defined successfully');

        /**
         * NEW: ConnectionHealthMonitor
         * Monitors connection health with ping/latency measurements
         */
        debugLog('Defining ConnectionHealthMonitor class...');
        class ConnectionHealthMonitor {
            constructor() {
                this.isMonitoring = false;
                this.pingInterval = null;
                this.currentLatency = null;
                this.lastPingTime = null;
                this.connectionQuality = 'unknown';
                this.healthHistory = [];
                this.maxHistorySize = 10;
                
                // UI elements will be set by the app
                this.healthIndicatorElement = null;
                this.pingDisplayElement = null;
                this.healthContainerElement = null;
            }

            /**
             * Initialize health monitor with UI elements
             * @param {HTMLElement} healthContainer - Container element
             * @param {HTMLElement} healthIndicator - Health icon element  
             * @param {HTMLElement} pingDisplay - Ping display element
             */
            initialize(healthContainer, healthIndicator, pingDisplay) {
                this.healthContainerElement = healthContainer;
                this.healthIndicatorElement = healthIndicator;
                this.pingDisplayElement = pingDisplay;
            }

            /**
             * Start monitoring connection health
             * @param {string} serverAddress - Server address to ping (e.g., "127.0.0.1:1256")
             */
            startMonitoring(serverAddress) {
                if (this.isMonitoring) {
                    this.stopMonitoring();
                }

                this.serverAddress = serverAddress;
                this.isMonitoring = true;
                
                // Show the health indicator
                if (this.healthContainerElement) {
                    this.healthContainerElement.style.display = 'flex';
                    this.healthContainerElement.style.alignItems = 'center';
                    this.healthContainerElement.style.gap = 'var(--space-xs)';
                }

                // Initial ping
                this.performHealthCheck();

                // Start periodic health checks (every 30 seconds)
                this.pingInterval = setInterval(() => {
                    this.performHealthCheck();
                }, 30000);

                debugLog(`Started health monitoring for ${serverAddress}`, 'HEALTH_MONITOR');
            }

            /**
             * Stop monitoring connection health
             */
            stopMonitoring() {
                this.isMonitoring = false;
                
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }

                // Hide the health indicator
                if (this.healthContainerElement) {
                    this.healthContainerElement.style.display = 'none';
                }

                // Reset state
                this.currentLatency = null;
                this.connectionQuality = 'unknown';
                this.healthHistory = [];

                debugLog('Stopped health monitoring', 'HEALTH_MONITOR');
            }

            /**
             * Perform a health check (ping simulation using API call)
             */
            async performHealthCheck() {
                if (!this.isMonitoring || !this.serverAddress) return;

                try {
                    const startTime = performance.now();
                    
                    // Use a lightweight API call to measure response time
                    // We'll use the status endpoint which should be fast
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

                    const response = await fetch('http://localhost:9090/api/status', {
                        method: 'GET',
                        signal: controller.signal,
                        cache: 'no-cache'
                    });

                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const latency = Math.round(endTime - startTime);

                    this.updateHealthMetrics(latency, true);
                    
                } catch (error) {
                    // Connection failed or timed out
                    this.updateHealthMetrics(null, false);
                    console.warn('Health check failed:', error.message);
                }
            }

            /**
             * Update health metrics and UI
             * @param {number|null} latency - Measured latency in ms (null if failed)
             * @param {boolean} isConnected - Whether connection succeeded
             */
            updateHealthMetrics(latency, isConnected) {
                this.lastPingTime = Date.now();
                this.currentLatency = latency;

                // Add to history
                this.healthHistory.unshift({
                    timestamp: this.lastPingTime,
                    latency: latency,
                    isConnected: isConnected
                });

                // Trim history
                if (this.healthHistory.length > this.maxHistorySize) {
                    this.healthHistory = this.healthHistory.slice(0, this.maxHistorySize);
                }

                // Determine connection quality
                this.connectionQuality = this.calculateConnectionQuality(latency, isConnected);

                // Update UI
                this.updateHealthUI();

                debugLog(`Health check: ${latency}ms, Quality: ${this.connectionQuality}`, 'HEALTH_MONITOR');
            }

            /**
             * Calculate connection quality based on latency
             * @param {number|null} latency - Latency in ms
             * @param {boolean} isConnected - Connection status
             * @returns {string} Quality rating
             */
            calculateConnectionQuality(latency, isConnected) {
                if (!isConnected || latency === null) return 'offline';
                if (latency < 50) return 'excellent';
                if (latency < 150) return 'good';
                if (latency < 300) return 'fair';
                if (latency < 1000) return 'poor';
                return 'very_poor';
            }

            /**
             * Update health indicator UI
             */
            updateHealthUI() {
                if (!this.healthIndicatorElement || !this.pingDisplayElement) return;

                // Update ping display
                if (this.currentLatency !== null) {
                    this.pingDisplayElement.textContent = `${this.currentLatency}ms`;
                } else {
                    this.pingDisplayElement.textContent = 'timeout';
                }

                // Update health indicator icon and color
                const qualityConfig = {
                    offline: { icon: 'üìµ', color: 'var(--error)', title: 'Connection failed' },
                    excellent: { icon: 'üì∂', color: 'var(--success)', title: 'Excellent connection' },
                    good: { icon: 'üì∂', color: 'var(--neon-green)', title: 'Good connection' },
                    fair: { icon: 'üì∂', color: 'var(--warning)', title: 'Fair connection' },
                    poor: { icon: 'üì∂', color: 'var(--neon-orange)', title: 'Poor connection' },
                    very_poor: { icon: 'üì∂', color: 'var(--error)', title: 'Very poor connection' }
                };

                const config = qualityConfig[this.connectionQuality] || qualityConfig.offline;

                this.healthIndicatorElement.textContent = config.icon;
                this.healthIndicatorElement.style.color = config.color;
                this.healthIndicatorElement.title = `${config.title} (${this.currentLatency || '--'}ms)`;
                this.pingDisplayElement.style.color = config.color;

                // Add subtle animation for poor connections
                if (this.connectionQuality === 'poor' || this.connectionQuality === 'very_poor') {
                    this.healthIndicatorElement.style.animation = 'pulse 2s infinite';
                } else {
                    this.healthIndicatorElement.style.animation = 'none';
                }
            }

            /**
             * Get current health status for external use
             * @returns {Object} Health status object
             */
            getHealthStatus() {
                return {
                    isMonitoring: this.isMonitoring,
                    latency: this.currentLatency,
                    quality: this.connectionQuality,
                    lastCheck: this.lastPingTime,
                    averageLatency: this.getAverageLatency(),
                    recentHistory: this.healthHistory.slice(0, 5)
                };
            }

            /**
             * Calculate average latency from recent history
             * @returns {number|null} Average latency or null
             */
            getAverageLatency() {
                const validPings = this.healthHistory.filter(h => h.latency !== null);
                if (validPings.length === 0) return null;
                
                const sum = validPings.reduce((acc, h) => acc + h.latency, 0);
                return Math.round(sum / validPings.length);
            }
        }
        debugLog('ConnectionHealthMonitor class defined successfully');

        // Initialize the main application
        debugLog('Initializing App instance...');
        const app = new App();
        window.app = app; // Make globally accessible for CopyManager
        debugLog('App instance initialized.');

        // Initialize error boundary system
        debugLog('Initializing ErrorBoundary...');
        const errorBoundary = new ErrorBoundary(app);
        app.errorBoundary = errorBoundary;
        debugLog('ErrorBoundary initialized.');

        // Initialize particle system
        debugLog('Initializing ParticleSystem...');
        const particleSystem = new ParticleSystem(app);
        particleSystem.init();
        debugLog('ParticleSystem initialized.');

        // Initial UI update
        app.updateAllUI();

        // Make systems accessible from app for potential controls
        app.particleSystem = particleSystem;

        debugLog('=== SCRIPT LOADING COMPLETE ===');
    </script>
</body>
</html>