<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberBackup Pro - v3.0 (API Driven)</title>
    <style>
        /* CRITICAL FIX: Move @import to top */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono:wght@400&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Enhanced Cyberpunk Color Palette */
            --neon-pink: #FF00FF;
            --neon-blue: #00FFFF;
            --neon-purple: #8A2BE2;
            --neon-green: #00FF00;
            --neon-yellow: #FFFF00;
            --neon-orange: #FF4500;
            --neon-red: #FF0040;
            --electric-blue: #0080FF;
            --cyber-lime: #32CD32;
            --plasma-pink: #FF1493;
            
            --bg-black: #000000;
            --bg-dark: #0A0A0A;
            --bg-medium: #1A1A2E;
            --bg-light: #16213E;
            --bg-card: rgba(26, 26, 46, 0.95);
            --bg-glass: rgba(255, 255, 255, 0.05);
            
            --text-primary: #FFFFFF;
            --text-secondary: #E0E0E0;
            --text-dim: #888888;
            --text-contrast: rgba(0, 0, 0, 0.8);
            
            --success: var(--neon-green);
            --warning: var(--neon-yellow);
            --error: var(--neon-red);
            --info: var(--neon-blue);
            
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-border-active: rgba(0, 255, 255, 0.6);
            
            /* Enhanced Glow Effects */
            --glow-pink: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink), 0 0 40px var(--neon-pink);
            --glow-blue: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue), 0 0 40px var(--neon-blue);
            --glow-green: 0 0 10px var(--neon-green), 0 0 20px var(--neon-green), 0 0 40px var(--neon-green);
            --glow-purple: 0 0 10px var(--neon-purple), 0 0 20px var(--neon-purple), 0 0 40px var(--neon-purple);
            
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-fast: all 0.15s ease-out;
            
            /* Improved Spacing System */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            
            /* Enhanced Border Radius System */
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
        }

        body {
            font-family: 'Orbitron', 'Share Tech Mono', monospace;
            background: var(--bg-black);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto; /* Ensure proper scrolling */
            position: relative;
            font-size: 1.125rem; /* Increased base font size */
        }

        /* Enhanced Animated Background */
        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(0, 255, 0, 0.1) 0%, transparent 50%),
                linear-gradient(var(--neon-pink) 1px, transparent 1px),
                linear-gradient(90deg, var(--neon-blue) 1px, transparent 1px);
            background-size: 
                100% 100%,
                100% 100%,
                100% 100%,
                100px 100px,
                100px 100px;
            opacity: 0.1;
            animation: cyber-grid-flow 30s linear infinite;
        }

        @keyframes cyber-grid-flow {
            0% { 
                transform: translate(0, 0) rotate(0deg);
                background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
            }
            100% { 
                transform: translate(100px, 100px) rotate(0.5deg);
                background-position: 100px 100px, -50px 50px, 150px -100px, 100px 100px, 100px 100px;
            }
        }

        /* Enhanced Neon Text Effects */
        .neon-text {
            position: relative;
            color: var(--text-primary);
            text-shadow: var(--glow-blue);
            animation: neon-flicker 3s ease-in-out infinite alternate;
        }

        .neon-text.pink { 
            color: var(--neon-pink);
            text-shadow: var(--glow-pink);
        }

        .neon-text.green { 
            color: var(--neon-green);
            text-shadow: var(--glow-green);
        }

        .neon-text.purple { 
            color: var(--neon-purple);
            text-shadow: var(--glow-purple);
        }

        @keyframes neon-flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
                text-shadow: var(--glow-blue);
            }
            20%, 24%, 55% {        
                opacity: 0.4;
                text-shadow: none;
            }
        }

        /* Enhanced Accessibility: Better contrast backgrounds */
        .text-with-contrast {
            background: var(--text-contrast);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        /* IMPROVED CONTAINER - Better Spacing and Responsive Grid */
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: var(--space-md) var(--space-md) var(--space-xl); /* FIX: Added bottom padding to prevent clipping */
            display: grid;
            grid-template-columns: minmax(300px, 1fr) minmax(400px, 2fr) minmax(350px, 1fr);
            grid-template-rows: auto 1fr auto;
            gap: var(--space-md);
            min-height: 100vh;
            grid-template-areas: 
                "header header header"
                "config main status"
                "debug debug debug";
        }

        /* Enhanced Glass Card with RGB Border Animation and Drop Shadows */
        .glass-card {
            background: var(--bg-card);
            -webkit-backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border: 2px solid transparent;
            border-radius: var(--radius-xl);
            padding: var(--space-md);
            position: relative;
            overflow: hidden;
            transition: var(--transition);
            background-clip: padding-box;
            /* FIX: Enhanced depth with more pronounced drop shadows */
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.5),
                0 2px 6px rgba(0, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                var(--neon-pink), var(--neon-blue), var(--neon-purple), 
                var(--neon-green), var(--neon-yellow), var(--neon-pink));
            background-size: 400% 400%;
            border-radius: calc(var(--radius-xl) + 3px);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
            animation: rgb-border-cycle 4s ease-in-out infinite;
        }

        .glass-card:hover::before,
        .glass-card.active::before {
            opacity: 0.7;
        }

        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.5),
                0 4px 12px rgba(0, 255, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        @keyframes rgb-border-cycle {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Particle Effect Container */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--neon-blue);
            border-radius: 50%;
            animation: particle-float 3s linear infinite;
        }

        @keyframes particle-float {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-10vh) scale(1);
                opacity: 0;
            }
        }

        /* Enhanced Header - Better Layout */
        .header {
            grid-area: header;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xl);
            border-bottom: 3px solid transparent;
            background: linear-gradient(90deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
            position: relative;
            border-image: linear-gradient(90deg, var(--neon-pink), var(--neon-blue), var(--neon-purple)) 1;
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-md);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }

        .logo-icon {
            font-size: 2.5rem;
            animation: logo-pulse 4s ease-in-out infinite;
            color: var(--neon-pink);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }

        .logo-icon:hover {
            transform: scale(1.1);
            filter: drop-shadow(var(--glow-pink));
        }

        .logo-icon:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 4px;
        }

        @keyframes logo-pulse {
            0%, 100% { 
                transform: scale(1);
                color: var(--neon-pink);
            }
            25% { 
                transform: scale(1.05);
                color: var(--neon-blue);
            }
            50% { 
                transform: scale(1.1);
                color: var(--neon-purple);
            }
            75% { 
                transform: scale(1.05);
                color: var(--neon-green);
            }
        }

        .logo-text h1 {
            font-size: 2rem;
            font-weight: 900;
            color: var(--neon-pink);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: var(--space-xs);
            position: relative;
        }

        .logo-text .subtitle {
            font-size: 0.875rem;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Share Tech Mono', monospace;
        }

        /* Enhanced Connection Status with Icons */
        .connection-status {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            padding: var(--space-lg) var(--space-xl);
            background: var(--bg-card);
            border-radius: 50px;
            border: 2px solid var(--glass-border);
            transition: var(--transition);
        }

        .connection-status:hover {
            border-color: var(--glass-border-active);
            box-shadow: var(--glow-blue);
        }

        .status-led {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            background: var(--error);
            position: relative;
            animation: pulse-error 2s infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            box-shadow: 
                0 0 10px rgba(255, 0, 64, 0.4),
                0 0 20px rgba(255, 0, 64, 0.2);
        }

        .status-led.connected {
            background: var(--success);
            animation: pulse-success 2s infinite;
            box-shadow: 
                var(--glow-green),
                0 0 15px rgba(0, 255, 0, 0.4);
        }

        .status-led.connecting {
            background: var(--warning);
            animation: pulse-warning 1s infinite;
            box-shadow: 
                0 0 10px rgba(255, 255, 0, 0.4),
                0 0 20px rgba(255, 255, 0, 0.2);
        }

        .status-led.connected::after {
            content: '‚úì';
        }

        .status-led.connecting::after {
            content: '‚ü≥';
            animation: spin 1s linear infinite;
        }

        .status-led:not(.connected):not(.connecting)::after {
            content: '‚úó';
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes pulse-success {
            0%, 100% { 
                box-shadow: 
                    var(--glow-green),
                    0 0 15px rgba(0, 255, 0, 0.4);
                transform: scale(1);
            }
            50% { 
                box-shadow: 
                    0 0 30px var(--neon-green), 
                    0 0 60px var(--neon-green),
                    0 0 25px rgba(0, 255, 0, 0.6);
                transform: scale(1.05);
            }
        }

        @keyframes pulse-error {
            0%, 100% { 
                box-shadow: 
                    0 0 10px rgba(255, 0, 64, 0.4),
                    0 0 20px rgba(255, 0, 64, 0.2);
                transform: scale(1);
            }
            50% { 
                box-shadow: 
                    0 0 20px var(--error), 
                    0 0 40px var(--error),
                    0 0 30px rgba(255, 0, 64, 0.4);
                transform: scale(1.05);
            }
        }

        @keyframes pulse-warning {
            0%, 100% { 
                box-shadow: 
                    0 0 10px rgba(255, 255, 0, 0.4),
                    0 0 20px rgba(255, 255, 0, 0.2);
                transform: scale(1);
            }
            50% { 
                box-shadow: 
                    0 0 20px var(--warning), 
                    0 0 40px var(--warning),
                    0 0 30px rgba(255, 255, 0, 0.4);
                transform: scale(1.05);
            }
        }

        /* Enhanced Panel Headers */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--glass-border);
        }

        .panel-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Configuration Panel Improvements */
        .config-panel {
            grid-area: config;
        }

        .config-section {
            margin-bottom: var(--space-lg);
        }

        .config-label {
            display: block;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .config-value {
            font-size: 1rem;
            color: var(--text-dim);
            margin-top: var(--space-sm);
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            max-width: 100%;
        }

        .config-value.file-info {
            background: var(--bg-black);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--glass-border);
        }

        .file-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .file-details {
            flex: 1;
            min-width: 0; /* Allow text to truncate */
        }

        .file-name {
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .file-size {
            font-size: 0.875rem;
            color: var(--text-dim);
            margin-top: 2px;
        }

        /* Enhanced Input Fields */
        .config-input {
            width: 100%;
            padding: var(--space-md) var(--space-lg);
            background: var(--bg-black);
            border: 2px solid var(--glass-border);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem;
            transition: var(--transition);
            position: relative;
        }

        .config-input:focus {
            outline: none;
            border-color: var(--neon-blue);
            box-shadow: var(--glow-blue);
            background: rgba(0, 255, 255, 0.05);
        }

        .config-input.error {
            border-color: var(--error);
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.3);
            animation: input-shake 0.5s ease-in-out;
        }

        @keyframes input-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Enhanced File Drop Zone with Better Visual Feedback */
        .file-drop-zone {
            position: relative;
            margin-bottom: var(--space-lg);
            border: 2px dashed var(--glass-border);
            border-radius: var(--radius-xl);
            padding: var(--space-2xl);
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
            background: var(--bg-glass);
            box-shadow: 
                inset 0 2px 6px rgba(0, 0, 0, 0.2),
                0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .file-drop-zone:hover,
        .file-drop-zone.drag-over {
            border-color: var(--neon-blue);
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 
                var(--glow-blue),
                inset 0 2px 6px rgba(0, 255, 255, 0.1),
                0 4px 16px rgba(0, 255, 255, 0.2);
            transform: scale(1.02);
        }

        .file-drop-zone.drag-over::before {
            content: 'üìÅ Drop file here!';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.25rem;
            color: var(--neon-blue);
            font-weight: bold;
            z-index: 10;
            text-shadow: var(--glow-blue);
            animation: pulse-glow 1s ease-in-out infinite alternate;
        }

        @keyframes pulse-glow {
            0% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-md);
            padding: var(--space-lg);
            background: linear-gradient(45deg, var(--neon-purple), var(--neon-blue));
            border: none;
            border-radius: var(--radius-md);
            color: white;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        .file-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-purple);
            filter: brightness(1.2);
        }

        .file-button:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        /* Main Panel Improvements */
        .main-panel {
            grid-area: main;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .phase-display {
            margin-bottom: var(--space-xl);
            font-size: 1.375rem;
            font-weight: 700;
            text-align: center;
        }

        /* Enhanced Progress Ring with Better Proportions */
        .progress-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin-bottom: var(--space-2xl);
        }

        /* Enhanced Progress Ring with Dynamic Glow */
        .progress-ring {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            filter: drop-shadow(var(--glow-blue));
            transition: filter 0.3s ease;
        }

        .progress-ring.active {
            filter: drop-shadow(0 0 20px var(--neon-blue)) drop-shadow(0 0 40px var(--neon-blue));
        }

        .progress-fill {
            fill: none;
            stroke: url(#progressGradient);
            stroke-width: 20;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .progress-percentage {
            font-size: 2.75rem;
            font-weight: 900;
            color: var(--neon-blue);
            margin-bottom: var(--space-sm);
            text-shadow: var(--glow-blue);
        }

        .progress-label {
            font-size: 1rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Enhanced Control Panel */
        .control-panel {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-2xl);
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Unified Cyberpunk Button System - Enhanced */
        .cyber-btn {
            padding: var(--space-md) var(--space-lg);
            border: 2px solid;
            background: transparent;
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            font-family: 'Orbitron', monospace;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            min-height: 44px; /* Better touch targets */
        }

        .cyber-btn:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        .cyber-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .cyber-btn.primary {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
        }

        .cyber-btn.primary:hover:not(:disabled) {
            background: var(--neon-blue);
            color: var(--bg-black);
            box-shadow: var(--glow-blue);
            transform: translateY(-2px);
        }

        .cyber-btn.success {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .cyber-btn.success:hover:not(:disabled) {
            background: var(--neon-green);
            color: var(--bg-black);
            box-shadow: var(--glow-green);
            transform: translateY(-2px);
        }

        .cyber-btn.danger {
            border-color: var(--error);
            color: var(--error);
        }

        .cyber-btn.danger:hover:not(:disabled) {
            background: var(--error);
            color: var(--bg-black);
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.6);
            transform: translateY(-2px);
        }

        .cyber-btn.secondary {
            border-color: var(--neon-purple);
            color: var(--neon-purple);
        }

        .cyber-btn.secondary:hover:not(:disabled) {
            background: var(--neon-purple);
            color: var(--bg-black);
            box-shadow: var(--glow-purple);
            transform: translateY(-2px);
        }

        /* Large Control Buttons */
        .cyber-btn.large {
            padding: var(--space-lg) var(--space-xl);
            font-size: 1rem;
            min-width: 160px;
        }

        .cyber-btn.large:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.02);
        }

        /* Small compact buttons */
        .cyber-btn.small {
            padding: var(--space-sm) var(--space-md);
            font-size: 0.625rem;
            min-width: auto;
        }

        .cyber-btn.control {
            /* Extend cyber-btn for control buttons - Enhanced with better accessibility */
        }

        /* File preview container */
        .file-preview-container {
            background: var(--bg-black);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            transition: var(--transition);
        }

        .file-preview-container:hover {
            border-color: var(--glass-border-active);
        }

        .file-icon-large {
            font-size: 2rem;
            opacity: 0.7;
        }

        .btn-group {
            display: flex;
            gap: var(--space-sm);
            flex-wrap: wrap;
            margin-top: var(--space-lg);
        }

        /* Enhanced Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--space-md);
            width: 100%;
            max-width: 600px;
        }

        .stat-card {
            background: var(--bg-black);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-xl);
            padding: var(--space-lg);
            text-align: center;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 3px 8px rgba(0, 0, 0, 0.3),
                0 1px 4px rgba(0, 255, 255, 0.1);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .stat-card:hover {
            border-color: var(--neon-blue);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.4),
                0 2px 8px rgba(0, 255, 255, 0.2),
                var(--glow-blue);
            transform: translateY(-8px) scale(1.02);
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-value {
            font-size: 1.375rem;
            font-weight: 700;
            color: var(--neon-blue);
            margin-bottom: var(--space-sm);
            font-family: 'Share Tech Mono', monospace;
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Status Panel Improvements */
        .status-panel {
            grid-area: status;
        }

        .log-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            background: var(--bg-black);
        }

        /* Enhanced Security Badges */
        .security-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-lg);
        }

        .security-badge {
            padding: var(--space-lg);
            background: var(--bg-black);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            gap: var(--space-md);
            transition: var(--transition);
            position: relative;
            box-shadow: 
                0 2px 6px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .security-badge.active {
            border-color: var(--success);
            box-shadow: inset 0 0 20px rgba(0, 255, 0, 0.2);
            background: rgba(0, 255, 0, 0.05);
            animation: security-activation 0.6s ease-out;
        }

        @keyframes security-activation {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .security-badge.active .badge-icon {
            color: var(--success);
            animation: security-pulse 2s infinite;
            filter: drop-shadow(var(--glow-green));
        }

        @keyframes security-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .badge-icon {
            font-size: 1.25rem;
        }

        .badge-text {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Theme Selector Improvements */
        .theme-selector {
            display: flex;
            gap: var(--space-md);
            justify-content: center;
            align-items: center;
            margin-top: var(--space-lg);
        }

        .theme-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 3px solid var(--glass-border);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            outline: none;
        }

        .theme-btn:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 3px;
        }

        .theme-btn.cyberpunk {
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-blue), var(--neon-purple));
        }

        .theme-btn.dark {
            background: linear-gradient(45deg, #2C3E50, #34495E, #1A1A1A);
        }

        .theme-btn.matrix {
            background: linear-gradient(45deg, #000000, var(--neon-green), #003300);
        }

        .theme-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 0 25px currentColor;
            border-color: var(--neon-blue);
        }

        .theme-btn.active {
            border-color: var(--neon-blue);
            box-shadow: var(--glow-blue);
            transform: scale(1.1);
        }

        .theme-btn.active::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        /* Enhanced Log System */
        .log-entry {
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-family: 'Share Tech Mono', monospace;
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
            transition: var(--transition);
            cursor: pointer;
            border-left: 3px solid transparent;
            position: relative;
        }

        .log-entry:hover {
            background: var(--bg-medium);
            border-left-color: var(--neon-blue);
            transform: translateX(5px);
        }

        .log-entry:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        .log-timestamp {
            font-size: 0.75rem;
            color: var(--text-dim);
            min-width: 60px;
        }

        .log-icon {
            font-size: 0.875rem;
            min-width: 16px;
        }

        .log-icon.success {
            color: var(--success);
        }

        .log-icon.error {
            color: var(--error);
        }

        .log-icon.info {
            color: var(--info);
        }

        .log-content {
            flex: 1;
        }

        .log-message {
            font-weight: 600;
            margin-bottom: var(--space-xs);
        }

        .log-details {
            font-size: 0.75rem;
            color: var(--text-dim);
            opacity: 0.8;
        }

        /* Enhanced Toast System with Better Stacking */
        .toast-container {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            max-width: 400px;
        }

        .toast {
            background: var(--bg-card);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-lg);
            padding: var(--space-lg) var(--space-xl);
            animation: toast-slide-in 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.5),
                0 2px 6px rgba(0, 0, 0, 0.3);
            min-width: 300px;
        }

        .toast.success {
            border-left: 4px solid var(--success);
            box-shadow: var(--glow-green);
        }

        .toast.error {
            border-left: 4px solid var(--error);
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.3);
        }

        .toast.info {
            border-left: 4px solid var(--info);
            box-shadow: var(--glow-blue);
        }

        @keyframes toast-slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toast-slide-out {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: var(--space-md);
        }

        .toast-message {
            flex: 1;
            line-height: 1.4;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: var(--transition);
            flex-shrink: 0;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        /* Enhanced Custom Modal System */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
            animation: modal-fade-in 0.3s ease-out;
        }

        @keyframes modal-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: var(--bg-card);
            border: 2px solid var(--glass-border);
            border-radius: var(--radius-xl);
            padding: var(--space-2xl);
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: modal-slide-up 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
        }

        @keyframes modal-slide-up {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--glass-border);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--neon-blue);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: var(--space-sm);
            border-radius: var(--radius-sm);
            transition: var(--transition);
        }

        .modal-close:hover {
            color: var(--neon-red);
            background: rgba(255, 0, 64, 0.1);
        }

        .confirm-modal .modal {
            max-width: 400px;
        }

        .confirm-modal .modal-title {
            color: var(--neon-yellow);
            margin-bottom: var(--space-lg);
        }

        .confirm-modal .modal-message {
            color: var(--text-secondary);
            margin-bottom: var(--space-xl);
            line-height: 1.5;
        }

        .confirm-modal .modal-buttons {
            display: flex;
            gap: var(--space-lg);
            justify-content: flex-end;
        }

        /* Debug Panel Improvements */
        .debug-panel {
            grid-area: debug;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            margin-bottom: var(--space-lg); /* Ensure spacing from bottom */
        }

        .debug-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .debug-content.show {
            max-height: 500px;
        }

        .debug-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .debug-section h3 {
            color: var(--neon-purple);
            margin-bottom: var(--space-md);
            font-size: 1.125rem;
        }

        .json-viewer {
            background: var(--bg-black);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Enhanced Mobile Responsiveness */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "main"
                    "config"
                    "status"
                    "debug";
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .debug-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: var(--space-md) var(--space-md) var(--space-2xl); /* Extra bottom padding on mobile */
                gap: var(--space-md);
            }

            .header {
                padding: var(--space-lg);
                flex-direction: column;
                gap: var(--space-md);
            }

            .logo-icon {
                font-size: 2rem;
            }

            .logo-text h1 {
                font-size: 1.75rem;
            }

            .progress-container {
                width: 250px;
                height: 250px;
            }

            .progress-percentage {
                font-size: 2.25rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .control-panel {
                flex-direction: column;
                align-items: center;
            }

            .cyber-btn.large {
                width: 100%;
                max-width: 250px;
            }

            .security-grid {
                grid-template-columns: 1fr;
            }

            .theme-selector {
                gap: var(--space-md);
            }

            .btn-group {
                flex-direction: column;
            }

            .toast-container {
                top: var(--space-md);
                right: var(--space-md);
                left: var(--space-md);
                max-width: none;
            }

            .toast {
                min-width: auto;
                width: 100%;
            }

            .debug-panel {
                margin-bottom: var(--space-2xl);
            }
        }

        /* Loading States */
        .loading {
            display: inline-block;
            animation: loading-pulse 1.5s infinite;
        }

        @keyframes loading-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .loading-spinner {
            display: inline-block;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid var(--glass-border);
            border-radius: 50%;
            border-top-color: var(--neon-blue);
            animation: spin 1s ease-in-out infinite;
        }

        /* Accessibility Improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        [aria-live] {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Focus management */
        *:focus {
            outline: 2px solid var(--neon-blue);
            outline-offset: 2px;
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --glass-border: rgba(255, 255, 255, 0.8);
                --text-secondary: #FFFFFF;
                --text-dim: #CCCCCC;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div class="cyber-grid"></div>
    <div class="particle-container" id="particleContainer"></div>
    <div class="toast-container" id="toastContainer" role="status" aria-live="polite"></div>
    <div aria-live="polite" aria-atomic="true" class="sr-only" id="announcements"></div>
    
    <div class="container">
        <!-- Header -->
        <header class="header" role="banner">
            <div class="logo">
                <div class="logo-icon neon-text pink" tabindex="0" role="button" aria-label="CyberBackup Logo">‚ö°</div>
                <div class="logo-text">
                    <h1 class="neon-text pink">CYBERBACKUP PRO</h1>
                    <div class="subtitle">v3.0 (API Driven)</div>
                </div>
            </div>
            <div class="connection-status">
                <div class="status-led" id="connectionLed" aria-label="Connection status"></div>
                <span id="connectionText" style="font-weight: 600;">OFFLINE</span>
            </div>
        </header>

        <!-- Configuration Panel -->
        <aside class="config-panel glass-card" role="region" aria-label="Configuration">
            <div class="panel-header">
                <h2 class="panel-title">System Configuration</h2>
            </div>
            
            <div class="config-section">                <label class="config-label" for="serverInput">Server Address</label>
                <input type="text" class="config-input" id="serverInput" 
                       placeholder="127.0.0.1:1256" value="127.0.0.1:1256" aria-describedby="serverHelp">
                <div id="serverHelp" class="sr-only">Enter server IP address and port</div>
            </div>
            
            <div class="config-section">
                <label class="config-label" for="usernameInput">Username</label>
                <input type="text" class="config-input" id="usernameInput" 
                       placeholder="Enter username" value="testuser" maxlength="100" aria-describedby="usernameHelp">
                <div id="usernameHelp" class="sr-only">Username for authentication (max 100 characters)</div>
            </div>
            
            <div class="config-section">
                <label class="config-label">Target File</label>
                <div class="file-drop-zone" id="fileDropZone">
                    <input type="file" class="file-input" id="fileInput" 
                           aria-describedby="fileHelp" accept="*/*" 
                           title="Select a file to backup" 
                           aria-label="File selection for backup">
                    <div class="file-button">
                        üìÅ Select File to Backup
                        <span class="sr-only">or drag and drop a file here</span>
                    </div>
                </div>
                <div id="fileHelp" class="sr-only">Select a file for backup or drag and drop</div>
                <div class="config-value" id="selectedFile">No file selected</div>
                <div id="filePreview" class="file-preview-container" style="margin-top: var(--space-md); text-align: center; min-height: 60px; display: flex; align-items: center; justify-content: center;"></div>
            </div>
            
            <div class="config-section">
                <label class="config-label">Client ID</label>
                <div class="config-value" id="clientId">Not connected</div>
            </div>

            <div class="btn-group">
                <button class="cyber-btn success" data-action="save-config">üíæ Save Config</button>
            </div>

            <div class="panel-header" style="margin-top: var(--space-xl);">
                <h2 class="panel-title">Theme Selection</h2>
            </div>
            
            <div class="theme-selector">
                <button class="theme-btn cyberpunk active" 
                        aria-label="Cyberpunk theme" title="Cyberpunk Theme"></button>
                <button class="theme-btn dark" 
                        aria-label="Dark theme" title="Dark Theme"></button>
                <button class="theme-btn matrix" 
                        aria-label="Matrix theme" title="Matrix Theme"></button>
            </div>
        </aside>

        <!-- Main Panel -->
        <main class="main-panel glass-card" role="main">
            <div class="phase-display" id="currentPhase">
                <span class="neon-text purple">SYSTEM READY</span>
            </div>
            
            <div class="progress-container">
                <svg class="progress-ring" viewBox="0 0 300 300" role="img" aria-label="Transfer progress">
                    <defs>
                        <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:var(--neon-blue);stop-opacity:1" />
                            <stop offset="33%" style="stop-color:var(--neon-purple);stop-opacity:1" />
                            <stop offset="66%" style="stop-color:var(--neon-pink);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:var(--neon-green);stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <circle class="progress-bg" cx="150" cy="150" r="130" 
                            fill="none" stroke="var(--bg-light)" stroke-width="16"></circle>
                    <circle class="progress-fill" cx="150" cy="150" r="130" id="progressCircle"></circle>
                </svg>
                <div class="progress-text">
                    <div class="progress-percentage neon-text" id="progressPercentage">0%</div>
                    <div class="progress-label" id="progressStatus">READY</div>
                </div>
            </div>            <div class="control-panel">
                <button type="button" class="cyber-btn primary large control-btn" id="primaryAction">
                    <span class="btn-icon">üöÄ</span>
                    <span class="btn-text">CONNECT</span>
                </button>
                <button type="button" class="cyber-btn secondary large control-btn" id="pauseBtn" disabled>
                    <span class="btn-icon">‚è∏Ô∏è</span>
                    <span class="btn-text">PAUSE</span>
                </button>
                <button type="button" class="cyber-btn danger large control-btn" id="stopBtn" disabled>
                    <span class="btn-icon">üõë</span>
                    <span class="btn-text">STOP</span>
                </button>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="speedStat">0 B/s</div>
                    <div class="stat-label">Transfer Speed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="etaStat">--:--</div>
                    <div class="stat-label">ETA</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="transferredStat">0 B</div>
                    <div class="stat-label">Transferred</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="sizeStat">0 B</div>
                    <div class="stat-label">Total Size</div>
                </div>
            </div>
        </main>

        <!-- Status Panel -->
        <aside class="status-panel glass-card" role="region" aria-label="Operation log">
            <div class="panel-header">
                <h2 class="panel-title">Operation Log</h2>
                <div class="btn-group">
                    <button class="cyber-btn success small" data-action="export-log">üì• Export</button>
                    <button class="cyber-btn danger small" data-action="clear-log">üóëÔ∏è Clear</button>
                    <button type="button" class="cyber-btn primary small" id="autoScrollBtn">
                        üìú Auto-scroll: ON
                    </button>
                </div>
            </div>
            
            <div class="log-container" id="logContainer" role="log" aria-live="polite" aria-label="Activity log">
                <!-- Logs will be populated here -->
            </div>
        </aside>

        <!-- Debug Panel -->
        <div class="debug-panel glass-card" role="region" aria-label="Developer console">
            <div class="panel-header">
                <h2 class="panel-title">Developer Console</h2>
                <button type="button" class="cyber-btn primary small" id="debugToggle" 
                        aria-expanded="false">üîß Toggle Debug</button>
            </div>
            
            <div class="debug-content" id="debugContent">
                <div class="debug-grid">
                    <div class="debug-section">
                        <h3>üìä Last API Response</h3>
                        <div class="json-viewer" id="statusJsonViewer">Waiting for status data...</div>
                    </div>
                    <div class="debug-section">
                        <h3>üìà State Machine</h3>
                        <div class="json-viewer" id="progressJsonViewer">Waiting for state data...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Custom Confirmation Modal -->
    <div class="modal-overlay confirm-modal" id="confirmModal">
        <div class="modal">
            <h3 class="modal-title" id="confirmTitle">Confirm Action</h3>
            <p class="modal-message" id="confirmMessage">Are you sure?</p>
            <div class="modal-buttons">
                <button class="cyber-btn secondary" data-action="cancel-modal">Cancel</button>
                <button type="button" class="cyber-btn danger" id="confirmOkBtn">Confirm</button>
            </div>
        </div>
    </div>    <script>
        // === IMMEDIATE TEST ===
        alert('JavaScript is working! Script started loading...');
        console.log('JavaScript is working! Script started loading...');
        
        // === ENHANCED DEBUG LOGGING SYSTEM ===
        class DebugLogger {
            constructor() {
                this.levels = {
                    ERROR: { value: 0, color: '#ff0040', prefix: 'ERROR' },
                    WARN: { value: 1, color: '#ffff00', prefix: 'WARN' },
                    INFO: { value: 2, color: '#00ffff', prefix: 'INFO' },
                    DEBUG: { value: 3, color: '#00ff00', prefix: 'DEBUG' },
                    TRACE: { value: 4, color: '#888888', prefix: 'TRACE' }
                };
                
                this.currentLevel = this.levels.DEBUG; // Default level
                this.filters = new Set(); // Category filters
                this.debugDiv = null;
                this.isEnabled = true;
                this.maxEntries = 1000; // Prevent memory issues
                this.entries = [];
                
                // Load preferences from localStorage
                this.loadPreferences();
                
                // Setup keyboard shortcut for debug toggle
                this.setupKeyboardShortcuts();
            }

            setLevel(levelName) {
                if (this.levels[levelName]) {
                    this.currentLevel = this.levels[levelName];
                    this.savePreferences();
                    this.log('DEBUG', 'DEBUG', `Debug level set to ${levelName}`);
                }
            }

            addFilter(category) {
                this.filters.add(category.toUpperCase());
                this.savePreferences();
            }

            removeFilter(category) {
                this.filters.delete(category.toUpperCase());
                this.savePreferences();
            }

            clearFilters() {
                this.filters.clear();
                this.savePreferences();
            }

            toggle() {
                this.isEnabled = !this.isEnabled;
                if (this.debugDiv) {
                    this.debugDiv.style.display = this.isEnabled ? 'block' : 'none';
                }
                this.savePreferences();
            }

            log(level, category, message) {
                const levelObj = this.levels[level];
                if (!levelObj || !this.isEnabled) return;
                
                // Check level filtering
                if (levelObj.value > this.currentLevel.value) return;
                
                // Check category filtering
                if (this.filters.size > 0 && !this.filters.has(category.toUpperCase())) return;

                const timestamp = new Date().toLocaleTimeString();
                const entry = { timestamp, level, category, message, levelObj };
                
                // Add to entries array
                this.entries.push(entry);
                if (this.entries.length > this.maxEntries) {
                    this.entries.shift(); // Remove oldest entry
                }

                // Console logging
                const consoleMessage = `[${levelObj.prefix}] [${category}] ${message}`;
                switch (level) {
                    case 'ERROR': console.error(consoleMessage); break;
                    case 'WARN': console.warn(consoleMessage); break;
                    case 'INFO': console.info(consoleMessage); break;
                    default: console.log(consoleMessage); break;
                }

                // Visual debug div
                this.updateDebugDiv(entry);
            }

            updateDebugDiv(entry) {
                if (!this.debugDiv) {
                    this.debugDiv = this.createDebugDiv();
                }

                const entryDiv = document.createElement('div');
                entryDiv.style.cssText = `color: ${entry.levelObj.color}; margin-bottom: 2px; font-size: 11px; line-height: 1.2;`;
                entryDiv.innerHTML = `<span style="color: #666;">[${entry.timestamp}]</span> <span style="color: ${entry.levelObj.color}; font-weight: bold;">[${entry.levelObj.prefix}]</span> <span style="color: #ccc;">[${entry.category}]</span> ${entry.message}`;
                
                this.debugDiv.appendChild(entryDiv);
                
                // Auto-scroll to bottom
                this.debugDiv.scrollTop = this.debugDiv.scrollHeight;
                
                // Limit entries in DOM
                if (this.debugDiv.children.length > 200) {
                    this.debugDiv.removeChild(this.debugDiv.firstChild);
                }
            }

            createDebugDiv() {
                const div = document.createElement('div');
                div.id = 'debug-output';
                div.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    width: 450px;
                    height: 300px;
                    background: rgba(0, 0, 0, 0.95);
                    color: #00ff00;
                    padding: 10px;
                    border: 2px solid #00ffff;
                    border-radius: 8px;
                    overflow-y: auto;
                    z-index: 9999;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    -webkit-backdrop-filter: blur(10px);
                    backdrop-filter: blur(10px);
                    display: ${this.isEnabled ? 'block' : 'none'};
                `;
                
                // Add header with controls
                const header = document.createElement('div');
                header.style.cssText = 'position: sticky; top: 0; background: rgba(0, 0, 0, 0.9); padding: 5px 0; border-bottom: 1px solid #00ffff; margin-bottom: 5px;';
                header.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #00ffff; font-weight: bold;">Debug Console</span>
                        <div>
                            <button onclick="debugLogger.clearEntries()" style="background: none; border: 1px solid #00ffff; color: #00ffff; padding: 2px 6px; font-size: 10px; cursor: pointer;">Clear</button>
                            <button onclick="debugLogger.toggle()" style="background: none; border: 1px solid #ff0040; color: #ff0040; padding: 2px 6px; font-size: 10px; cursor: pointer;">√ó</button>
                        </div>
                    </div>
                `;
                
                div.appendChild(header);
                document.body.appendChild(div);
                return div;
            }

            clearEntries() {
                this.entries = [];
                if (this.debugDiv) {
                    // Keep only the header
                    const header = this.debugDiv.firstChild;
                    this.debugDiv.innerHTML = '';
                    this.debugDiv.appendChild(header);
                }
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ctrl+Shift+D toggles debug console
                    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                        e.preventDefault();
                        this.toggle();
                    }
                });
            }

            savePreferences() {
                const prefs = {
                    level: Object.keys(this.levels).find(key => this.levels[key] === this.currentLevel),
                    filters: Array.from(this.filters),
                    enabled: this.isEnabled
                };
                localStorage.setItem('cyberbackup_debug_prefs', JSON.stringify(prefs));
            }

            loadPreferences() {
                try {
                    const saved = localStorage.getItem('cyberbackup_debug_prefs');
                    if (saved) {
                        const prefs = JSON.parse(saved);
                        if (prefs.level && this.levels[prefs.level]) {
                            this.currentLevel = this.levels[prefs.level];
                        }
                        if (prefs.filters) {
                            this.filters = new Set(prefs.filters);
                        }
                        if (typeof prefs.enabled === 'boolean') {
                            this.isEnabled = prefs.enabled;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load debug preferences:', error);
                }
            }

            getStatus() {
                return {
                    level: Object.keys(this.levels).find(key => this.levels[key] === this.currentLevel),
                    filters: Array.from(this.filters),
                    enabled: this.isEnabled,
                    entryCount: this.entries.length
                };
            }
        }

        // Create global debug logger instance
        const debugLogger = new DebugLogger();

        // Backward compatibility function
        function debugLog(message, category = 'GENERAL') {
            debugLogger.log('DEBUG', category, message);
        }

        debugLog('=== SCRIPT LOADING STARTED ===');

        /**
         * =================================================================
         * API-DRIVEN CLIENT GUI v3.0
         * =================================================================
         * This version has been refactored to communicate with a local
         * C++ web server (via Boost.Beast) instead of a file-based system.
         * The GUI now acts as a true frontend to the C++ backend.
         * =================================================================
         */

        // Interval Manager to prevent leaks
        debugLog('Defining IntervalManager class...');
        class IntervalManager {
            constructor() {
                this.intervals = new Map();
            }
            set(name, callback, delay) {
                this.clear(name);
                this.intervals.set(name, setInterval(callback, delay));
            }
            clear(name) {
                if (this.intervals.has(name)) {
                    clearInterval(this.intervals.get(name));
                    this.intervals.delete(name);
                }
            }
            clearAll() {
                this.intervals.forEach(id => clearInterval(id));
                this.intervals.clear();
            }        }
        debugLog('IntervalManager class defined successfully');

        /**
         * NEW: ApiClient
         * Handles all communication with the local C++ web server.
         */
        debugLog('Defining ApiClient class...');
        class ApiClient {
            constructor(baseUrl = 'http://127.0.0.1:9090') {
                this.baseUrl = baseUrl;
            }

            async _request(endpoint, options = {}) {
                try {
                    console.log(`Making ${options.method || 'GET'} request to: ${this.baseUrl}${endpoint}`);
                    if (options.body) {
                        console.log('Request body:', options.body);
                        debugLog(`API: ${options.method || 'GET'} ${endpoint} with body: ${options.body}`);
                    }
                    const response = await fetch(`${this.baseUrl}${endpoint}`, options);
                    console.log('Response status:', response.status, response.statusText);
                    debugLog(`API: Response status: ${response.status} ${response.statusText}`);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: response.statusText }));
                        console.error('API Error data:', errorData);
                        debugLog(`API ERROR: ${JSON.stringify(errorData)}`);
                        throw new Error(`API Error: ${errorData.message || 'Unknown Error'}`);
                    }
                    const responseData = await response.json();
                    console.log('Response data:', responseData);
                    debugLog(`API: Response data: ${JSON.stringify(responseData)}`);
                    return responseData;
                } catch (err) {
                    // This catches network errors (e.g., C++ client not running) or API errors
                    console.error(`API request to ${endpoint} failed:`, err);
                    debugLog(`API NETWORK ERROR: ${err.message}`);
                    throw err; // Re-throw to be handled by the calling function
                }
            }

            getStatus() {
                return this._request('/api/status');
            }

            connect(config) {
                console.log('ApiClient.connect() called with:', config);
                debugLog('API: Making POST request to /api/connect');
                return this._request('/api/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
            }

            startBackup(file, username = 'testuser') {
                // Create FormData to send the actual file
                const formData = new FormData();
                formData.append('file', file);
                formData.append('username', username);
                
                console.log('ApiClient.startBackup() called with file:', file.name, 'size:', file.size);
                debugLog('API: Making multipart/form-data POST request to /api/start_backup');
                
                // Send FormData (no Content-Type header needed - browser sets it automatically with boundary)
                return this._request('/api/start_backup', {
                    method: 'POST',
                    body: formData
                });
            }            stop() { return this._request('/api/stop', { method: 'POST' }); }
            pause() { return this._request('/api/pause', { method: 'POST' }); }
            resume() { return this._request('/api/resume', { method: 'POST' }); }
        }
        debugLog('ApiClient class defined successfully');

        // Configuration Manager (largely unchanged)        
        debugLog('Defining ConfigManager class...');
        class ConfigManager {
            constructor() {
                this.config = {
                    server: '127.0.0.1',
                    port: 1256,
                    username: 'testuser', // Default username for testing
                    filepath: 'test.txt', // Default file for testing
                };
            }
            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('cyberbackup_config');
                    if (saved) {
                        this.config = { ...this.config, ...JSON.parse(saved) };
                    }
                } catch (error) {
                    console.warn('Invalid config in localStorage.');
                    localStorage.removeItem('cyberbackup_config');
                }
            }
            saveToStorage() {
                localStorage.setItem('cyberbackup_config', JSON.stringify(this.config));
            }            validate() {
                const errors = [];
                if (!this.config.server || !this.config.port) errors.push('Server address and port are required');
                if (!this.config.username) errors.push('Username is required');
                if (!this.config.filepath) errors.push('A file must be selected');
                return errors;
            }
        }
        debugLog('ConfigManager class defined successfully');

        // UI Controller Classes (moved here to fix initialization order)
        debugLog('Defining UIController class...');
        class UIController {
            createLogEntry(log) { 
                const entry = document.createElement('div');
                entry.className = `log-entry ${log.type}`;
                const icon = log.type === 'success' ? '‚úì' : log.type === 'error' ? '‚úó' : log.type === 'warning' ? '‚ö†' : '‚Ñπ';
                entry.innerHTML = `<span class="log-timestamp">${log.timestamp}</span><div class="log-icon ${log.type}">${icon}</div><div class="log-content"><div class="log-message">${log.operation}</div><div class="log-details">${log.details || ''}</div></div>`;
                return entry;
             }
            updateProgressRing(p) { 
                const circle = document.getElementById('progressCircle');
                if (!circle || !p) return;
                if (!circle.getAttribute('data-circumference')) {
                    const radius = parseFloat(circle.getAttribute('r'));
                    circle.setAttribute('data-circumference', 2 * Math.PI * radius);
                }
                const circumference = circle.getAttribute('data-circumference');
                circle.style.strokeDasharray = circumference;
                circle.style.strokeDashoffset = circumference - (p / 100) * circumference;
            }
            showFilePreview(file) { /* Basic implementation */ }
            getFileIcon(type) { return 'üìÅ'; }
        }
        debugLog('UIController class defined successfully');

        // Enhanced UI Controller with better visual feedback
        debugLog('Defining EnhancedUIController class...');
        class EnhancedUIController extends UIController {
            constructor() {
                super();
                this.animationId = null;
            }

            createLogEntry(log) { 
                const entry = document.createElement('div');
                entry.className = `log-entry ${log.type}`;
                entry.setAttribute('tabindex', '0');
                entry.setAttribute('role', 'listitem');
                
                const icon = log.type === 'success' ? '‚úì' : log.type === 'error' ? '‚úó' : log.type === 'warning' ? '‚ö†' : '‚Ñπ';
                entry.innerHTML = `
                    <span class="log-timestamp">${log.timestamp}</span>
                    <div class="log-icon ${log.type}">${icon}</div>
                    <div class="log-content">
                        <div class="log-message">${log.operation}</div>
                        ${log.details ? `<div class="log-details">${log.details}</div>` : ''}
                    </div>
                `;

                // Add entrance animation
                entry.style.opacity = '0';
                entry.style.transform = 'translateX(-20px)';
                
                requestAnimationFrame(() => {
                    entry.style.transition = 'all 0.3s ease-out';
                    entry.style.opacity = '1';
                    entry.style.transform = 'translateX(0)';
                });

                return entry;
            }

            updateProgressRing(percentage) { 
                const circle = document.getElementById('progressCircle');
                const ring = document.querySelector('.progress-ring');
                
                if (!circle) return;

                if (!circle.getAttribute('data-circumference')) {
                    const radius = parseFloat(circle.getAttribute('r'));
                    const circumference = 2 * Math.PI * radius;
                    circle.setAttribute('data-circumference', circumference);
                    circle.style.strokeDasharray = circumference;
                }
                
                const circumference = parseFloat(circle.getAttribute('data-circumference'));
                const offset = circumference - (percentage / 100) * circumference;
                
                // Animate the progress change
                circle.style.transition = 'stroke-dashoffset 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
                circle.style.strokeDashoffset = offset;

                // Add glow effect when progress is active
                if (ring) {
                    if (percentage > 0 && percentage < 100) {
                        ring.classList.add('active');
                    } else {
                        ring.classList.remove('active');
                    }
                }
            }

            showFilePreview(file) {
                const previewContainer = document.getElementById('filePreview');
                if (!previewContainer) return;

                previewContainer.innerHTML = '';
                
                if (file.type.startsWith('image/')) {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.style.maxWidth = '100px';
                    img.style.maxHeight = '100px';
                    img.style.borderRadius = '8px';
                    previewContainer.appendChild(img);
                } else {
                    const icon = this.getFileIcon(file.type || file.name);
                    previewContainer.innerHTML = `<div class="file-icon-large">${icon}</div>`;
                }
            }

            getFileIcon(typeOrName) {
                const type = typeOrName.toLowerCase();
                if (type.includes('image/') || type.endsWith('.jpg') || type.endsWith('.png') || type.endsWith('.gif')) return 'üñºÔ∏è';
                if (type.includes('video/') || type.endsWith('.mp4') || type.endsWith('.avi') || type.endsWith('.mov')) return 'üé•';
                if (type.includes('audio/') || type.endsWith('.mp3') || type.endsWith('.wav')) return 'üéµ';
                if (type.includes('text/') || type.endsWith('.txt') || type.endsWith('.md')) return 'üìÑ';
                if (type.endsWith('.pdf')) return 'üìï';
                if (type.endsWith('.zip') || type.endsWith('.rar') || type.endsWith('.7z')) return 'üóúÔ∏è';
                if (type.endsWith('.exe') || type.endsWith('.msi')) return '‚öôÔ∏è';
                return 'üìÅ';
            }
        }
        debugLog('EnhancedUIController class defined successfully');

        // Browser Notification Manager
        debugLog('Defining BrowserNotificationManager class...');
        class BrowserNotificationManager {
            constructor() {
                this.supported = 'Notification' in window;
                this.permission = this.supported ? Notification.permission : 'denied';
                this.requestPermissionOnInit();
            }

            async requestPermissionOnInit() {
                if (this.supported && this.permission === 'default') {
                    try {
                        this.permission = await Notification.requestPermission();
                    } catch (error) {
                        console.warn('Could not request notification permission:', error);
                    }
                }
            }

            show(title, message, options = {}) {
                // Show toast notification in GUI
                if (window.gui) {
                    window.gui.showToast(`${title}: ${message}`, options.type || 'info');
                }

                // Show browser notification if supported and permitted
                if (this.supported && this.permission === 'granted') {
                    const notification = new Notification(title, {
                        body: message,
                        icon: options.icon || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><text y="18" font-size="20">üöÄ</text></svg>',
                        badge: options.badge || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><text y="18" font-size="20">üîí</text></svg>',
                        requireInteraction: options.requireInteraction || false,
                        silent: options.silent || false
                    });

                    // Auto-close after 5 seconds unless persistent
                    if (!options.persistent) {
                        setTimeout(() => notification.close(), 5000);
                    }

                    return notification;
                }

                return null;
            }

            showConnectionStatus(connected) {
                const title = connected ? 'Backup Client Connected' : 'Backup Client Disconnected';
                const message = connected ? 'Successfully connected to backup server' : 'Lost connection to backup server';
                this.show(title, message, { 
                    type: connected ? 'success' : 'error',
                    requireInteraction: !connected
                });
            }

            showBackupComplete(filename, success) {
                const title = success ? 'Backup Completed' : 'Backup Failed';
                const message = success ? `Successfully backed up ${filename}` : `Failed to backup ${filename}`;
                this.show(title, message, { 
                    type: success ? 'success' : 'error',
                    requireInteraction: !success
                });
            }

            showProgress(percentage, filename) {
                if (percentage === 25 || percentage === 50 || percentage === 75) {
                    this.show('Backup Progress', `${filename} - ${percentage}% complete`, {
                        type: 'info',
                        silent: true
                    });
                }
            }
        }
        debugLog('BrowserNotificationManager class defined successfully');

        // Enhanced File Manager with modern APIs
        debugLog('Defining EnhancedFileManager class...');
        class EnhancedFileManager {
            constructor() {
                this.supportsFileSystemAccess = 'showOpenFilePicker' in window;
                this.supportsDragDrop = true;
            }

            async selectFile() {
                if (this.supportsFileSystemAccess) {
                    try {
                        const [fileHandle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'All files',
                                accept: { '*/*': [] }
                            }],
                            excludeAcceptAllOption: false,
                            multiple: false
                        });
                        
                        const file = await fileHandle.getFile();
                        return file;
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            console.warn('File picker error:', error);
                        }
                        return null;
                    }
                } else {
                    // Fallback to traditional file input
                    return new Promise((resolve) => {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.onchange = () => resolve(input.files[0] || null);
                        input.click();
                    });
                }
            }

            setupDragAndDrop(dropZone, onFileSelected) {
                if (!this.supportsDragDrop) return;

                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });

                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                });

                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    
                    const files = Array.from(e.dataTransfer.files);
                    if (files.length > 0) {
                        onFileSelected(files[0]);
                    }
                });
            }
        }
        debugLog('EnhancedFileManager class defined successfully');

        // System Integration Manager
        debugLog('Defining SystemIntegrationManager class...');
        class SystemIntegrationManager {
            constructor() {
                this.notifications = new BrowserNotificationManager();
                this.fileManager = new EnhancedFileManager();
                this.visibility = document.visibilityState;
                this.setupVisibilityTracking();
            }

            setupVisibilityTracking() {
                document.addEventListener('visibilitychange', () => {
                    this.visibility = document.visibilityState;
                });
            }

            isWindowVisible() {
                return this.visibility === 'visible';
            }

            notifyIfHidden(title, message, options = {}) {
                if (!this.isWindowVisible()) {
                    this.notifications.show(title, message, { ...options, requireInteraction: true });
                }
            }

            // Keyboard shortcuts
            setupKeyboardShortcuts(gui) {
                document.addEventListener('keydown', (e) => {
                    // Ctrl+O: Open file
                    if (e.ctrlKey && e.key === 'o') {
                        e.preventDefault();
                        gui.selectFile();
                    }
                    
                    // Ctrl+Enter: Start backup
                    if (e.ctrlKey && e.key === 'Enter') {
                        e.preventDefault();
                        gui.handlePrimaryAction();
                    }
                    
                    // Escape: Stop operation
                    if (e.key === 'Escape' && gui.state.isRunning) {
                        e.preventDefault();
                        gui.stopOperation();
                    }
                    
                    // Ctrl+,: Open settings (future feature)
                    if (e.ctrlKey && e.key === ',') {
                        e.preventDefault();
                        // gui.showSettings();
                    }
                });
            }
        }
        debugLog('SystemIntegrationManager class defined successfully');

        // Main Application Class (Refactored for API communication)
        debugLog('Defining CyberBackupPro class...');
        class CyberBackupPro {
            constructor() {
                this.api = new ApiClient();
                this.config = new ConfigManager();
                this.intervals = new IntervalManager();
                this.ui = new EnhancedUIController(); // Use enhanced UI controller
                this.system = new SystemIntegrationManager(); // Add system integration

                this.state = {
                    isConnecting: false, // NEW: Tracks the connection attempt itself
                    isConnected: false,  // Is the C++ client connected to the remote server
                    isRunning: false,
                    isPaused: false,
                    clientId: null,
                    currentPhase: 'SYSTEM_READY',
                    logs: [],
                    progress: {},
                    debugVisible: false,
                    autoScroll: true,
                    selectedFile: null
                };

                // State management for preventing race conditions
                this.stateManagement = {
                    isPolling: false,
                    isUpdatingUI: false,
                    lastPollTime: 0,
                    pollCooldown: 500, // Minimum time between polls in ms
                    uiUpdateQueue: [],
                    updateUIDebounced: this.debounce(() => this._updateAllUI(), 100)
                };
                
                this.pendingConfirmAction = null;
                
                this.init();
            }

            // Utility function for debouncing
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            async init() {
                console.log('üöÄ CyberBackup Pro v3.0 (API Driven) Initializing...');
                this.config.loadFromStorage();
                this.updateConfigDisplay();
                this.setupEventListeners();
                this.ui = new EnhancedUIController(); // Use enhanced UI controller
                this.theme = new ThemeManager(); // assuming ThemeManager exists
                this.theme.loadSavedTheme();
                this.system.setupKeyboardShortcuts(this); // Add keyboard shortcuts

                // Start master status polling
                this.intervals.set('statusPoll', () => this.pollStatus(), 1000);
                this.addLog('System Initialized', 'success', 'Ready to connect to C++ client.');
                this.system.notifications.show('CyberBackup Pro', 'Application ready', { type: 'info', silent: true });
                
                try {
                    // Initialize with enhanced file drop zone
                    const dropZone = document.querySelector('.file-drop-zone');
                    if (dropZone) {
                        this.system.fileManager.setupDragAndDrop(dropZone, (file) => {
                            this.handleFileSelection({ target: { files: [file] } });
                        });
                    }
                } catch (error) {
                    console.warn('Could not setup enhanced file handling:', error);
                }
            }

            setupEventListeners() {
                try {
                    // Configuration inputs with validation
                    const serverInput = document.getElementById('serverInput');
                    const usernameInput = document.getElementById('usernameInput');
                    const fileInput = document.getElementById('fileInput');
                    const fileButton = document.querySelector('.file-button');
                    
                    if (serverInput) {
                        serverInput.addEventListener('input', (e) => {
                            this.updateServerConfig(e.target.value);
                            this.validateAndUpdateUI();
                        });
                    }
                    
                    if (usernameInput) {
                        usernameInput.addEventListener('input', (e) => {
                            this.config.config.username = e.target.value;
                            this.validateAndUpdateUI();
                        });
                    }
                    
                    // File input event listener
                    if (fileInput) {
                        fileInput.addEventListener('change', (e) => this.handleFileSelection(e));
                    }
                    
                    // File button click handler (replace onclick)
                    if (fileButton) {
                        fileButton.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.selectFile();
                        });
                    }

                    // Configuration buttons
                    this.setupButton('.cyber-btn.success[data-action="save-config"]', () => this.saveConfiguration());
                    
                    // Theme buttons
                    this.setupButton('.theme-btn.cyberpunk', () => this.setTheme('cyberpunk'));
                    this.setupButton('.theme-btn.dark', () => this.setTheme('dark'));
                    this.setupButton('.theme-btn.matrix', () => this.setTheme('matrix'));
                    
                    // Control buttons
                    this.setupButton('#primaryAction', () => this.handlePrimaryAction());
                    this.setupButton('#pauseBtn', () => this.pauseOperation());
                    this.setupButton('#stopBtn', () => this.stopOperation());
                    
                    // Log buttons
                    this.setupButton('.cyber-btn.success.small[data-action="export-log"]', () => this.exportLog());
                    this.setupButton('.cyber-btn.danger.small[data-action="clear-log"]', () => this.clearLog());
                    this.setupButton('#autoScrollBtn', () => this.toggleAutoScroll());
                    
                    // Debug button
                    this.setupButton('#debugToggle', () => this.toggleDebug());
                    
                    // Modal buttons
                    this.setupButton('.cyber-btn.secondary[data-action="cancel-modal"]', () => this.hideConfirmModal());
                    this.setupButton('#confirmOkBtn', () => this.confirmAction());
                    
                    debugLog('EVENT: All event listeners setup successfully');
                } catch (error) {
                    debugLog('EVENT ERROR: Failed to setup event listeners: ' + error.message);
                }
            }

            // Helper method to setup button event listeners safely
            setupButton(selector, handler) {
                const element = document.querySelector(selector);
                if (element) {
                    element.addEventListener('click', (e) => {
                        e.preventDefault();
                        handler();
                    });
                    debugLog('EVENT: Setup listener for ' + selector);
                } else {
                    debugLog('EVENT WARNING: Element not found for selector: ' + selector);
                }
            }
            
            // Enhanced Master Polling Function with Race Condition Protection
            async pollStatus() {
                // Prevent concurrent polls
                if (this.stateManagement.isPolling) {
                    debugLog('POLL: Skipping poll - already in progress');
                    return;
                }

                // Respect cooldown period
                const now = Date.now();
                if (now - this.stateManagement.lastPollTime < this.stateManagement.pollCooldown) {
                    debugLog('POLL: Skipping poll - in cooldown period');
                    return;
                }

                this.stateManagement.isPolling = true;
                this.stateManagement.lastPollTime = now;

                try {
                    debugLog('POLL: Starting status poll...');
                    const status = await this.api.getStatus();
                    debugLog('POLL: Status received: ' + JSON.stringify(status));
                    
                    // Batch state updates to prevent partial state inconsistencies
                    const newState = {
                        isConnected: status.connected === "true" || status.connected === true,
                        isRunning: status.isRunning,
                        isPaused: status.isPaused,
                        currentPhase: status.phase,
                        clientId: status.client_id
                    };

                    // Check if state actually changed to avoid unnecessary UI updates
                    const stateChanged = (
                        this.state.isConnected !== newState.isConnected ||
                        this.state.isRunning !== newState.isRunning ||
                        this.state.isPaused !== newState.isPaused ||
                        this.state.currentPhase !== newState.currentPhase ||
                        this.state.clientId !== newState.clientId
                    );

                    // Apply state changes atomically
                    Object.assign(this.state, newState);

                    // Clear connecting flag if we got a successful response
                    if (this.state.isConnecting) {
                        this.state.isConnecting = false;
                        stateChanged = true;
                    }

                    debugLog('POLL: State updated - connected: ' + this.state.isConnected + ', changed: ' + stateChanged);

                    // Handle additional data
                    if (status.progress) this.updateProgress(status.progress);
                    if (status.log) this.addLog(status.log.operation, status.log.success ? 'success' : 'error', status.log.details);
                    
                    // Only update UI if state actually changed
                    if (stateChanged) {
                        this.stateManagement.updateUIDebounced();
                    }

                } catch (error) {
                    debugLog('POLL ERROR: ' + error.message);
                    // Handle offline state - only update if actually changing
                    const wasConnected = this.state.isConnected || this.state.isConnecting;
                    
                    this.state.isConnecting = false;
                    this.state.isConnected = false;
                    this.state.isRunning = false;
                    
                    // Only update UI if we were previously connected
                    if (wasConnected) {
                        this.stateManagement.updateUIDebounced();
                    }
                } finally {
                    this.stateManagement.isPolling = false;
                }
            }

            // Public UI Update Function (uses debouncing)
            updateAllUI() {
                this.stateManagement.updateUIDebounced();
            }

            // Private UI Update Function (actual implementation)
            _updateAllUI() {
                // Prevent concurrent UI updates
                if (this.stateManagement.isUpdatingUI) {
                    debugLog('UI: Skipping UI update - already in progress');
                    return;
                }

                this.stateManagement.isUpdatingUI = true;
                
                try {
                    debugLog('UI: Starting UI update...');
                    this.updateConnectionStatus();
                    this.updateControlButtons();
                    this.updatePhase(this.state.currentPhase);
                    this.updateClientIdDisplay();
                    
                    if (this.state.debugVisible) {
                        const statusViewer = document.getElementById('statusJsonViewer');
                        const progressViewer = document.getElementById('progressJsonViewer');
                        if (statusViewer) statusViewer.textContent = JSON.stringify(this.state, null, 2);
                        if (progressViewer) progressViewer.textContent = JSON.stringify(this.state.progress, null, 2);
                    }
                    
                    debugLog('UI: UI update completed');
                } catch (error) {
                    debugLog('UI ERROR: ' + error.message);
                } finally {
                    this.stateManagement.isUpdatingUI = false;
                }
            }

            // REFACTORED: Action Handlers now call the API           
               async handlePrimaryAction() {
                console.log('Primary action clicked');
                console.log('Current state:', this.state);
                console.log('Current config:', this.config.config);
                
                if (!this.validateAndUpdateUI()) {
                    console.log('Validation failed');
                    const errors = this.config.validate();
                    console.log('Validation errors:', errors);
                    this.showToast('Please fill in all required fields: ' + errors.join(', '), 'error');
                    return;
                }
                
                console.log('Validation passed');
                if (this.state.isRunning && this.state.isPaused) await this.resumeOperation();
                else if (!this.state.isConnected) await this.connectToServer();
                else if (!this.state.isRunning) await this.startBackup();
            }

            async connectToServer() {
                debugLog('CONNECT: Starting connection attempt...');
                
                // Prevent multiple simultaneous connection attempts
                if (this.state.isConnecting) {
                    debugLog('CONNECT: Connection already in progress, ignoring request');
                    return;
                }
                
                this.state.isConnecting = true;
                this.updateAllUI(); // Immediately show "Connecting..."
                
                try {
                    debugLog('CONNECT: Sending config to API: ' + JSON.stringify(this.config.config));
                    const response = await this.api.connect(this.config.config);
                    debugLog('CONNECT: API response received: ' + JSON.stringify(response));
                    
                    this.addLog('Connect command sent', 'info', `Awaiting response from ${this.config.config.server}`);
                    debugLog('CONNECT: Command sent successfully');
                    
                    // The regular polling will handle state updates - no need for immediate poll
                    // This prevents race conditions with the main polling loop
                    
                } catch (error) {
                    debugLog('CONNECT ERROR: ' + error.message);
                    this.state.isConnecting = false;
                    this.updateAllUI();
                    this.showToast('Failed to send connect command. Is the C++ client running?', 'error');
                    this.addLog('Connection failed', 'error', error.message);
                }
            }

            async startBackup() {
                try {
                    // Check if a file is selected
                    if (!this.state.selectedFile) {
                        this.showToast('No file selected for backup.', 'error');
                        return;
                    }
                    
                    // Get username from config
                    const username = this.config.config.username || 'testuser';
                    
                    // Send the actual file for upload
                    await this.api.startBackup(this.state.selectedFile, username);
                    this.addLog('File backup started', 'success', `Uploading ${this.state.selectedFile.name}`);
                } catch (error) {
                    console.error('Backup start error:', error);
                    this.showToast('Failed to start backup: ' + error.message, 'error');
                }
            }
            
            async pauseOperation() { try { await this.api.pause(); } catch(e) { this.showToast('Failed to send pause command', 'error'); } }
            async resumeOperation() { try { await this.api.resume(); } catch(e) { this.showToast('Failed to send resume command', 'error'); } }
            
            stopOperation() {
                this.showConfirmModal('Stop Operation', 'Are you sure?', () => this.executeStop());
            }

            async executeStop() {
                try {
                    await this.api.stop();
                } catch (e) {
                    this.showToast('Failed to send stop command', 'error');
                }
            }

            // REFACTORED: UI Update Functions now read from this.state
            updateConnectionStatus() {
                console.log('updateConnectionStatus() called - state:', this.state);
                debugLog('UI: Updating connection status - connected: ' + this.state.isConnected + ', connecting: ' + this.state.isConnecting);
                
                const led = document.getElementById('connectionLed');
                const text = document.getElementById('connectionText');
                
                if (!led || !text) {
                    console.error('Connection status elements not found!');
                    debugLog('UI ERROR: Connection status elements not found');
                    return;
                }
                
                led.classList.remove('connected', 'connecting');

                if (this.state.isConnecting) {
                    led.classList.add('connecting');
                    text.textContent = 'CONNECTING...';
                    console.log('UI: Set to CONNECTING...');
                    debugLog('UI: Connection status set to CONNECTING');
                } else if (this.state.isConnected) {
                    led.classList.add('connected');
                    text.textContent = 'ONLINE';
                    console.log('UI: Set to ONLINE');
                    debugLog('UI: Connection status set to ONLINE');
                    // Show notification when connected
                    this.system.notifications.showConnectionStatus(true);
                } else {
                    text.textContent = 'OFFLINE';
                    console.log('UI: Set to OFFLINE');
                    debugLog('UI: Connection status set to OFFLINE');
                    // Show notification when disconnected (but not on initial load)
                    if (this.state.clientId) { // Only if we were previously connected
                        this.system.notifications.showConnectionStatus(false);
                    }
                }
            }

            updateControlButtons() {
                const primaryBtn = document.getElementById('primaryAction');
                const pauseBtn = document.getElementById('pauseBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                const primaryIcon = primaryBtn.querySelector('.btn-icon');
                const primaryText = primaryBtn.querySelector('.btn-text');
                
                primaryBtn.disabled = false; // Enable by default, disable in specific cases
                pauseBtn.disabled = true;
                stopBtn.disabled = true;

                if (this.state.isConnecting) {
                    primaryBtn.disabled = true;
                    primaryText.textContent = 'CONNECTING';
                } else if (this.state.isRunning) {
                    if (this.state.isPaused) {
                        primaryIcon.textContent = '‚ñ∂Ô∏è';
                        primaryText.textContent = 'RESUME';
                    } else {
                        primaryBtn.disabled = true;
                        primaryIcon.textContent = 'üîó';
                        primaryText.textContent = 'TRANSFERRING';
                        pauseBtn.disabled = false;
                    }
                    stopBtn.disabled = false;
                } else if (this.state.isConnected) {
                    primaryIcon.textContent = 'üöÄ';
                    primaryText.textContent = 'START BACKUP';
                    if (!this.state.selectedFile) primaryBtn.disabled = true;
                    stopBtn.disabled = false;
                } else { // Offline
                    primaryIcon.textContent = 'üöÄ';
                    primaryText.textContent = 'CONNECT';
                    if (!this.validateAndUpdateUI()) primaryBtn.disabled = true;
                }

                // Lock/unlock config panel
                const panel = document.querySelector('.config-panel');
                const inputs = panel.querySelectorAll('input, button');
                const isBusy = this.state.isConnecting || this.state.isRunning;
                panel.style.opacity = isBusy ? '0.6' : '1';
                inputs.forEach(input => input.disabled = isBusy);
            }

            updateProgress(data) {
                // This function is now just for rendering progress data from the state
                this.state.progress = data;
                const percentage = data.percentage || 0;
                this.ui.updateProgressRing(percentage);
                document.getElementById('progressPercentage').textContent = Math.round(percentage) + '%';
                document.getElementById('speedStat').textContent = data.speed || '0 B/s';
                document.getElementById('etaStat').textContent = data.eta || '--:--';
                document.getElementById('transferredStat').textContent = this.formatBytes(data.transferred || 0);
                
                // Show progress notifications at key milestones
                if (this.state.selectedFile) {
                    this.system.notifications.showProgress(Math.round(percentage), this.state.selectedFile.name);
                }
            }
            
            updateClientIdDisplay() {
                const clientIdEl = document.getElementById('clientId');
                if (this.state.clientId) {
                    clientIdEl.textContent = this.state.clientId.substring(0, 8) + '...';
                    clientIdEl.title = this.state.clientId;
                } else {
                    clientIdEl.textContent = 'Not connected';
                }
            }
            
            // Other functions (logging, modals, etc.) remain largely the same...
            addLog(operation, type, details) {
                const timestamp = new Date().toLocaleTimeString();
                const log = { timestamp, operation, type, details, id: Date.now() + Math.random() };
                this.state.logs.push(log);
                const logContainer = document.getElementById('logContainer');
                const entry = this.ui.createLogEntry(log); // Assumes UIController.createLogEntry exists
                logContainer.appendChild(entry);
                if (this.state.autoScroll) {
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
                if (logContainer.children.length > 200) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }

            showToast(message, type = 'info') {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                
                const content = document.createElement('div');
                content.className = 'toast-content';
                
                const messageEl = document.createElement('div');
                messageEl.className = 'toast-message';
                messageEl.textContent = message;
                
                const closeBtn = document.createElement('button');
                closeBtn.className = 'toast-close';
                closeBtn.textContent = '√ó';
                closeBtn.addEventListener('click', () => {
                    if (container.contains(toast)) {
                        toast.style.animation = 'toast-slide-out 0.3s forwards';
                        setTimeout(() => toast.remove(), 300);
                    }
                });
                
                content.appendChild(messageEl);
                content.appendChild(closeBtn);
                toast.appendChild(content);
                container.appendChild(toast);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (container.contains(toast)) {
                        toast.style.animation = 'toast-slide-out 0.3s forwards';
                        setTimeout(() => toast.remove(), 300);
                    }
                }, 5000);
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

             // ... [The rest of the helper functions: clearLog, exportLog, modal handlers, file handlers, etc.]
            updateServerConfig(value) {
                const parts = value.split(':');
                this.config.config.server = parts[0] || '';
                this.config.config.port = parseInt(parts[1]) || 1256;
            }

            validateAndUpdateUI() {
                const errors = this.config.validate();
                if (errors.length > 0) {
                    // Optionally show errors, but the button state is handled by updateControlButtons
                    return false;
                }
                return true;
            }

            handleFileSelection(event) {
                try {
                    const file = event.target.files[0];
                    if (!file) {
                        debugLog('FILE: No file selected');
                        return;
                    }
                    
                    // Validate file
                    const validation = this.validateFile(file);
                    if (!validation.valid) {
                        this.showToast(validation.message, 'error');
                        this.addLog('File validation failed', 'error', validation.message);
                        return;
                    }
                    
                    this.state.selectedFile = file;
                    this.config.config.filepath = file.name; // For saving config
                    const sizeFormatted = this.formatBytes(file.size);
                    
                    // Update UI with file information
                    const selectedFileEl = document.getElementById('selectedFile');
                    if (selectedFileEl) {
                        selectedFileEl.innerHTML = `
                            <div class="config-value file-info">
                                <span class="file-icon">${this.ui.getFileIcon(file.type || file.name)}</span>
                                <div class="file-details">
                                    <div class="file-name" title="${file.name}">${file.name}</div>
                                    <div class="file-size">${sizeFormatted}</div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Update size stat
                    const sizeStatEl = document.getElementById('sizeStat');
                    if (sizeStatEl) {
                        sizeStatEl.textContent = sizeFormatted;
                    }
                    
                    // Show file preview if supported
                    this.ui.showFilePreview(file);
                    
                    this.addLog('File selected', 'success', `${file.name} (${sizeFormatted})`);
                    this.showToast(`File selected: ${file.name}`, 'success');
                    this.updateAllUI();
                    
                    debugLog('FILE: Successfully selected file: ' + file.name + ' (' + sizeFormatted + ')');
                    
                } catch (error) {
                    this.showToast('Failed to select file', 'error');
                    this.addLog('File selection error', 'error', error.message);
                    debugLog('FILE ERROR: ' + error.message);
                }
            }

            validateFile(file) {
                const maxSize = 100 * 1024 * 1024; // 100MB limit
                const minSize = 1; // At least 1 byte
                
                if (file.size === 0) {
                    return { valid: false, message: 'File is empty' };
                }
                
                if (file.size < minSize) {
                    return { valid: false, message: 'File is too small' };
                }
                
                if (file.size > maxSize) {
                    return { valid: false, message: `File is too large (max ${this.formatBytes(maxSize)})` };
                }
                
                // Check for suspicious file types (basic security)
                const suspiciousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.pif', '.com'];
                const fileExt = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
                
                if (suspiciousExtensions.includes(fileExt)) {
                    return { 
                        valid: false, 
                        message: `${fileExt.toUpperCase()} files are not allowed for security reasons` 
                    };
                }
                
                return { valid: true, message: 'File validation passed' };
            }

            async selectFile() {
                try {
                    const file = await this.system.fileManager.selectFile();
                    if (file) {
                        this.handleFileSelection({ target: { files: [file] } });
                    }
                } catch (error) {
                    this.addLog('File selection failed', 'error', error.message);
                }
            }

            saveConfiguration() {
                this.config.saveToStorage();
                this.showToast('Configuration saved to browser storage.', 'success');
            }

            showConfirmModal(title, message, onConfirm) {
                this.pendingConfirmAction = onConfirm;
                document.getElementById('confirmTitle').textContent = title;
                document.getElementById('confirmMessage').textContent = message;
                document.getElementById('confirmModal').classList.add('show');
            }

            hideConfirmModal() {
                document.getElementById('confirmModal').classList.remove('show');
            }

            confirmAction() {
                if(this.pendingConfirmAction) this.pendingConfirmAction();
                this.hideConfirmModal();
            }

            updatePhase(phase) {
                this.state.currentPhase = phase;
                document.getElementById('currentPhase').innerHTML = `<span class="neon-text purple">${phase.replace(/_/g, ' ')}</span>`;
            }

            // === MISSING METHOD IMPLEMENTATIONS ===

            exportLog() {
                try {
                    const logData = this.state.logs.map(log => ({
                        timestamp: log.timestamp,
                        type: log.type,
                        operation: log.operation,
                        details: log.details || ''
                    }));
                    
                    const exportData = {
                        timestamp: new Date().toISOString(),
                        clientVersion: 'CyberBackup Pro v3.0',
                        totalLogs: logData.length,
                        logs: logData
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `cyberbackup-log-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Log exported successfully', 'success');
                    this.addLog('Log Export', 'success', `Exported ${logData.length} log entries`);
                    debugLog('EXPORT: Log exported successfully with ' + logData.length + ' entries');
                } catch (error) {
                    this.showToast('Failed to export log', 'error');
                    this.addLog('Export Error', 'error', error.message);
                    debugLog('EXPORT ERROR: ' + error.message);
                }
            }

            clearLog() {
                this.showConfirmModal(
                    'Clear All Logs',
                    'Are you sure you want to clear all operation logs? This action cannot be undone.',
                    () => {
                        this.state.logs = [];
                        const logContainer = document.getElementById('logContainer');
                        if (logContainer) {
                            logContainer.innerHTML = '';
                        }
                        this.showToast('All logs cleared', 'info');
                        this.addLog('Log Management', 'info', 'All previous logs cleared');
                        debugLog('LOGS: All logs cleared by user');
                    }
                );
            }

            toggleAutoScroll() {
                this.state.autoScroll = !this.state.autoScroll;
                const btn = document.getElementById('autoScrollBtn');
                if (btn) {
                    btn.textContent = `üìú Auto-scroll: ${this.state.autoScroll ? 'ON' : 'OFF'}`;
                    btn.classList.toggle('active', this.state.autoScroll);
                }
                this.showToast(`Auto-scroll ${this.state.autoScroll ? 'enabled' : 'disabled'}`, 'info');
                debugLog('UI: Auto-scroll toggled to ' + this.state.autoScroll);
            }

            toggleDebug() {
                this.state.debugVisible = !this.state.debugVisible;
                const debugContent = document.getElementById('debugContent');
                const debugToggle = document.getElementById('debugToggle');
                
                if (debugContent) {
                    debugContent.classList.toggle('show', this.state.debugVisible);
                }
                
                if (debugToggle) {
                    debugToggle.setAttribute('aria-expanded', this.state.debugVisible.toString());
                    debugToggle.textContent = `üîß ${this.state.debugVisible ? 'Hide' : 'Show'} Debug`;
                }
                
                this.showToast(`Debug panel ${this.state.debugVisible ? 'shown' : 'hidden'}`, 'info');
                debugLog('UI: Debug panel toggled to ' + (this.state.debugVisible ? 'visible' : 'hidden'));
            }

            setTheme(themeName) {
                try {
                    // Use the ThemeManager to handle theme changes
                    if (this.theme && this.theme.setTheme(themeName)) {
                        this.showToast(`Theme changed to ${themeName}`, 'success');
                        this.addLog('Theme Change', 'info', `Switched to ${themeName} theme`);
                    } else {
                        // Fallback if ThemeManager not available
                        document.body.setAttribute('data-theme', themeName);
                        localStorage.setItem('cyberbackup_theme', themeName);
                        this.showToast(`Theme changed to ${themeName}`, 'success');
                        debugLog('THEME: Used fallback theme change for ' + themeName);
                    }
                } catch (error) {
                    this.showToast('Failed to change theme', 'error');
                    debugLog('THEME ERROR: ' + error.message);
                }
            }
        }
        debugLog('CyberBackupPro class defined successfully');
        
        // Enhanced Theme Manager
        if (typeof ThemeManager === 'undefined') {
            class ThemeManager { 
                constructor() {
                    this.currentTheme = 'cyberpunk';
                    this.themes = {
                        cyberpunk: {
                            name: 'Cyberpunk',
                            primary: '#FF00FF',
                            secondary: '#00FFFF',
                            accent: '#8A2BE2'
                        },
                        dark: {
                            name: 'Dark',
                            primary: '#2C3E50',
                            secondary: '#34495E',
                            accent: '#1A1A1A'
                        },
                        matrix: {
                            name: 'Matrix',
                            primary: '#00FF00',
                            secondary: '#003300',
                            accent: '#000000'
                        }
                    };
                }

                loadSavedTheme() {
                    try {
                        const saved = localStorage.getItem('cyberbackup_theme');
                        if (saved && this.themes[saved]) {
                            this.setTheme(saved);
                        } else {
                            this.setTheme('cyberpunk'); // default
                        }
                        debugLog('THEME: Loaded saved theme: ' + this.currentTheme);
                    } catch (error) {
                        debugLog('THEME ERROR loading saved theme: ' + error.message);
                        this.setTheme('cyberpunk'); // fallback
                    }
                }

                setTheme(themeName) {
                    if (!this.themes[themeName]) {
                        debugLog('THEME ERROR: Unknown theme: ' + themeName);
                        return false;
                    }

                    try {
                        this.currentTheme = themeName;
                        
                        // Update theme buttons
                        document.querySelectorAll('.theme-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        
                        const selectedBtn = document.querySelector(`.theme-btn.${themeName}`);
                        if (selectedBtn) {
                            selectedBtn.classList.add('active');
                        }
                        
                        // Apply theme to body
                        document.body.setAttribute('data-theme', themeName);
                        
                        // Store in localStorage
                        localStorage.setItem('cyberbackup_theme', themeName);
                        
                        debugLog('THEME: Successfully set theme to ' + themeName);
                        return true;
                    } catch (error) {
                        debugLog('THEME ERROR setting theme: ' + error.message);
                        return false;
                    }
                }

                getCurrentTheme() {
                    return this.currentTheme;
                }

                getAvailableThemes() {
                    return Object.keys(this.themes);
                }
            }
            window.ThemeManager = ThemeManager;
        }

        // Initialize the GUI - make it global so onclick handlers can access it
        try {
            debugLog('Starting GUI initialization...');
            console.log('About to create CyberBackupPro...');
            alert('About to create CyberBackupPro...');
            
            // Check if classes are defined
            debugLog('Checking if classes are defined...');
            if (typeof ApiClient === 'undefined') {
                throw new Error('ApiClient class not defined');
            }
            debugLog('ApiClient class is defined');
            
            if (typeof ConfigManager === 'undefined') {
                throw new Error('ConfigManager class not defined'); 
            }
            debugLog('ConfigManager class is defined');
            
            if (typeof IntervalManager === 'undefined') {
                throw new Error('IntervalManager class not defined');
            }
            debugLog('IntervalManager class is defined');
            
            if (typeof CyberBackupPro === 'undefined') {
                throw new Error('CyberBackupPro class not defined');
            }
            debugLog('CyberBackupPro class is defined');
            
            console.log('All classes are defined, creating CyberBackupPro...');
            debugLog('All classes verified, instantiating CyberBackupPro...');
            window.gui = new CyberBackupPro();
            console.log('CyberBackupPro created successfully!');
            debugLog('CyberBackupPro instance created successfully');
            alert('CyberBackupPro created successfully! window.gui is now available.');
            
            // Test the method exists
            if (typeof window.gui.handlePrimaryAction === 'function') {
                console.log('handlePrimaryAction method is available');
                debugLog('handlePrimaryAction method verified');
            } else {
                throw new Error('handlePrimaryAction method not found on gui object');
            }
            
            debugLog('=== GUI INITIALIZATION COMPLETED SUCCESSFULLY ===');
            
        } catch (error) {
            debugLog('ERROR during initialization: ' + error.message);
            console.error('ERROR creating CyberBackupPro:', error);
            alert('ERROR creating CyberBackupPro: ' + error.message + '\nStack: ' + error.stack);
        }

        // ...existing code...
    </script>
</body>
</html>